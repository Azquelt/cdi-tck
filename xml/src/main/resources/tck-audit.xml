<specification 
    xmlns="http://jboss.com/products/weld/tck/audit"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://jboss.com/products/weld/tck/audit http://snapshots.jboss.org/maven2/org/hibernate/tck-utils-api/0.9-SNAPSHOT/tck-utils-api-0.9-20090220.134140-13-audit.xsd"
    name="JSR-299: Java Contexts and Dependency Injection" 
    version="Revised Public Review Draft">

  <section id="2" title="Bean definition">
  
  </section>
  
  <section id="2.2" title="Bean types">
  
  </section>
  
  <section id="2.3" title="Bindings">
  
  </section>
    
  <section id="2.3.1" title="Default binding type">
    
  </section>
    
  <section id="2.3.3" title="Declaring the bindings of a bean using annotations">

  </section>
  
  <section id="2.3.4" title="Declaring the bindings of a bean using XML">
  
    <assertion id="a">
      <text>If a bean is declared in beans.xml, bindings may be specified using the binding type names</text>
    </assertion>
  
  </section>
  
  <section id="2.3.5" title="Specifying bindings of an injected field">
    
    <assertion id="c">
      <text>For a bean defined in XML, the bindings of a field may be specified using XML</text>
    </assertion>
    
    <assertion id="d">
      <text>When the bindings of a field are specified using XML, any binding annotations of the field are ignored</text>
    </assertion>
  </section>
  
  <section id="2.3.6" title="Specifying bindings of a method or constructor parameter">
    
    <assertion id="e">
      <text>For a bean defined in XML, the bindings of a method parameter may be specified using XML</text>
    </assertion>
    
    <assertion id="f">
      <text>When the bindings of a parameter are specified using XML, any binding annotations of the parameter are ignored</text>
    </assertion>
  </section>
  
  <section id="2.4" title="Scopes">
    
  </section>
  
  <section id="2.4.1" title="Built-in scope types">
        
  </section>
  
  <section id="2.4.3" title="Declaring the bean scope using annotations">

  </section>
  
  <section id="2.4.4" title="Declaring the bean scope using XML">
    <assertion id="a">
      <text>If the bean is declared in beans.xml, the scope may be specified using the scope annotation type name</text>
    </assertion>
    
    <assertion id="b">
      <text>If more than one scope type is specified in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="c">
      <text>A scope type may be specified using a stereotype declared in XML, as defined in Section 2.7.3, "Declaring the stereotypes for a bean using XML"</text>
    </assertion>
  </section>
  
  <section id="2.4.5" title="Default scope">
    <assertion id="a">
      <text>When no scope is explicitly declared by annotating the bean class or producer method or field, or by using XML, the scope of a bean is defaulted</text>
    </assertion>
    
  </section>
  
  <section id="2.5.1" title="Built-in deployment types">
  
  </section>    
  
  <section id="2.5.2" title="Defining new deployment types">
  
  </section>
  
  <section id="2.5.3" title="Declaring the deployment type of a bean using annotations">
  
  </section>
  
  <section id="2.5.4" title="Declaring the deployment type of a bean using XML">
    <assertion id="a">
      <text>When a bean is declared in beans.xml, the deployment type may be specified using a tag with the annotation type name</text>
    </assertion>
    
    <assertion id="b">
      <text>If more than one deployment type is specified in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="c">
      <text>A deployment type may be specified using a stereotype declared in XML, as defined in Section 2.7.3, "Declaring the stereotypes for a bean using XML".</text>
    </assertion>
  </section>
  
  <section id="2.5.5" title="Default deployment type">
    
  </section>
  
  <section id="2.5.6" title="Enabled deployment types">
  
  </section>
  
  <section id="2.6" title="Bean names">
  
  </section>
  
  <section id="2.6.1" title="Declaring the bean name using annotations">
  
  </section>
  
  <section id="2.6.2" title="Declaring the bean name using XML">
    
    <assertion id="a">
      <text>If the bean is declared in beans.xml, the name may be specified using |&lt;Named&gt;|</text>
    </assertion>
    
    <assertion id="b">
      <text>If the |&lt;Named&gt;| element is empty, the default name is assumed</text>
    </assertion>
  </section>
  
  <section id="2.6.3" title="Default bean names">
    
    <assertion id="d">
      <text>A default name must be assigned by the container when an empty |&lt;Named&gt;| element is specified by a bean defined in XML</text>
    </assertion>
    
  </section>
  
  <section id="2.6.4" title="Beans with no name">
  
    <assertion id="a">
      <text>If neither |&lt;Named&gt;| nor |@Named| is specified, by the bean or its stereotypes, a bean has no name</text>
    </assertion>
    
  </section>
  
  <section id="2.7" title="Stereotypes">
  
  </section>
  
  <section id="2.7.1" title="Defining new stereotypes">
 
  </section>
  
  <section id="2.7.1.1" title="Declaring the default scope and deployment type for a stereotype">

  </section>
  
  <section id="2.7.1.2" title="Specifying interceptor bindings for a stereotype">
  
  </section>
  
  <section id="2.7.1.3" title="Specifying name defaulting for a stereotype">
   
  </section>
  
  <section id="2.7.1.4" title="Restricting bean scopes and types using a stereotype">
   
  </section>
  
  <section id="2.7.1.5" title="Stereotypes with additional stereotypes">
    
  </section>
  
  <section id="2.7.2" title="Declaring the stereotypes for a bean using annotations">
    
  </section>
  
  <section id="2.7.3" title="Declaring the stereotypes for a bean using XML">
    <assertion id="a">
      <text>If the bean is declared in beans.xml, stereotypes may be declared using the stereotype annotation type name</text>
    </assertion>
  </section>
  
  <section id="2.7.4" title="Stereotype restrictions">
  </section>
  
  <section id="2.7.5" title="Built-in stereotypes">
    
  </section>

  <section id="3" title="Bean Implementation">
  
  </section>
     
  <section id="3.1" title="Restriction upon bean instantiation">
    
  </section>
 
  <section id="3.2" title="Simple beans">
    
    <assertion id="e">
      <text>Multiple simple beans may share the same bean class. This occurs when beans are defined using XML. Only one simple bean per bean class may be defined using annotations.</text>
    </assertion>
        
  </section>
  
  <section id="3.2.1" title="Which Java classes are beans?">

    <assertion id="r">
      <text>Additional simple beans with the same bean class may be defined using XML, by specifying the class in |beans.xml|.</text>    
    </assertion>
    
  </section>
  
  <section id="3.2.2" title="Bean types of a simple bean">
    
  </section>
  
  <section id="3.2.3" title="Declaring a simple bean using annotations">
 
  </section>
  
  <section id="3.2.4" title="Declaring a simple bean using XML">
    <assertion id="a">
      <text>Simple beans may be declared in |beans.xml| using the bean class name</text>
    </assertion>
    
    <assertion id="b">
      <text>A simple bean may even be declared at any injection point declared in XML, as defined in Section 9.9, "Inline bean declarations", in which case no bindings are specified.</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a simple bean defined in XML is a parameterized type , a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="d">
      <text>If the bean class of a simple bean defined in XML is a non-static inner class, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="da">
      <text>If the bean class of a simple bean defined in XML is a static inner class, a |DefinitionException| is not thrown.</text>
    </assertion>
    
    <assertion id="e">
      <text>If the bean class of a simple bean defined in XML is an abstract class, and the simple bean is not a decorator, a |DefinitionException|
is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="f">
      <text>If the bean class of a simple bean defined in XML is annotated @Interceptor, then the bean must be explicitly declared as an interceptor in XML, as defined in Section A.3.5.2, "Declaring an interceptor using XML". If a simple bean defined in XML has a bean class annotated |@Interceptor| and is not declared as an interceptor in XML, a |DefinitionException| is
thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="g">
      <text>If the bean class of a simple bean defined in XML is annotated @Interceptor, then the bean must be explicitly declared as an interceptor in XML, as defined in Section A.3.5.2, "Declaring an interceptor using XML". If a simple bean defined in XML has a bean class annotated |@Interceptor| and is not declared as an interceptor in XML, a |DefinitionException| is
thrown by the container at deployment time.</text>
    </assertion>
  </section>
  
  <section id="3.2.5" title="Simple beans with the @New binding">
    
  </section>
  
  <section id="3.2.6" title="Bean constructors">
    
  </section>
  
  <section id="3.2.6.1" title="Declaring a bean constructor using annotations">
  
  </section>
  
  <section id="3.2.6.2" title="Declaring a bean constructor using XML">
  
    <assertion id="a">
      <text>For a simple bean defined using XML, the bean constructor may be specified by listing the parameter types of the constructer, in order, as direct children of the element that declares the bean</text>
    </assertion>
    
    <assertion id="b">
      <text>If a simple bean defined using XML does not explicitly declare constructor parameters in XML, the constructor that accepts no parameters is the bean constructor</text>
    </assertion>
    
    <assertion id="c">
      <text>If a simple bean declared in XML does not have a constructor with the parameter types declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="d">
      <text>When a bean constructor is declared in XML, the container ignores binding annotations applied to Java constructor parameters</text>
    </assertion>
  
  </section>
  
  <section id="3.2.6.3" title="Bean constructor parameters">
    
  </section>
  
  <section id="3.2.7" title="Specializing a simple bean">
    <assertion id="e">
      <text>If a simple bean X defined in XML declares the |&lt;Specializes&gt;| element, then the bean class of X must be the bean class of another simple bean Y defined using annotations. Then X inherits all bindings of Y, and if Y has a name, X has the same name as Y</text>
    </assertion>
  </section>
  
  <section id="3.2.8" title="Default name for a simple bean">

  </section>
  
  <section id="3.3" title="Session beans">
    
    <assertion id="e">
      <text>Note that multiple session beans may share the same bean class. This occurs when beans are defined using XML</text>
    </assertion>
    
  </section>
  
  <section id="3.3.1" title="EJB remove methods of session beans">
    
  </section>
  
  <section id="3.3.2" title="Which EJBs are beans?">
    
  </section>
  
  <section id="3.3.3" title="Bean types of a session bean">
    
  </section>
  
  <section id="3.3.4" title="Declaring a session bean using annotations">
  
  </section>
  
  <section id="3.3.5" title="Declaring a session bean using XML">
    <assertion id="a">
      <text>Session beans may be declared in |beans.xml| using the bean class name (for EJBs defined using a component-defining annotation) or bean class and EJB name (for EJBs defined in |ejb-jar.xml|)</text>
    </assertion>
    
    <assertion id="b">
      <text>The ejbName attribute declares the EJB name of an EJB defined in |ejb-jar.xml|</text>
    </assertion>
    
    <assertion id="c">
      <text>If an entity bean class is declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>

    <assertion id="d">
      <text>If a message-driven bean class is declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="3.3.6" title="Session beans with the @New binding">

    
  </section>
  
  <section id="3.3.7" title="Specializing a session bean">
    
    <assertion id="e">
      <text>If a session bean X defined in XML declares the |&lt;Specializes&gt;| element, then the bean class of X must be the bean class of another session bean Y defined using annotations. Then X inherits all bindings of Y, and if Y has a name, X has the same name as Y.</text>
    </assertion>
  </section>
  
  <section id="3.3.8" title="Default name for a session bean">
    
  </section>
  
  <section id="3.3.9" title="Session bean proxies">
 
  </section>
  
  <section id="3.4" title="Producer methods">
  
  </section>
  
  <section id="3.4.1" title="Bean types of a producer method">
  
  </section>
  
  <section id="3.4.2" title="Declaring a producer method using annotations">
  
  </section>
  
  <section id="3.4.3" title="Declaring a producer method using XML">
  
    <assertion id="a">
      <text>For a bean defined in XML, a producer method may be declared using the method name, the |&lt;Produces&gt;| element, the return type, and the parameter types of the method</text>
    </assertion>
    
    <assertion id="b">
      <text>When a producer method is declared in XML, the container ignores binding annotations applied to the Java method or method parameters</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a bean declared in XML does not have a method with the name and parameter types declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="3.4.4" title="Producer method parameters">
    
  </section>
  
  <section id="3.4.5" title="Specializing a producer method">
    
  </section>
  
  <section id="3.4.6" title="Disposal methods">

  </section>
  
  <section id="3.4.7" title="Disposed parameter of a disposal method">
    
  </section>
  
  <section id="3.4.8" title="Declaring a disposal method using annotations">
    
  </section>
  
  <section id="3.4.9" title="Declaring a disposal method using XML">
  
    <assertion id="a">
      <text>For a bean defined in XML, a disposal method may be declared using the method name, the &lt;Disposes&gt; element, and the parameter types of the method</text>
    </assertion>
    
    <assertion id="b">
      <text>When a disposal method is declared in XML, the container ignores binding annotations applied to the Java method parameter</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a bean declared in XML does not have a method with the name and parameter types declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="3.4.10" title="Disposal method parameters">
  
  </section>
  
  <section id="3.4.11" title="Disposal method resolution">
  
  </section>
  
  <section id="3.4.12" title="Default name for a producer method">
  
  </section>
  
  <section id="3.5" title="Producer fields">
  
  </section>
  
  <section id="3.5.1" title="Bean types of a producer field">
    
  </section>
  
  <section id="3.5.2" title="Declaring a producer field using annotations">
  
  </section>
  
  <section id="3.5.3" title="Declaring a producer field using XML">
  
    <assertion id="a">
      <text>For a bean defined in XML, a producer field may be declared using the field name, the |&lt;Produces&gt;| element, and the type</text>
    </assertion>
    
    <assertion id="b">
      <text>When a producer field is declared in XML, the container ignores binding annotations applied to the Java field</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a bean declared in XML does not have a field with the name and type declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  
  </section>
  
  <section id="3.5.4" title="Default name for a producer field">
    
  </section>
  
  <section id="3.6" title="Resources">
    
  </section>
  
  <section id="3.6.1" title="Declaring a resource using XML">
  
  </section>
  
  <section id="3.7" title="JMS resources">
    
  </section>
  
  <section id="3.7.1" title="Bean types of a JMS resource">
  
  </section>
  
  <section id="3.7.2" title="Declaring a JMS resource using XML">
    
  </section>
  
  <section id="3.8" title="Injected fields">
 
  </section>
  
  <section id="3.8.1" title="Declaring an injected field using annotations">
    
  </section>
  
  <section id="3.8.2" title="Declaring an injected field using XML">
    <assertion id="a">
      <text>For bean defined in XML, an injected field may be declared using the field name and a child element representing the type of the field</text>
    </assertion>
    
    <assertion id="b">
      <text>When an injected field is declared in XML, the container ignores binding annotations applied to the Java field</text>
    </assertion>
    
    <assertion id="c">
      <text>If the type element does not declare any binding, the default binding |@Current| is assumed</text>
    </assertion>
    
    <assertion id="d">
      <text>If the bean class of a bean declared in XML does not have a field with the name and type declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="e">
      <text>Check fields declared in XML and Java injected</text>
      <note>Sanity check</note>
    </assertion>
  </section>
  
  <section id="3.9" title="Initializer methods">
    
  </section>
  
  <section id="3.9.1" title="Declaring an initializer method using annotations">
    
  </section>
  
  <section id="3.9.2" title="Declaring an initializer method using XML">
  
    <assertion id="a">
      <text>For a bean defined in XML, an initializer method may be declared using the method name, the |&lt;Initializer&gt;| element and the parameter types of the method</text>
    </assertion>
    
    <assertion id="b">
      <text>When an initializer method is declared in XML, the container ignores binding annotations applied to the Java method parameters</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a bean declared in XML does not have a method with the name and parameter types declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="3.9.3" title="Initializer method parameters">
   
  </section>
  
  <section id="3.10" title="Support for Common Annotations">
    
  </section>
  
  <section id="3.11" title="The Bean object for a bean">
    
  </section>
  
  <section id="4" title="Inheritance, specialization and realization">

  </section>
  
  <section id="4.1" title="Inheritance of type-level metadata">
    
    <assertion id="ea">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X is annotated with a _binding type_ Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare an annotation of type Z using XML.</text>
    </assertion>
    
    <assertion id="eb">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X is annotated with a _stereotype_ Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare an annotation of type Z using XML.</text>
    </assertion>
    
    <assertion id="ec">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X is annotated with an _interceptor binding type_ Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare an annotation of type Z using XML.</text>
    </assertion>
    
    <assertion id="ed">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X is annotated with a _binding type_ Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare an annotation of type Z using XML.</text>
    </assertion>
    
    <assertion id="ee">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X is annotated with a _stereotype_ Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare an annotation of type Z using XML.</text>
    </assertion>
    
    <assertion id="ef">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X is annotated with an _interceptor binding type_ Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare an annotation of type Z using XML.</text>
    </assertion>
    
    <assertion id="fa">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X is annotated with a scope type Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare a scope type using XML.</text>
    </assertion>
    
    <assertion id="fb">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X is annotated with a scope type Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare a scope type using XML.</text>
    </assertion>
    
    <assertion id="ga">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X is annotated with a deployment type Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare a deployment type using XML.</text>
    </assertion>
    
    <assertion id="gb">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X is annotated with a deployment type Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and Y does not explicitly declare a deployment type using XML.</text>
    </assertion>
        
    <assertion id="ha">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, the scope types and deployment types explicitly declared by and inherited from the class X take precedence over default scope and deployment types declared by stereotypes.</text>
    </assertion>    
    
    <assertion id="hb">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, the scope types and deployment types explicitly declared by and inherited from the class X take precedence over default scope and deployment types declared by stereotypes.</text>
    </assertion>  
    
  </section>
  
  <section id="4.2" title="Inheritance of member-level metadata">
    
    <assertion id="ga">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares an injected field x then Y inherits x, unless Y explicitly declares x using XML.</text>
    </assertion>
    
    <assertion id="gb">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares an injected field x then Y inherits x, unless Y explicitly declares x using XML.</text>
    </assertion>
    
    <assertion id="ha">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares an _initializer method_ x() then Y inherits x(), unless Y explicitly declares x() using XML</text>
    </assertion>
    
    <assertion id="hb">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a _@PostConstruct method_ x() then Y inherits x(), unless Y explicitly declares x() using XML</text>
    </assertion>
    
    <assertion id="hc">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a _@PreDestroy method_ x() then Y inherits x(), unless Y explicitly declares x() using XML</text>
    </assertion>
    
    <assertion id="hd">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares an _initializer method_ x() then Y inherits x(), unless Y explicitly declares x() using XML</text>
    </assertion>
    
    <assertion id="he">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a _@PostConstruct method_ x() then Y inherits x(), unless Y explicitly declares x() using XML</text>
    </assertion>
    
    <assertion id="hf">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a _@PreDestroy method_ x() then Y inherits x(), unless Y explicitly declares x() using XML</text>
    </assertion>
    
    <assertion id="ia">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static method x() annotated with an interceptor binding type Z then Y inherits the binding, unless Y explicitly declares x() using XML.</text>
    </assertion>
    
    <assertion id="ib">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static method x() annotated with an interceptor binding type Z then Y inherits the binding, unless Y explicitly declares x() using XML.</text>
    </assertion>
    
    <assertion id="ja">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static _producer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="jb">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static _producer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>    
    
    <assertion id="jc">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static _disposal method_ x() then Y does not inherit this method, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="jd">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static _disposal method_ x() then Y does not inherit this method, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>  
    
    <assertion id="je">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static _observer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="jf">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static _observer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>    
    
    <assertion id="jg">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static _producer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="jh">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static _producer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>    
    
    <assertion id="ji">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static _disposal method_ x() then Y does not inherit this method, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="jj">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static _disposal method_ x() then Y does not inherit this method, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>  
    
    <assertion id="jk">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static _observer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="jl">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static _observer method_ x() then Y does not inherit this method, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>     
    
    <assertion id="ka">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static producer field x then Y does not inherit this field, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="kb">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if X declares a non-static producer field x then Y does not inherit this field, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>
    
    <assertion id="kc">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static producer field x then Y does not inherit this field, unless Y is explicitly declared to _specialize_ X.</text>
    </assertion>
    
    <assertion id="kd">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if X declares a non-static producer field x then Y does not inherit this field, unless Y is explicitly declared to _realize_ X.</text>
    </assertion>
    
    <assertion id="la">
      <text>For class X which is the bean class of a _simple_ bean Y declared using XML, if Y is a decorator and X declares a delegate attribute x then Y inherits x, unless Y explicitly declares a delegate attribute using XML.</text>
    </assertion>
    
    <assertion id="lb">
      <text>For class X which is the bean class of a _session_ bean Y declared using XML, if Y is a decorator and X declares a delegate attribute x then Y inherits x, unless Y explicitly declares a delegate attribute using XML.</text>
    </assertion>
  </section>
  
  <section id="4.3" title="Specialization">
    
  </section>
  
  <section id="4.3.1" title="Using specialization">
  
    <assertion id="b">
      <text>A bean declared using XML may declare that it specializes a lower-priority bean using the |&lt;Specializes&gt;| element</text>
    </assertion>
    
  </section>
  
  <section id="4.3.2" title="Direct and indirect specialization">
    <assertion id="a" testable="false">
      <text>The |@javax.inject.Specializes| annotation or |&lt;Specializes&gt;| XML element is used to indicate that one bean directly specializes another bean</text>
      <note>A statement of intent</note>
    </assertion>
    
  </section>
  
  <section id="4.3.3" title="Inconsistent specialization">
    
    <assertion id="b" testable="false">
      <text>Any bean that extends a generic class may declare that the generic class is the bean class, in the case of a bean declared using XML and then explicitly declare that it realizes the generic class.</text>
      <note>A statement of intent</note>
    </assertion>
  
  </section>
  
  <section id="4.4.1" title="Using realization">
    
    <assertion id="b" testable="false">
      <text>A bean declared using XML may declare that it realizes a generic class using the |&lt;Realizes&gt;| element.</text>
      <note>A statement of intent</note>
    </assertion>
    
  </section>
  
  <section id="5" title="Lookup, dependency injection and EL resolution">
   
  </section>
  
  <section id="5.1" title="Unsatisfied and ambiguous dependencies">
    
  </section>
  
  <section id="5.2" title="Primitive types and null values">
     
  </section>
  
  <section id="5.3" title="Injected reference validity">
    
  </section>
  
  <section id="5.4" title="Client proxies">
    
  </section>
  
  <section id="5.4.1" title="Unproxyable bean types">

  </section>
  
  <section id="5.5" title="The default binding at injection points">
    
  </section>
  
  <section id="5.6" title="Injection point metadata">
    
    <assertion id="bd">
      <text>An injection point declared in XML has it's bindings determined according to Section 9.10, "Specifying bean types and bindings"</text>
    </assertion>
    
  </section>
  
  <section id="5.6.1" title="Injecting InjectionPoint">
  
  </section>
  
  <section id="5.7" title="The Manager object">
  
  </section>
  
  <section id="5.7.1" title="Resolving dependencies">
  
  </section>
  
  <section id="5.8" title="Dynamic lookup">
  
  </section>    
  
  <section id="5.9" title="Typesafe resolution algorithm">
    
  </section>
  
  <section id="5.9.1" title="Binding annotations with members">
   
  </section>
  
  <section id="5.9.2" title="Multiple bindings">
   
  </section>
  
  <section id="5.10" title="EL name resolution">
  
  </section>
  
  <section id="5.11" title="Name resolution algorithm">
    
  </section>
  
  <section id="5.12" title="Injection into non-contextual objects">
    
  </section>
  
  <section id="5.12.1" title="Non-contextual instances of session beans">
    
  </section>
  
  <section id="5.12.2" title="Message-driven beans">
   
  </section>
  
  <section id="5.12.3" title="Servlets">
    
  </section>
  
  <section id="6" title="Bean lifecycle">
 
  </section>
  
  <section id="6.1" title="The Contextual interface">
 
  </section>
  
  <section id="6.2" title="Creation">

    
    <assertion id="e">
      <text>The |Contextual.create()| method sets any initial field values defined in XML</text>
    </assertion>
  </section>
  
  <section id="6.4" title="Lifecycle of simple beans">
    
    <assertion id="f">
      <text>When the |create()| method of the |Bean| object that represents a simple bean is called, after injected fields are initialized the container initializes the values of any fields with initial values specified in XML, as defined in Section 9.5.5, "Field initial value declarations".</text>
    </assertion>
    
    <assertion id="g">
      <text>When the |create()| method of the |Bean| object that represents a simple bean is called, after the values of fields with initial values specified in XML are initialized the container calls all initializer methods. For each initializer method parameter, the container passes the object
returned by |Manager.getInstanceToInject()|</text>
    </assertion>
    
  </section>
  
  <section id="6.5" title="Lifecycle of stateful session beans">
    
  </section>
  
  <section id="6.6" title="Lifecycle of stateless session and singleton beans">
    
  </section>
  
  <section id="6.7" title="Lifecycle of producer methods">
   
  </section>
  
  <section id="6.8" title="Lifecycle of producer fields">
    
  </section>
  
  <section id="6.9" title="Lifecycle of resources">
   
  </section>
  
  <section id="6.10" title="Lifecycle of JMS resources">
    
  </section>
  
  <section id="6.11" title="Lifecycle of EJBs">

    <assertion id="b">
      <text>When the EJB container creates a new instance of an EJB, after Java EE injection has been performed and before the |@PostConstruct| callback occurs the container must initialize the values of any fields with initial values specified in XML, as defined in Section 9.5.5, "Field initial value declarations"</text>
    </assertion>
    
  </section>
  
  <section id="6.12" title="Lifecycle of servlets">

  </section>
  
  <section id="7" title="Events">
  
  </section>
  
  <section id="7.1" title="Event types and binding types">
  
  </section>
  
  <section id="7.2" title="Firing an event via the Manager interface">
    
  </section>
  
  <section id="7.3" title="Observing events via the Observer interface">
   
  </section>
  
  <section id="7.4" title="Observer notification">
  
  </section>
  
  <section id="7.5" title="Observer methods">

  </section>
  
  <section id="7.5.1" title="Event parameter of an observer method">

  </section>
  
  <section id="7.5.2" title="Declaring an observer method using annotations">
 
  </section>
  
  <section id="7.5.3" title="Declaring an observer method using XML">
    <assertion id="a">
      <text>For a beans defined in XML, an observer method may be declared using the method name, the |&lt;Observes&gt;| element, and the parameter types of the method</text>
    </assertion>
    
    <assertion id="b">
      <text>When an observer method is declared in XML, the container ignores binding annotations applied to the Java method parameters</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a bean declared in XML does not have a method with parameters that match those declared in XML, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="7.5.4" title="Observer method parameters">

  </section>
  
  <section id="7.5.5" title="Conditional observer methods">
    
    <assertion id="c">
      <text>Conditional observer methods may be declared in XML by adding a child |&lt;IfExists&gt;| element to the |&lt;Observes&gt;| element</text>
    </assertion>
  </section>
  
  <section id="7.5.6" title="Transactional observer methods">
    
    <assertion id="f">
      <text>A transactional observer method may be declared by ~annotating the event parameter of the observer method~ or in XML by a child element of the &lt;Observes&gt; element</text>
    </assertion>
    
    <assertion id="g">
      <text>A transactional observer method may be declared by annotating the event parameter of the observer method or ~in XML by a child element of the |&lt;Observes&gt;| element~</text>
    </assertion>
    
  </section>
  
  <section id="7.5.7" title="Asynchronous observer methods">
    <assertion id="a">
      <text>An asynchronous observer method may be declared by ~annotating the event parameter of the observer method |@javax.event.Asynchronously|~ or in XML by a child |&lt;Asynchronously&gt;| element of the |&lt;Observes&gt;| element</text>
    </assertion>
    
  </section>
  
  <section id="7.5.8" title="Observer object for an observer method">
     
  </section>
  
  <section id="7.5.9" title="Observer invocation context">
    
  </section>
  
  <section id="7.6" title="The Event interface">
    
  </section>
  
  <section id="7.7" title="Observer resolution">
    
  </section>
  
  <section id="7.7.1" title="Event binding types with members">
    
  </section>
  
  <section id="7.7.2" title="Multiple event bindings">
   
  </section>
  
  <section id="7.8" title="JMS event mappings">
    
  </section>
  
  <section id="8" title="Scopes and contexts">
  
  </section>
  
  <section id="8.1" title="The Context interface">
    
  </section>
  
  <section id="8.2" title="Normal scopes and pseudo-scopes">
    
  </section>
  
  <section id="8.3" title="Dependent pseudo-scope">
  
  </section>
  
  <section id="8.3.1" title="Dependent objects">
    
  </section>
  
  <section id="8.3.2" title="Dependent object destruction">
  
    
  </section>
  
  <section id="8.4" title="Passivating scopes and serialization">
    
  </section>
  
  <section id="8.5" title="Context management for built-in scopes">
  
  </section>
  
  <section id="8.5.1" title="Request context lifecycle">
  
  </section>
  
  <section id="8.5.2" title="Session context lifecycle">
  
  </section>
  
  <section id="8.5.3" title="Application context lifecycle">
  
  </section>
  
  <section id="8.5.4" title="Conversation context lifecycle">
  
    
  </section>
  
  <section id="8.6" title="Context management for custom scopes">
  
  </section>
  
  <section id="9" title="XML based metadata">
    <assertion id="a">
      <text>XML-based bean declarations define additional beans they do not redefine or disable any bean that was declared via annotations</text>
    </assertion>
    
  </section>  
  
  <section id="9.1" title="XML namespace for a Java package">
    
  </section>
  
  <section id="9.2" title="XML namespace aggregating multiple packages">

  </section>
  
  <section id="9.2.1" title="The Java EE namespace">
    
  </section>
  
  <section id="9.3" title="Standard schema location for a namespace">
    
  </section>
  
  <section id="9.4" title="Stereotype, binding type and interceptor binding type declarations">
    
  </section>
  
  <section id="9.4.1" title="Child elements of a stereotype declaration">
    
  </section>
  
  <section id="9.4.2" title="Child elements of an interceptor binding type declaration">
  
  </section>
  
  <section id="9.5" title="Bean declarations">
  
    <assertion id="a">
      <text>An XML element that appears as a direct child of the root |&lt;Beans&gt;| element is interpreted as a bean declaration if it is not a |&lt;Deploy&gt;|, |&lt;Interceptors&gt;| or |&lt;Decorators&gt;| element in the Java EE namespace, and does not have a direct child |&lt;BindingType&gt;|,|&lt;InterceptorBindingType&gt;| or |&lt;Stereotype&gt;| element in the Java EE namespace</text>    
    </assertion>
    
    <assertion id="b">
      <text>The name of the XML element is interpreted as a Java type. The container inspects the Java type and other metadata to determine what kind of bean is being declared. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="c">
      <text>If the type is |javax.jms.Queue| or |javax.jms.Topic|, it declares a JMS resource, as defined in Section 3.7.2, "Declaring a JMS resource using XML"</text>
    </assertion>
    
    <assertion id="d">
      <text>If the element has a child |&lt;Resource&gt;|, |&lt;PersistenceContext&gt;|, |&lt;PersistenceUnit&gt;|, |&lt;EJB&gt;| or |&lt;WebServiceRef&gt;| element, it declares a resource, as defined in Section 3.6.1, "Declaring a resource using XML"</text>
    </assertion>
    
    <assertion id="e">
      <text>If the type is an EJB bean class, a session bean was declared, as defined in Section 3.3.5, "Declaring a session bean using XML"</text>
    </assertion>
    
    <assertion id="f">
      <text>If the type is a concrete class, is not an EJB bean class, and is not a parameterized type, a simple bean was declared, as defined in Section 3.2.4, "Declaring a simple bean using XML"</text>
    </assertion>
    
    <assertion id="g">
      <text>Otherwise, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="h">
      <text>Inline bean declarations may occur at injection points, as defined in Section 9.9, "Inline bean declarations". Inline bean declarations always declare simple beans</text>
    </assertion>
  
  </section>
  
  <section id="9.5.1" title="Child elements of a bean declaration">
    <assertion id="a">
      <text>If the child element can be interpreted as a Java annotation type, the container interprets the child element as declaring type-level metadata</text>
    </assertion>
    
    <assertion id="b">
      <text>If the child element can be interpreted as a Java class or interface, the container interprets the child element as declaring a parameter of the bean constructor</text>
    </assertion>
    
    <assertion id="c">
      <text>If the child element namespace is the same as the namespace of the parent, the container interprets the element as declaring a method or field of the bean</text>
    </assertion>
    
    <assertion id="d">
      <text>If the name of the child element matches the name of both a method and a field of the bean class, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="e">
      <text>If the name of the child element matches the name of a method of the bean class, is it interpreted to represent that method</text>
    </assertion>
    
    <assertion id="f">
      <text>If the name of the child element matches the name of a field of the bean class, is it interpreted to represent that field</text>
    </assertion>
    
    <assertion id="g">
      <text>Otherwise, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="9.5.2" title="Type-level metadata for a bean">
    <assertion id="a">
      <text>Type-level metadata is specified via direct child elements of the bean declaration that represent Java annotation types</text>
    </assertion>
    
    <assertion id="b">
      <text>The child element is interpreted as a Java annotation type</text>
    </assertion>
    
    <assertion id="c">
      <text>If the annotation type is a deployment type, the deployment type of the bean was declared, as defined in Section 2.5.4, "Declaring the deployment type of a bean using XML"</text>
    </assertion>
    
    <assertion id="d">
      <text>If the annotation type is a scope type, the scope of the bean was declared, as defined in Section 2.4.4, "Declaring the bean scope using XML"</text>
    </assertion>
    
    <assertion id="e">
      <text>If the annotation type is a binding type, a binding of the bean was declared, as defined in Section 2.3.4, "Declaring the bindings of a bean using XML"</text>
    </assertion>
    
    <assertion id="f">
      <text>If the annotation type is an interceptor binding type, an interceptor binding of the bean was declared, as defined in Section A.3.6.2, "Binding an interceptor using XML"</text>
    </assertion>
    
    <assertion id="g">
      <text>If the annotation type is a stereotype, a stereotype of the bean was declared, as defined in Section 2.7.3, "Declaring the stereotypes for a bean using XML"</text>
    </assertion>
    
    <assertion id="h">
      <text>If the annotation type is |javax.annotation.Name|, the name of the bean was declared, as defined in Section 2.6.2, "Declaring the bean name using XML"</text>
    </assertion>
    
    <assertion id="i">
      <text>If the annotation type is |javax.inject.Specializes|, the bean was declared to directly specialize the bean with the same bean class that was defined using annotations, as specified in Section 3.2.7, "Specializing a simple bean" and Section 3.3.7, "Specializing a session bean"</text>
    </assertion>
    
    <assertion id="j">
      <text>If the annotation type is |javax.inject.Realizes|, the bean was declared to realize the bean with the same bean class that was defined using annotations</text>
    </assertion>
    
    <assertion id="k">
      <text>If the annotation type is |javax.interceptor.Interceptor|, or |javax.decorator.Decorator| the bean is an interceptor or decorator, as defined in Section 9.7, "Interceptor and decorator declarations"</text>
    </assertion>
    
    <assertion id="l">
      <text>If the annotation type is |javax.annotation.Resource|, |javax.ejb.EJB|, |javax.xml.ws.WebServiceRef|, |javax.persistence.PersistenceContext| or |javax.persistence.PersistenceUnit|, the metadata for a resource or JMS resource was declared, as defined in Section 3.6.1, "Declaring a resource using XML" and Section 3.7.2, "Declaring a JMS resource using XML"</text>
    </assertion>
    
    <assertion id="m">
      <text>Otherwise, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="9.5.3" title="Bean constructor declarations">
    <assertion id="a">
      <text>The bean constructor for a simple bean is declared by the list of direct child elements of the bean declaration that represent Java class or interface types</text>
    </assertion>
    
    <assertion id="b">
      <text>The container interprets these elements as declaring parameters of the constructor</text>
    </assertion>
    
    <assertion id="c">
      <text>Each constructor parameter declaration is interpreted as an injection point declaration, as specified in Section 9.8, "Injection point declarations"</text>
    </assertion>
    
    <assertion id="d">
      <text>If the simple bean class has exactly one constructor such that the constructor has the same number of parameters as the bean declaration has constructor parameter declarations, and the Java type represented by each constructor parameter declaration is assignable to the Java type of the corresponding constructor parameter then the element is interpreted to represent that constructor, and that constructor is the bean constructor</text>
    </assertion>
    
    <assertion id="e">
      <text>If more than one constructor exists which satisfies these conditions, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="f">
      <text>If no constructor of the simple bean class satisfies these conditions, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="g">
      <text>For any constructor parameter, the bean type declared in XML may be a subtype of the Java parameter type. In this case, the container will use the bean type declared in XML when resolving the dependency</text>
    </assertion>
  </section>
  
  <section id="9.5.4" title="Fields of a bean">
    <assertion id="a">
      <text>A field of a bean is declared by a direct child element of the bean declaration. The name of the field is the same as the name of the element</text>
    </assertion>
    
    <assertion id="b">
      <text>If the bean class has exactly one field with the same name as the child element, then the child element is interpreted to represent that field</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class does not have exactly one field with the specified name, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="d">
      <text>If more than one child element of a bean declaration represents the same field of the bean class, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="e">
      <text>A field declaration may contain child elements</text>
    </assertion>
    
    <assertion id="f">
      <text>If a field declaration has more than one direct child element, and at least
one of these elements is something other than a |&lt;value&gt;| element in the Java EE namespace, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="g">
      <text>An element that represents a field may declare an injected field, a producer field or a field with an initial value</text>
    </assertion>
    
    <assertion id="h">
      <text>If the element contains a child |&lt;Produces&gt;| element in the Java EE namespace, a producer field was declared, as defined in Section 3.5.3, "Declaring a producer field using XML"</text>
    </assertion>
    
    <assertion id="i">
      <text>If the element contains a child |&lt;value&gt;| element in the Java EE namespace, a field with an initial value of type Set or List was declared, as defined in Section 9.5.5, "Field initial value declarations"</text>
    </assertion>
    
    <assertion id="j">
      <text>If the element has exactly one child element, an injected field was declared, as defined in Section 3.8.2, "Declaring an injected field using XML"</text>
    </assertion>
    
    <assertion id="k">
      <text>If the element has a non-empty body, and no child elements, a field with an initial value was declared, as defined in Section 9.5.5, "Field initial value declarations"</text>
    </assertion>
    
    <assertion id="l">
      <text>Otherwise, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="m">
      <text>If a field declaration represents an injected field, the child element is interpreted as an injection point declaration, as specified in Section 9.8, "Injection point declarations"</text>
    </assertion>
    
    <assertion id="n">
      <text>If the declared type is not assignable to the Java type of the field, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="o">
      <text>The bean type declared in XML may be a subtype of the Java field type. In this case, the container will use the bean type declared in XML when resolving the dependency</text>
    </assertion>
        
  </section>
  
  <section id="9.5.5" title="Field initial value declarations">
    <assertion id="a">
      <text>The initial value of a field of a simple bean or session bean with any one of the following types may be specified in XML: any primitive type, or |java.lang| wrapper type, any enumerated type, |java.lang.String|, |java.util.Date|, |java.sql.Date|, |java.sql.Time| or |java.sql.Timestamp|, |java.util.Calendar|, |java.math.BigDecimal| or |java.math.BigInteger|, |java.lang.Class|, |java.util.List&lt;java.lang.String&gt;| or |java.util.Set&lt;java.lang.String&gt;|, |java.util.List&lt;java.lang.Class&gt;| or |java.util.Set&lt;java.lang.Class&gt;|, |java.util.List&lt;X&gt;| or |java.util.Set&lt;X&gt;| where X is an enumerated type</text>
    </assertion>
    
    <assertion id="b">
      <text>The initial value of the field is specified in the body of an XML element representing the field</text>
    </assertion>
    
    <assertion id="c">
      <text>The initial value of a field of primitive type or |java.lang| wrapper type is specified using the Java literal syntax for that type</text>
    </assertion>
    
    <assertion id="d">
      <text>The initial value of a field of type |java.lang.String| is specified using the string value</text>
    </assertion>
    
    <assertion id="e">
      <text>The initial value of a field of enumerated type is specified using the unqualified name of the enumeration value</text>
    </assertion>
    
    <assertion id="f">
      <text>The initial value of a field of type |java.util.Date|, |java.sql.Date|, |java.sql.Time|, |java.sql.Timestamp| or |java.util.Calendar| is specified using a format that can be parsed by calling
|java.text.DateFormat.getDateTimeInstance().parse()|</text>
    </assertion>
    
    <assertion id="g">
      <text>The initial value of a field of type |java.math.BigDecimal| or |java.math.BigInteger| is specified using a format that can be parsed by the constructor that accepts a string</text>
    </assertion>
    
    <assertion id="h">
      <text>The initial value of a field of type |java.lang.Class| is specified using the fully qualified Java class name</text>
    </assertion>
    
    <assertion id="i">
      <text>The initial value of a field of type |java.util.List| or |java.util.Set| is specified by a list of |&lt;value&gt;| elements. The body of the value element is specified using the string value, fully qualified Java class name or unqualified name of the enumeration value</text>
    </assertion>
    
    <assertion id="j">
      <text>If a field with an initial value specified in XML is not of one of the listed types, or if the initial value is not specified in the correct format for the type of the field, a  |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="k">
      <text>If an element representing a field specifies both an initial value and a type declaration, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="9.5.6" title="Methods of a bean">
    <assertion id="a">
      <text>A method of a bean is declared by a direct child element of the bean declaration. The name of the declared method is the same as the name of the child element</text>
    </assertion>
    
    <assertion id="b">
      <text>A method declaration may have any number of direct child elements</text>
    </assertion>
    
    <assertion id="c">
      <text>The container inspects the direct child elements of the method declaration. For each child element, the element is interpreted as a Java type. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="d">
      <text>If the type is |javax.inject.Disposes|, the container searches for a direct child element of the child element and interprets that element as declaring a disposed parameter of the disposal method</text>
    </assertion>
    
    <assertion id="e">
      <text>If the type is |javax.event.Observes|, the container searches for a direct child element of the child element that is not an |&lt;IfExists&gt;|, |&lt;Asynchronously&gt;|, |&lt;AfterTransactionCompletion&gt;|, |&lt;AfterTransactionSuccess&gt;|, |&lt;AfterTransactionFailure&gt;| or |&lt;BeforeTransactionCompletion&gt;| element in the Java EE namespace, and interprets that element as declaring an event parameter of the observer method</text>
    </assertion>
    
    <assertion id="f">
      <text>If the type is some other Java annotation type, the container interprets the child element as declaring method-level metadata</text>
    </assertion>
    
    <assertion id="g">
      <text>If the type is a Java class or interface, the container interprets the child element as declaring a parameter of the method</text>
    </assertion>
    
    <assertion id="h">
      <text>Otherwise, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="i">
      <text>If a method declaration has more than one direct child element which is an |&lt;Initializer&gt;|, |&lt;Produces&gt;|, |&lt;Disposes&gt;| or |&lt;Observes&gt;| element in the Java EE namespace, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="j">
      <text>If a |&lt;Disposes&gt;| element does not contain exactly one direct child element, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="k">
      <text>If an |&lt;Observes&gt;| element does not contain exactly one direct child element that is not an |&lt;IfExists&gt;|, |&lt;Asynchronously&gt;|, |&lt;AfterTransactionCompletion&gt;|, |&lt;AfterTransactionSuccess&gt;|, |&lt;AfterTransactionFailure&gt;| or |&lt;BeforeTransactionCompletion&gt;| element in the Java EE namespace, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="l">
      <text>Each method parameter declaration and disposed parameter declaration is interpreted as an injection point declaration, as specified in Section 9.8, "Injection point declarations". An event parameter declaration is interpreted as a type declaration, as defined in Section 9.10, "Specifying bean types and bindings"</text>
    </assertion>
    
    <assertion id="m">
      <text>If the bean class has exactly one method such that the method name is the same as the name of the element that declares the method, the method has the same number of parameters as the element that declares the method has child elements, and the Java type represented by each method parameter declaration is assignable to the Java type of the corresponding method parameter, then the element is interpreted to represent that method</text>
    </assertion>
    
    <assertion id="n">
      <text>If more than one method exists which satisfies these conditions, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="o">
      <text>If no method of the bean class satisfies these conditions, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="p">
      <text>For any method parameter, the bean type declared in XML may be a subtype of the Java parameter type. In this case, the container will use the bean type declared in XML when resolving the dependency</text>
    </assertion>
    
    <assertion id="q">
      <text>If more than one child element of a bean declaration represents the same method of the bean class, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="r">
      <text>An element that represents a method may declare an initializer method, an observer method, a producer method or a disposal method. Alternatively, or additionally, it may declare method-level interceptor binding</text>
    </assertion>
    
    <assertion id="s">
      <text>If the element contains a child |&lt;Initializes&gt;| element in the Java EE namespace, an initializer method was declared, as defined in Section 3.9.2, "Declaring an initializer method using XML"</text>
    </assertion>
    
    <assertion id="t">
      <text>If the element contains a child |&lt;Produces&gt;| element in the Java EE namespace, a producer method was declared, as defined in Section 3.4.3, "Declaring a producer method using XML"</text>
    </assertion>
    
    <assertion id="u">
      <text>If the element contains a child |&lt;Disposes&gt;| element in the Java EE namespace, a disposal method was declared, as defined in Section 3.4.9, "Declaring a disposal method using XML"</text>
    </assertion>
    
    <assertion id="v">
      <text>If the element contains a child |&lt;Observes&gt;| element in the Java EE namespace, an observer method was declared, as defined in Section 7.5.3, "Declaring an observer method using XML"</text>
    </assertion>
    
    <assertion id="w">
      <text>If the element contains a child element which can be interpreted as an interceptor binding type, method-level interceptor binding was declared, as defined in Section A.3.6.2, "Binding an interceptor using XML"</text>
    </assertion>
  </section>
  
  <section id="9.6" title="Producer method and field declarations">
    <assertion id="a">
      <text>A producer method or field declaration is formed by adding a direct child |&lt;Produces&gt;| element to an element that represents the method or field, as defined in Section 3.4.3, "Declaring a producer method using XML" and Section 3.5.3, "Declaring a producer field using XML"</text>
    </assertion>
    
  </section>
  
  <section id="9.6.1" title="Child elements of a producer field declaration">
    <assertion id="a">
      <text>The container inspects the direct child elements of a producer field declaration</text>
    </assertion>
    
    <assertion id="b">
      <text>If there is more than one direct child element, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="c">
      <text>Otherwise, the direct child element is a |&lt;Produces&gt;| element in the Java EE namespace, and declares the return type, bindings and member-level metadata of the producer field</text>
    </assertion>
    
    <assertion id="d">
      <text>The container inspects the direct child elements of the |&lt;Produces&gt;| element. For each child element, the element is interpreted as a Java type. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="e">
      <text>If the type is a Java class or interface type, the type of the producer field was declared</text>
    </assertion>
    
    <assertion id="f">
      <text>If the type is a Java annotation type, it declares member-level metadata of the producer field</text>
    </assertion>
    
    <assertion id="g">
      <text>Otherwise, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="h">
      <text>If more than one child element represents a Java class or interface type, or if no child element represents a Java class or interface type, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="9.6.2" title="Child elements of a producer method declaration">
    <assertion id="a">
      <text>If a child element of a producer method declaration is the |&lt;Produces&gt;| element in the Java EE namespace, it declares the return type, bindings and member-level metadata of the producer method</text>
    </assertion>
    
    <assertion id="b">
      <text>If the child element of a producer method declaration can be interpreted as an interceptor binding type, it declares a method-level interceptor binding</text>
    </assertion>
    
    <assertion id="c">
      <text>The container interprets the child element of a producer method declaration as declaring a parameter of the producer method, if it is not a |&lt;Produces&gt;| element and cannot be interpreted as an interceptor binding type</text>
    </assertion>
    
    <assertion id="d">
      <text>If there is more than one child |&lt;Produces&gt;| element of a producer method declaration in the Java EE namespace, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="e">
      <text>The container inspects the direct child elements of the |&lt;Produces&gt;| element. For each child element, the element is interpreted as a Java type. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="f">
      <text>If the type of the direct child element of a |&lt;Produces&gt;| element is a Java class or interface type, the return type of the producer method was declared</text>
    </assertion>
    
    <assertion id="g">
      <text>If the type of the direct child element of a |&lt;Produces&gt;| element is a Java annotation type, it declares member-level metadata of the producer method</text>
    </assertion>
    
    <assertion id="h">
      <text>If the type of the direct child element of a |&lt;Produces&gt;| element is not a Java class or Java annotation, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="i">
      <text>If more than one child element represents a Java class or interface type, or if no child element represents a Java class or interface type, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="9.6.3" title="Return type and bindings of a producer method or field">
    <assertion id="a">
      <text>Every XML producer method or field declaration has a direct child |&lt;Produces&gt;| element</text>
    </assertion>
    
    <assertion id="b">
      <text>This |&lt;Produces&gt;| element must, in turn, have a direct child element which declares the return type of the producer method or the type of the producer field and which is interpreted by the container as a type declaration, as defined in Section 9.10, "Specifying bean types and bindings"</text>
    </assertion>
    
    <assertion id="c">
      <text>The type declaration that declares the return type of the producer method or the type of the producer field specifies the return type and bindings of the producer method bean, or the type and bindings of the producer field bean.</text>
    </assertion>
    
    <assertion id="d">
      <text>The type is used to calculate the set of bean types</text>
    </assertion>
    
    <assertion id="e">
      <text>The type declared in XML must be a supertype or subtype of the Java method or field type. If the declared type is not a supertype or subtype of the Java method or field type, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
  </section>
  
  <section id="9.6.4" title="Member-level metadata for a producer method or field">
    <assertion id="a">
      <text>Member-level metadata for a producer method or field declaration is specified via direct child elements of the |&lt;Produces&gt;| element that represent Java annotation types.</text>
    </assertion>
    
    <assertion id="b">
      <text>Each child element is interpreted as a Java annotation type. If the type is not a Java annotation type, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="c">
      <text>If the annotation type is a deployment type, the deployment type of the producer method or field was declared, as defined in Section 2.5.4, "Declaring the deployment type of a bean using XML".</text>
    </assertion>
    
    <assertion id="d">
      <text>If the annotation type is a scope type, the scope of the producer method or field was declared, as defined in Section 2.4.4, "Declaring the bean scope using XML".</text>
    </assertion>
    
    <assertion id="e">
      <text>If the annotation type is a stereotype, a stereotype of the producer method or field was declared, as defined in Section 2.7.3, "Declaring the stereotypes for a bean using XML".</text>
    </assertion>
    
    <assertion id="f">
      <text>If the annotation type is |javax.annotation.Name|, the name of the producer method or field was declared, as defined in Section 2.6.2, "Declaring the bean name using XML".</text>
    </assertion>
    
    <assertion id="g">
      <text>If the annotation type is not a deployment type, or a scope type, or a stereotype, or a |javax.annotation.Name|, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
  </section>
  
  <section id="9.7" title="Interceptor and decorator declarations">
    <assertion id="a">
      <text>A simple bean declaration is interpreted as an interceptor declaration if it contains a direct child |&lt;Interceptor&gt;| element in the Java EE namespace</text>
    </assertion>
    
    <assertion id="b">
      <text>A simple bean declaration is interpreted as a decorator declaration if it contains a direct child |&lt;Decorator&gt;| element in the Java EE namespace</text>
    </assertion>
    
    <assertion id="c">
      <text>If a bean declaration that is not a simple bean declaration contains a child |&lt;Interceptor&gt;| element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="d">
      <text>If a bean declaration that is not a simple bean declaration contains a child |&lt;Decorator&gt;| element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="e">
      <text>If an inline bean declaration contains a child |&lt;Interceptor&gt;| element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="f">
      <text>If an inline bean declaration contains a child |&lt;Decorator&gt;| element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="g">
      <text>If a simple bean declaration contains more than one direct child |&lt;Interceptor&gt;| element in the Java EE namespace, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="h">
      <text>If a simple bean declaration contains more than one direct child |&lt;Decorator&gt;| element in the Java EE namespace, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
  </section>
  
  <section id="9.7.1" title="Decorator delegate attribute">
    <assertion id="a">
      <text>Decorator declarations may declare the delegate attribute</text>
    </assertion>
    
    <assertion id="b">
      <text>A delegate declaration is a direct child element of the decorator declaration.</text>
    </assertion>
    
    <assertion id="c">
      <text>The name of the delegate attribute is the same as the name of the element.</text>
    </assertion>
    
    <assertion id="d">
      <text>If a direct child element of a decorator declaration exists in the same namespace as its parent, and has direct child |&lt;Decorates&gt;| element in the Java EE namespace then it is interpreted as a delegate declaration.</text>
    </assertion>
    
    <assertion id="e">
      <text>If the bean class has a field with the same name as the child element, then the child element is interpreted to represent that field.</text>
    </assertion>
    
    <assertion id="f">
      <text>If the bean class does not have have a field with the specified name, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="g">
      <text>If a delegate declaration has more than one direct child element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="h">
      <text>The child element of the delegate declaration is a |&lt;Decorates&gt;| element in the Java EE namespace. If the |&lt;Decorates&gt;| element does not, in turn, have exactly one direct child element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="i">
      <text>The direct child element of the |&lt;Decorates&gt;| element is interpreted as a type declaration as specified by Section 9.10, "Specifying bean types and bindings". If the declared bean type is not assignable to the type of the Java field, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="j">
      <text>The bean type declared in XML may be a subtype of the Java field type. In this case, the container will use the bean type declared in XML when resolving the dependency.</text>
    </assertion>
    
    <assertion id="k">
      <text>If simple bean declaration that is not a decorator declaration contains a direct child element that in turn contains a direct child |&lt;Decorates&gt;| element, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
  </section>
  
  <section id="9.8" title="Injection point declarations">
    <assertion id="a">
      <text>An injection point declaration is either a type declaration, as defined in Section 9.10, "Specifying bean types and bindings", or an inline bean declaration, as defined in Section 9.9, "Inline bean declarations".</text>
    </assertion>
    
    <assertion id="b">
      <text>When the container encounters an injection point declaration, it interprets the element as a Java class or interface. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="c">
      <text>If the Java type is a parameterized type, the injection point declaration is a type declaration, and the declared type of the injection point is the bean type of the type declaration, including actual type parameters.</text>
    </assertion>
    
    <assertion id="d">
      <text>Otherwise, the container inspects the direct child elements. If any direct child element can be interpreted as a binding type, the injection point declaration is a type declaration, and the declared type of the injection point is the bean type of the type declaration.</text>
    </assertion>
    
    <assertion id="e">
      <text>Otherwise, if any direct child elements exist, the injection point declaration is an inline bean declaration, and the declared type of the injection point is the bean class of the bean.</text>
    </assertion>
    
    <assertion id="f">
      <text>Otherwise, the injection point declaration is a type declaration, and the declared type of the injection point is the bean type of the type declaration.</text>
    </assertion>
  </section>
  
  <section id="9.9" title="Inline bean declarations">
    <assertion id="a">
      <text>An inline bean declaration is a simple bean declaration, as defined in Section 9.5, "Bean declarations" that occurs as an injection point declaration, instead of as a direct child of the &lt;Beans&gt; element.</text>
    </assertion>
    
    <assertion id="b">
      <text>The element is interpreted as a Java class. This Java class is the bean class of the simple bean</text>
    </assertion>
    
    <assertion id="c">
      <text>Inline bean declarations may not explicitly specify a binding type. If an inline bean declaration explicitly specifies a binding type, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="d">
      <text>For every inline injection point, the container generates a unique value for an implementation-specific binding type.  This generated value is the binding of the injection point, and the only binding of the simple bean. The bean type of the injection point is the declared bean class of the simple bean.</text>
    </assertion>
    
    <assertion id="e">
      <text>An inline bean declaration results in a simple bean that is bound only to the injection point at which it was declared.</text>
    </assertion>
  </section>
  
  <section id="9.10" title="Specifying bean types and bindings">
    <assertion id="a">
      <text>Every injection point defined in XML must explicitly specify a bean type and combination of bindings.</text>
    </assertion>
    
    <assertion id="b">
      <text>Every event parameter defined in XML must explicitly specify a bean type and combination of bindings.</text>
    </assertion>
    
    <assertion id="c">
      <text>Every delegate attribute defined in XML must explicitly specify a bean type and combination of bindings.</text>
    </assertion>
    
    <assertion id="d">
      <text>XML-based producer method declarations must explicitly specify the return type (which is used to calculate the set of bean types) and bindings</text>
    </assertion>
    
    <assertion id="e">
      <text>A type declaration is an element that represents a Java class or interface, or |&lt;Array&gt;|</text>
    </assertion>
    
    <assertion id="f">
      <text>A type declaration is (if the type is a parameterized type), a set of child elements that represent Java classes and/or interfaces, and are interpreted as the actual type parameters, or, if the type is an array type, a single child element that represents the array element type</text>
    </assertion>
    
    <assertion id="g">
      <text>A type declaration is optionally, a set of child elements that represent Java annotation types, and are interpreted as bindings</text>
    </assertion>
    
    <assertion id="h">
      <text>When the container encounters a type declaration it interprets the element as a Java type</text>
    </assertion>
    
    <assertion id="i">
      <text>If the element is an |&lt;Array&gt;| element in the Java EE namespace, an array type was declared.</text>
    </assertion>
    
    <assertion id="j">
      <text>Otherwise, the element is interpreted as a Java class or interface. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time. If the Java type is not a class or interface type, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="k">
      <text>The container inspects every direct child element of the type declaration. Each child element is interpreted as a Java type. If no such Java type exists in the classpath, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="l">
      <text>If the type is a Java annotation type, a binding was declared.</text>
    </assertion>
    
    <assertion id="m">
      <text>If the type is a Java class or interface type, an actual type parameter or array element type was declared</text>
    </assertion>
    
    <assertion id="n">
      <text>If the type is not a Java annotation type or a Java class or interface type, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="o">
      <text>If multiple array element types are declared, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="p">
      <text>If the number of declared actual type parameters is not the same as the number of parameters of the Java type, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="q">
      <text>If a type parameter of the Java type is bounded, and the corresponding declared actual type parameter does not satisfy the upper or lower bound, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="r">
      <text>If a binding declaration declares a Java annotation type that is not a binding type, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="s">
      <text>If no binding is declared, the default binding |@Current| is assumed</text>
    </assertion>
    
    <assertion id="t">
      <text>If the same binding type occurs more than once, a |DuplicateBindingTypeException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="u">
      <text>For fields, type declarations are specified as direct child elements of the field declaration</text>
    </assertion>
    
    <assertion id="v">
      <text>For methods, the method parameter declarations are type declarations</text>
    </assertion>
    
    <assertion id="w">
      <text>For producer methods, the return type must be specified</text>
    </assertion>
    
    <assertion id="x">
      <text>For constructors, the constructor parameter declarations are type declarations</text>
    </assertion>
  </section>
  
  <section id="9.11" title="Annotation members">
    <assertion id="a">
      <text>Any binding or interceptor binding declaration must define the value of any annotation member without a default value, and may additionally define the value of any annotation member with a default value.</text>
    </assertion>
    
    <assertion id="b">
      <text>Annotation member values are defined by attributes of the XML element which represents the Java annotation.</text>
    </assertion>
    
    <assertion id="c">
      <text>All attributes of any XML element which represents a Java annotation are interpreted as members of the annotation</text>
    </assertion>
    
    <assertion id="d">
      <text>The name of the attribute is interpreted as the name of the corresponding annotation member.</text>
    </assertion>
    
    <assertion id="e">
      <text>The value of the attribute is interpreted as the value of the annotation member.</text>
    </assertion>
    
    <assertion id="f">
      <text>If there is no annotation member with the same name as the attribute, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="g">
      <text>The value of an annotation member named value may be specified in the body of the XML element which represents the Java annotation.</text>
    </assertion>
    
    <assertion id="h">
      <text>If the XML element has a non-empty body and also specifies an attribute named value, a
|DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="i">
      <text>If the XML element has a non-empty body, and there is no annotation member named value, a |DefinitionException| is thrown by the container at deployment time</text>
    </assertion>
    
    <assertion id="j">
      <text>The value of a member of primitive type is specified using the Java literal syntax for that type</text>
    </assertion>
    
    <assertion id="k">
      <text>The value of a member of type |java.lang.String| is specified using the string value</text>
    </assertion>
    
    <assertion id="l">
      <text>The value of a member of enumerated type is specified using the unqualified name of the enumeration value.</text>
    </assertion>
    
    <assertion id="m">
      <text>The value of a member of type |java.lang.Class| is specified using the fully qualified Java class name.</text>
    </assertion>
    
    <assertion id="n">
      <text>If the member value is not specified in the correct format for the type of the member, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
    
    <assertion id="o">
      <text>If an XML element that refers to a Java annotation with a member with no default value does not declare a value for that member, a |DefinitionException| is thrown by the container at deployment time.</text>
    </assertion>
  </section>
  
  <section id="9.12" title="Deployment declarations">
    
  </section>
  
  <section id="9.12.1" title="The &lt;Deploy&gt; declaration">
   
  </section>
  
  <section id="9.12.2" title="The &lt;Interceptors&gt; declaration">
  
  </section>
  
  <section id="9.12.3" title="The &lt;Decorators&gt; declaration">
    
  </section>
  
  <section id="11" title="Packaging and Deployment">
    
  </section>
  
  <section id="11.1" title="Deployment lifecycle">
    
  </section>
 
  <section id="11.2" title="Bean discovery">
     
   
    
    <assertion id="w">
      <text>The container discovers beans~, disposal methods and observer methods~ defined using XML by parsing the |beans.xml| files according to the rules of Chapter 9, XML based metadata.</text>
      <note>Check all archive types enumerated above, simple beans, session beans, producer methods and producer fields</note>
    </assertion>
    
    <assertion id="x">
      <text>The container discovers ~beans, ~disposal methods ~and observer methods~ defined using XML by parsing the |beans.xml| files according to the rules of Chapter 9, XML based metadata.</text>
      <note>Check all archive types enumerated above</note>
    </assertion>
    
    <assertion id="y">
      <text>The container discovers ~beans, disposal methods and~ observer methods defined using XML by parsing the |beans.xml| files according to the rules of Chapter 9, XML based metadata.</text>
      <note>Check all archive types enumerated above</note>
    </assertion> 

  </section>
    
  <section id="11.4" title="Providing additional XML based metadata"> 
    <assertion id="a">
      <text>The container parses the XML stream according to the rules of Chapter 9, XML based metadata.  This method may be called at any time by the application or third-party framework.</text>
      <note>Check that the parse method adds beans etc.</note>
    </assertion>
  </section>
  
  <section id="11.6" title="Activities">
  
  </section>
  
  <section id="11.6.1" title="Current Activity">
  
  </section>

</specification>
