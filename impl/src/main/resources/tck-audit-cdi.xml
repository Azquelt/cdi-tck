<specification
    xmlns="http://jboss.com/products/weld/tck/audit"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://jboss.com/products/weld/tck/audit /Users/pmuir/workspace/jboss-test-audit/api/src/main/resources/tck-audit.xsd"
    name="JSR-299: Contexts and Dependency Injection for Java Enterprise Edition"
    id="cdi"
    version="20091101">

  <section id="2" title="Concepts">

    <assertion id="a">
      <text>A bean comprises of a (nonempty) set of bean types.</text>
    </assertion>

    <assertion id="b">
      <text>A bean comprises of a (nonempty) set of qualifiers.</text>
    </assertion>

    <assertion id="c">
      <text>A bean comprises of a scope.</text>
    </assertion>

    <assertion id="e">
      <text>A bean comprises of an optional bean EL name.</text>
    </assertion>

    <assertion id="f">
      <text>A bean comprises of a set of interceptor bindings.</text>
    </assertion>

    <assertion id="g">
      <text>A bean comprises of a bean implementation.</text>
    </assertion>
    
    <assertion id="h" testable="false">
      <text>A bean may or may not be an alternative.</text>
    </assertion>
  </section>
  
  <section id="2.1" title="Functionality provided by the container to the bean">
  </section>

  <section id="2.2" title="Bean types">

    <assertion id="a">
      <text>A bean may have multiple bean types.</text>
    </assertion>

    <assertion id="l">
      <text>All beans have the bean type |java.lang.Object|.</text>
    </assertion>

  </section>

  <section id="2.2.1" title="Legal bean types">
    <assertion id="a">
      <text>A bean type may be an interface.</text>
    </assertion>

    <assertion id="b">
      <text>A bean type may be a concrete class.</text>
    </assertion>

    <assertion id="c">
      <text>A bean type may be an abstract class.</text>
    </assertion>

    <assertion id="d">
      <text>A bean type may be declared final.</text>
    </assertion>

    <assertion id="e">
      <text>A bean type may have final methods.</text>
    </assertion>

    <assertion id="f">
      <text>A bean type may be a parameterized type with actual type parameters.</text>
    </assertion>

    <assertion id="g">
      <text>A bean type may be a parameterized type with type variables.</text>
    </assertion>

    <assertion id="i">
      <text>A bean type may be an array type.  Two array types are considered identical only if the element type is identical.</text>
    </assertion>

    <assertion id="j">
      <text>A bean type may be a primitive type. Primitive types are considered to be identical to their corresponding wrapper types in |java.lang|.</text>
    </assertion>

    <assertion id="k">
      <text>A bean type may be a raw type.</text>
    </assertion>

    <assertion id="la">
      <text>A type variable is not a legal bean type.</text>
    </assertion>

    <assertion id="lb">
      <text>A parameterized type that contains a wildcard type parameter is not a legal bean type.</text>
    </assertion>
  </section>
  
  <section id="2.2.2" title="Restricting the bean types of a bean">
    <group>
      <text>The bean types of a bean may be restricted by annotating the bean class or producer method or field with the annotation |@javax.enterprise.inject.Typed|. When a |@Typed| annotation is explicitly specified, only the types whose classes are explicitly listed using the |value| member, together with |java.lang.Object| are bean types of the bean.</text>
      <assertion id="a">
        <text>Check managed bean</text>
      </assertion>
      <assertion id="b">
        <text>Check session bean</text>
      </assertion>
      <assertion id="c">
        <text>Check producer method</text>
      </assertion>
      <assertion id="d">
        <text>Check producer field</text>
      </assertion>
      <assertion id="e">
        <text>Check generic managed bean</text>
      </assertion>
      <assertion id="g">
        <text>Check generic producer method</text>
      </assertion>
      <assertion id="h">
        <text>Check generic producer field</text>
      </assertion>
    </group>
    
    <group>
      <text>If a bean class or producer method or field specifies a |@Typed| annotation, and the |value| member specifies a class which does not correspond to a type in the unrestricted set of bean types of a bean, the container automatically detects the problem and treats it as a definition error.</text>
      <assertion id="j">
        <text>Check managed bean</text>
      </assertion>
      <assertion id="k">
        <text>Check session bean</text>
      </assertion>
      <assertion id="l">
        <text>Check producer method</text>
      </assertion>
      <assertion id="m">
        <text>Check producer field</text>
      </assertion>
    </group>
  </section>

  <section id="2.2.3" title="Typecasting between bean types">
    <assertion id="a">
      <text>A client of a bean may typecast its contextual reference to a bean to any bean type of the bean which is a Java interface.  However, the client may not in general typecast its contextual reference to an arbitrary concrete bean type of the bean.</text>
    </assertion>
  </section>

  <section id="2.3" title="Qualifiers">

  </section>

  <section id="2.3.1" title="Built-in qualifier types">

    <assertion id="a0">
      <text>Every bean has the built-in qualifier |@Any|, even if it does not explicitly declare this qualifier, except for the special |@New| qualified beans defined in Section 3.12, "@New qualified beans".</text>
    </assertion>

    <assertion id="aa">
      <text>If a bean does not explicitly declare a qualifier other than |@Named|, the bean has exactly one additional qualifier, of type |@Default|.  This is called the default qualifier.</text>
    </assertion>

    <assertion id="b">
      <text>The default qualifier is also assumed for any injection point that does not explicitly declare a qualifier.</text>
    </assertion>
  </section>

  <section id="2.3.2" title="Defining new qualifier types">
    <assertion id="aa" testable="false">
      <text>A qualifier type is a Java annotation defined as |@Target({METHOD, FIELD, PARAMETER, TYPE})|~ and |@Retention(RUNTIME)|~.</text>
    </assertion>

    <assertion id="ab" testable="false">
      <text>A qualifier type is a Java annotation defined as ~|@Target({METHOD, FIELD, PARAMETER, TYPE})| and ~|@Retention(RUNTIME)|.</text>
      <note>Non-runtime retention annotations are discarded by the compiler</note>
    </assertion>

    <assertion id="ba">
      <text>A qualifier type may be declared by specifying the |@javax.inject.Qualifier| meta-annotation.</text>
    </assertion>

    <assertion id="d" testable="false">
      <text>A qualifier type may define annotation members.</text>
      <note>This is true by default in the JLS</note>
    </assertion>
  </section>

  <section id="2.3.3" title="Declaring the qualifiers of a bean">
    <group>
      <text>The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types.</text>
    
      <assertion id="a">
        <text>Test by annotating a bean class.</text>
      </assertion>

      <assertion id="b">
        <text>Test by annotating a producer method.</text>
      </assertion>

      <assertion id="c">
        <text>Test by annotating a producer field.</text>
      </assertion>
    </group>

    <assertion id="d">
      <text>Any bean may declare multiple qualifier types.</text>
    </assertion>
  </section>

  <section id="2.3.4" title="Specifying qualifiers of an injected field">
    <assertion id="a">
      <text>Qualifier types may be applied to injected fields (see Section 3.8, "Injected fields") to determine the bean that is injected, according to the rules of typesafe resolution defined in Section 5.3, "Typesafe resolution".</text>
    </assertion>

    <assertion id="b">
      <text>A bean may only be injected to an injection point if it has all the qualifiers of the injection point.</text>
    </assertion>
  </section>

  <section id="2.3.5" title="Specifying qualifiers of a method or constructor parameter">
    <group>
      <text>Qualifier types may be applied to parameters of producer methods, initializer methods, disposer methods, observer methods or bean constructors (see Chapter 3, Bean implementation) to determine the bean instance that is passed when the method is called by the container.</text>    

      <assertion id="a">
        <text>Test producer method.</text>
      </assertion>

      <assertion id="b">
        <text>Test initializer method.</text>
      </assertion>

      <assertion id="c">
        <text>Test disposer method.</text>
      </assertion>

      <assertion id="ca">
        <text>Test observer method.</text>
      </assertion>

      <assertion id="d">
        <text>Test bean constructor.</text>
      </assertion>
    </group>
  </section>

  <section id="2.4" title="Scopes">
    <assertion id="a">
      <text>All beans have a scope.</text>
    </assertion>

    <assertion id="b" testable="false">
      <text>A scope type is represented by an annotation type.</text>
      <note>This is a statement of intent</note>
    </assertion>

    <assertion id="c">
      <text>The set of scope types is extensible.</text>
    </assertion>
  </section>

  <section id="2.4.1" title="Built-in scope types">
    <assertion id="aa">
      <text>There are five standard scope types defined by this specification, all defined in the package javax.enterprise.context. The |@RequestScoped|~, |@ApplicationScoped| and |@SessionScoped|~ annotations defined in Section 6.7, "Context management for built-in scopes" represent the standard scopes defined by the Java Servlets specification.</text>
    </assertion>

    <assertion id="ab">
      <text>There are five standard scope types defined by this specification, all defined in the package javax.enterprise.context. The ~|@RequestScoped|, ~|@ApplicationScoped|~ and |@SessionScoped|~ annotations defined in Section 6.7, "Context management for built-in scopes" represent the standard scopes defined by the Java Servlets specification.</text>
    </assertion>

    <assertion id="ac">
      <text>There are five standard scope types defined by this specification, all defined in the package javax.enterprise.context. The ~|@RequestScoped|, |@ApplicationScoped| and ~|@SessionScoped| annotations defined in Section 6.7, "Context management for built-in scopes" represent the standard scopes defined by the Java Servlets specification.</text>
    </assertion>

    <assertion id="ba">
      <text>There are five standard scope types defined by this specification, all defined in the package javax.enterprise.context. The |@ConversationScoped| annotation represents the conversation scope defined in Section 6.7.4, "Conversation context lifecycle".</text>
    </assertion>

    <assertion id="ca">
      <text>There are five standard scope types defined by this specification, all defined in the package javax.enterprise.context. The |@Dependent| pseudo-scope is for dependent objects, as defined in Section 6.4, "Dependent pseudo-scope"</text>
    </assertion>
    
    <assertion id="e" testable="false">
      <text>If an interceptor or decorator has any scope other than |@Dependent|, non-portable behavior results.</text>
    </assertion>
  </section>

  <section id="2.4.2" title="Defining new scope types">
    <assertion id="aa">
      <text>A scope type is a Java annotation defined as |@Target({TYPE, METHOD, FIELD})|~ and |@Retention(RUNTIME)|~.</text>
    </assertion>

    <assertion id="ab" testable="false">
      <text>A scope type is a Java annotation defined as ~|@Target({TYPE, METHOD, FIELD})| and ~|@Retention(RUNTIME)|.</text>
      <note>Non-runtime retention annotations are discarded by the compiler</note>
    </assertion>

    <assertion id="ba">
      <text>All scope types must specify the |@javax.inject.Scope| or |@javax.enterprise.context.NormalScope| meta-annotation.</text>
    </assertion>

  </section>

  <section id="2.4.3" title="Declaring the bean scope">
    <assertion id="a">
      <text>The scope of a bean is defined by annotating the bean class or producer method or field with a scope type.</text>
    </assertion>

    <assertion id="ba">
      <text>A bean class or producer method or field may specify at most one scope type annotation. If a bean class or producer method or field specifies multiple scope type annotations, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="c">
      <text>A scope type may be specified using a stereotype annotation, as defined in Section 2.7.2, "Declaring the stereotypes for a bean"</text>
    </assertion>
  </section>

  <section id="2.4.4" title="Default scope">
    <assertion id="aa">
      <text>When no scope is explicitly declared by annotating the bean class or producer method or field the scope of a bean is defaulted.</text>
    </assertion>

    <assertion id="b">
      <text>If the bean does not declare any stereotype with a declared default scope, the default scope for the bean is |@Dependent|.</text>
    </assertion>

    <assertion id="c">
      <text>If all stereotypes declared by the bean that have some declared default scope have the same default scope, then that scope is the default scope for the bean.</text>
    </assertion>

    <assertion id="da">
      <text>If there are two different stereotypes declared by the bean that declare different default scopes, then there is no default scope and the bean must explicitly declare a scope. If it does not explicitly declare a scope, the container automatically
detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="e">
      <text>If a bean explicitly declares a scope, any default scopes declared by stereotypes are ignored.</text>
    </assertion>
  </section>

  <section id="2.5" title="Bean EL names">

    <assertion id="a">
      <text>A valid bean EL name is a period-separated list of valid EL identifiers</text>
    </assertion>
  </section>

  <section id="2.5.1" title="Declaring the bean EL name">

    <group>
      <text>To specify the EL name of a bean, the qualifier |@javax.inject.Named| is applied to the bean class or producer method or field.</text>
      
      <assertion id="a">
        <text>Test with a bean class.</text>
      </assertion>

      <assertion id="b">
        <text>Test with a producer method.</text>
      </assertion>

      <assertion id="c">
        <text>Test with a producer field.</text>
      </assertion>
    </group>

    <assertion id="d">
    <text>If the |@Named| annotation does not specify the |value| member, the EL name is defaulted.</text>
    </assertion>
  </section>

  <section id="2.5.2" title="Default bean EL names">

    <group>
      <text>A default EL name must be assigned by the container when a bean class or producer method or field of a bean declares a |@Named| annotation and no EL name is explicitly specified by the |value| member.</text>    
      
      <assertion id="a">
        <text>Test with a bean class.</text>
      </assertion>

      <assertion id="b">
        <text>Test with a producer method.</text>
      </assertion>

      <assertion id="c">
        <text>Test with a producer field.</text>
      </assertion>
    </group>

    <assertion id="e">
      <text>A default EL name must be assigned by the container when a bean declares a stereotype that declares an empty |@Named| annotation, and the bean does not explicitly specify an EL name.</text>
    </assertion>
  </section>

  <section id="2.5.3" title="Beans with no EL name">

    <assertion id="a">
      <text>If |@Named| is not declared by the bean, nor by its stereotypes, a bean has no EL name.</text>
    </assertion>
    
    <assertion id="b" testable="false">
      <text>If an interceptor or decorator has a name, non-portable behavior results.</text>
    </assertion>
  </section>

  <section id="2.6" title="Alternatives">
    <assertion id="a">
      <text>An alternative is a bean that must be explicitly declared in the |beans.xml| file if it should be available for lookup, injection or EL resolution.</text>
    </assertion>
  </section>

  <section id="2.6.1" title="Declaring an alternative">

    <group>
      <text>An alternative may be declared by annotating the bean class or producer method or field with the |@Alternative| annotation.</text>
      
      <assertion id="a">
        <text>Test with a bean class.</text>
      </assertion>

      <assertion id="ab">
        <text>Test with a producer method.</text>
      </assertion>
      
      <assertion id="ac">
        <text>Test with a producer field.</text>
      </assertion>            
    </group>

    <group>
      <text>An alternative may be declared by annotating a bean, producer method or producer field with a stereotype that declares an |@Alternative| annotation.</text>
            
      <assertion id="b">
        <text>Test with a bean.</text>
      </assertion>

      <assertion id="c">
        <text>Test with a producer method.</text>
      </assertion>

      <assertion id="d">
        <text>Test with a producer field.</text>
      </assertion>
    </group>
    
    <assertion id="e" testable="false">
      <text>If an interceptor or decorator is an alternative, non-portable behavior results.</text>
    </assertion>
    
  </section>

  <section id="2.7" title="Stereotypes">

    <assertion id="a">
      <text>A stereotype may specify that all beans with the stereotype have defaulted bean EL names.</text>
    </assertion>

    <assertion id="aa">
      <text>A stereotype may specify that all beans with the stereotype are alternatives.</text>
    </assertion>

    <group>
      <text>A bean may declare zero, one or multiple stereotypes.</text>
      
      <assertion id="b" testable="false">
        <text>A bean may declare zero stereotypes.</text>
        <note>Not testable through API</note>
      </assertion>

      <assertion id="c">
        <text>Test with one stereotype.</text>
      </assertion>

      <assertion id="d">
        <text>Test with multiple stereotypes.</text>
      </assertion>
    </group>

  </section>

  <section id="2.7.1" title="Defining new stereotypes">
    <group>
      <text>A beans stereotype is a Java annotation defined as |@Target({TYPE, METHOD, FIELD})|, |@Target(TYPE)|, |@Target(METHOD)|, |@Target(FIELD)| or |@Target({METHOD, FIELD})| and |@Retention(RUNTIME)|.</text>
      
      <assertion id="aa" testable="false">
        <text>Test |@Target({TYPE, METHOD, FIELD})|.</text>
      </assertion>

      <assertion id="ab" testable="false">
        <text>Test |@Target(TYPE)|.</text>
      </assertion>

      <assertion id="ac" testable="false">
        <text>Test |@Target(FIELD)|.</text>
      </assertion>

      <assertion id="ad" testable="false">
        <text>Test |@Target({METHOD, FIELD})|.</text>
      </assertion>

      <assertion id="ae" testable="false">
        <text>|@Retention(RUNTIME)| - untestable.</text>
        <note>Non-runtime retention annotations are discarded by the compiler</note>
      </assertion>
    </group>

    <assertion id="b">
      <text>A stereotype may be declared by specifying the |@javax.enterprise.inject.Stereotype| meta-annotation.</text>
    </assertion>
  </section>

  <section id="2.7.1.1" title="Declaring the default scope for a stereotype">

    <group>
      <text>The default scope of a stereotype is defined by annotating the stereotype with a scope type. A stereotype may declare at most one scope. If a stereotype declares more than one scope, the container automatically detects the problem and treats it as a definition error.</text>
    
      <assertion id="aa">
        <text>Test with one scope.</text>
      </assertion>
      
      <assertion id="ab">
        <text>Test that a stereotype with multiple scopes throws an exception.</text>
      </assertion>
    </group>
    
  </section>

  <section id="2.7.1.2" title="Specifying interceptor bindings for a stereotype">
    <assertion id="a0">
      <text>The interceptor bindings of a stereotype are defined by annotating the stereotype with the interceptor binding types.</text>
    </assertion>
  
    <assertion id="a">
      <text>A stereotype may declare zero interceptor bindings.</text>
    </assertion>

    <assertion id="b">
      <text>A stereotype may declare one interceptor bindings.</text>
    </assertion>

    <assertion id="c">
      <text>A stereotype may declare multiple interceptor bindings.</text>
    </assertion>
  </section>

  <section id="2.7.1.3" title="Declaring a @Named stereotype">
    <assertion id="aaa">
      <text>A stereotype may declare an empty |@Named| annotation, which specifies that every bean with the stereotype has a defaulted name when a name is not explicitly specified by the bean.</text>
    </assertion>

    <assertion id="aab">
      <text>If a stereotype declares a non-empty |@Named| annotation, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="b" testable="false">
      <text>A stereotype should not declare any qualifier annotation other than |@Named|.  If a stereotype declares any other qualifier annotation, non-portable behavior results.</text>
      <note>The behavior here is undefined.</note>
    </assertion>
    
    <assertion id="c" testable="false">
      <text>A stereotype should not be annotated |@Typed|. If a stereotype is annotated |@Typed|, non-portable behavior results.</text>
    </assertion>
    
  </section>

  <section id="2.7.1.4" title="Declaring an @Alternative stereotype">
    <assertion id="a">
      <text>A stereotype may declare an |@Alternative| annotation, which specifies that every bean with the stereotype is an alternative.</text>
    </assertion>
  </section>

  <section id="2.7.1.5" title="Stereotypes with additional stereotypes">
    <assertion id="a">
      <text>A stereotype may declare other stereotypes.</text>
    </assertion>

    <assertion id="b">
      <text>Stereotype declarations are transitive - a stereotype declared by a second stereotype is inherited by all beans and other stereotypes that declare the second stereotype.</text>
    </assertion>

    <assertion id="c" testable="false">
      <text>Stereotypes declared |@Target(TYPE)| may not be applied to stereotypes declared |@Target({TYPE, METHOD, FIELD})|, |@Target(METHOD)|, |@Target(FIELD)|, |@Target({METHOD, FIELD})|.</text>
      <note>No definition of what happens if you do this</note>
    </assertion>

  </section>

  <section id="2.7.2" title="Declaring the stereotypes for a bean">
    <group>
      <text>Stereotype annotations may be applied to a bean class or producer method or field.</text>
      
      <assertion id="a">
        <text>Test with a bean class.</text>
      </assertion>

      <assertion id="b">
        <text>Test with a producer method.</text>
      </assertion>

      <assertion id="c">
        <text>Test with a producer field.</text>
      </assertion>
    </group>

    <assertion id="db">
    <text>The default scope declared by the stereotype may be overridden by the bean.</text>
    </assertion>

    <assertion id="e">
      <text>Multiple stereotypes may be applied to the same bean.</text>
    </assertion>
  </section>

  <section id="2.7.3" title="Built-in stereotypes">
    <assertion id="aa" testable="false">
      <text>The built-in stereotype |@javax.enterprise.inject.Model| is intended for use with beans that define the model layer of an MVC web application architecture such as JSF.</text>
      <note>Tested by API signature test</note>
    </assertion>
  </section>
  
  <section id="2.8" title="Problems detected automatically by the container">
    <assertion id="a" testable="false">
      <text>When the application violates a rule defined by this specification, the container automatically detects the problem.  There are three kinds of problem - definition errors occur when a single bean definition violates the rules of this specification, deployment problems occur when there are problems resolving dependencies, or inconsistent specialization, in a particular deployment, and exceptions occur at runtime.</text>
      <note>Generalization</note>
    </assertion>
    
    <assertion id="b">
      <text>Definition errors are developer errors.  They may be detected by tooling at development time, and are also detected by the container at initialization time.  If a definition error exists in a deployment, initialization will be aborted by the container.</text>
    </assertion>
    
    <assertion id="c">
      <text>Deployment problems are detected by the container at initialization time.  If a deployment problem exists in a deployment, initialization will be aborted by the container.</text>
    </assertion>
    
    <assertion id="d">
      <text>The container is permitted to define a non-portable mode, for use at development time, in which some definition errors and deployment problems do not cause application initialization to abort.</text>
    </assertion>
    
    <assertion id="e">
      <text>Exceptions represent problems that may not be detected until they actually occur at runtime.  All exceptions defined by this specification are unchecked exceptions.  All exceptions defined by this specification may be safely caught and handled by the application.</text>
    </assertion>
    
    
  
  </section>

  <section id="3" title="Programming model">

  </section>

  <section id="3.1" title="Managed beans">
    <assertion id="f0">
      <text>If the bean class of a managed bean is annotated with both the |@Interceptor| and |@Decorator| stereotypes, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="fa">
      <text>If a managed bean has a public field, it must have scope |@Dependent|.</text>
      <note>Check that a dependent scoped bean with a public field does work</note>
    </assertion>

    <assertion id="fba">
      <text>If a managed bean with a public field declares any scope other than |@Dependent|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="g">
      <text>If the managed bean class is a generic type, it must have scope |@Dependent|. If a managed bean with a parameterized bean class declares any scope other than |@Dependent|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.1.1" title="Which Java classes are managed beans?">
    <assertion id="b">
      <text>A top-level Java class is not a managed bean if it is a non-static inner class.</text>
    </assertion>

    <assertion id="ba">
      <text>A top-level Java class that is a static inner class can be a managed bean.</text>
      <note>Implied as the inverse of assertion 3.1.1.b</note>
    </assertion>

    <assertion id="ca">
      <text>A top-level Java class is not a managed bean if it is an abstract class, unless it is annotated |@Decorator|.</text>
    </assertion>

    <assertion id="cb">
      <text>A top-level Java class is not a managed bean if it is an interface, unless it is annotated |@Decorator|.</text>
    </assertion>

    <assertion id="f">
      <text>A top-level Java class is not a managed bean if it is annotated with any of the EJB component-defining annotations</text>
    </assertion>
    
    <assertion id="g">
      <text>A top-level Java class is not a managed bean if it implements |javax.enterprise.inject.spi.Extension|.</text>
    </assertion>

    <assertion id="n">
      <text>A top-level Java class is not a managed bean if it is declared as an EJB bean class in |ejb-jar.xml|</text>
    </assertion>

    <assertion id="p">
      <text>A top-level Java class is only a managed bean if it has an appropriate constructor - a constructor with no parameters.</text>
    </assertion>

    <assertion id="q">
      <text>A top-level Java class is only a managed bean if it has an appropriate constructor - a constructor annotated |@Inject|.</text>
    </assertion>
  </section>

  <section id="3.1.2" title="Bean types of a managed bean">
  
    <assertion id="a">
      <text>The unrestricted set of bean types for a managed bean contains the bean class, every superclass and all interfaces it implements directly or indirectly.</text>
    </assertion>
  </section>

  <section id="3.1.3" title="Declaring a managed bean">
    <assertion id="a">
      <text>A managed bean with a constructor that takes no parameters does not require any special annotations</text>
    </assertion>
    
    <assertion id="ab" testable="false">
      <text>If the managed bean does not have a constructor that takes no parameters, it must have a constructor annotated |@Inject|.  No additional special annotations are required.</text>
    </assertion>

    <group>
      <text>A bean class may also specify a scope, name, stereotypes and/or qualifiers.</text>    
      
      <assertion id="ba">
        <text>Test a bean with a scope.</text>
      </assertion>

      <assertion id="bb">
        <text>Test a bean with a name.</text>
      </assertion>

      <assertion id="bd">
        <text>Test a bean with a stereotype.</text>
      </assertion>

      <assertion id="be">
        <text>Test a bean with a qualifier.</text>
      </assertion>
    </group>

    <assertion id="c">
      <text>A managed bean may extend another managed bean.</text>
    </assertion>
  </section>

  <section id="3.1.4" title="Specializing a managed bean">
    <group>
      <text>If a bean class of a managed bean X is annotated |@Specializes|, then the bean class of X must directly extend the bean class of another managed bean Y. Then X directly specializes Y, as defined in Section 4.3, "Specialization".</text>    
       
      <assertion id="aa">
        <text>Test that a specializing bean has all its own qualifiers and the qualifiers of the specialized bean.</text>
      </assertion>
      
      <assertion id="ab">
        <text>Test that a specializing bean has the name of the specialized bean.</text>
      </assertion>
      
      <assertion id="ac">
        <text>Test a specialized bean extending a managed bean.</text>
      </assertion>
    </group>

    <group>
      <text>If the bean class of X does not directly extend the bean class of another managed bean, the container automatically detects the problem and treats it as a definition error.</text>    
      
      <assertion id="da">
        <text>Test a specializing bean extending a non simple bean.</text>
      </assertion>
      
      <assertion id="db">
        <text>Test a specializing bean extending nothing.</text>
      </assertion>
      
      <assertion id="dc">
        <text>Test a specializing bean directly extending an enterprise bean class.</text>
      </assertion>
      
      <assertion id="dd">
        <text>Test a specializing bean implementing an interface and extending nothing.</text>
      </assertion>
    </group>
  </section>
  
  <section id="3.1.5" title="Default name for a managed bean">
    <assertion id="a">
      <text>The default name for a managed bean is the unqualified class name of the bean class, after converting the first character to lower case</text>
    </assertion>
  </section>

  <section id="3.2" title="Session beans">
    <assertion id="aa" testable="false">
      <text>A session bean is a bean that is implemented by a session bean with an EJB 3.x client view.  The basic lifecycle and semantics of EJB session beans are defined by the EJB specification.</text>
      <note>This is a reference to the EJB specification</note>
    </assertion>

    <assertion id="b">
      <text>A stateless session bean must belong to the |@Dependent| pseudo-scope</text>
    </assertion>

    <assertion id="c">
      <text>A singleton bean must belong to either the |@ApplicationScoped| scope or to the |@Dependent| pseudo-scope</text>
    </assertion>

    <assertion id="da">
      <text>If a session bean specifies an illegal scope, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="e">
      <text>A stateful session bean may have any scope.</text>
      <note>No way of testing the real intent of this statement, so we check that a SFSB may be scoped</note>
    </assertion>

    <assertion id="f" testable="false">
      <text>When a contextual instance of a session bean is obtained via the dependency injection service, the behavior of |SessionContext.getInvokedBusinessInterface()| is specific to the container implementation. Portable applications should not rely upon the value returned by this method.</text>
      <note>This is describing non-portable behavior</note>
    </assertion>

    <assertion id="g">
      <text>If the bean class of a session bean is annotated |@Interceptor|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="h">
      <text>If the bean class of a session bean is annotated |@Decorator|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="i">
      <text>If the session bean class is a generic type, it must have scope |@Dependent|. If a session bean with a parameterized bean class declares any scope other than |@Dependent|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.2.1" title="EJB remove methods of session beans">
    <assertion id="a">
      <text>If a session bean is a stateful session bean, and the scope is |@Dependent|, the application may call any EJB remove method of a contextual instance of the session bean.</text>
    </assertion>

    <assertion id="b">
      <text>If a session bean is a stateful session bean, and the scope is not |@Dependent|, the application may not directly call any EJB remove method of any instance of the session bean.  If the application directly calls an EJB remove method of any contextual instance of a session bean that is a stateful session bean and declares any scope other than |@Dependent|, an |UnsupportedOperationException| is thrown</text>
    </assertion>

    <assertion id="da">
      <text>If the application directly calls an EJB remove method of a contextual instance of a session bean that is a stateful session bean and has scope |@Dependent| then no parameters are passed to the method by the container.</text>
    </assertion>

    <assertion id="dba">
      <text>If the application directly calls an EJB remove method of a contextual instance of a session bean that is a stateful session bean and has scope |@Dependent| then the container ignores the instance instead of destroying it when |Contextual.destroy()| is called, as defined in Section 6.5, "Lifecycle of stateful session beans"</text>
    </assertion>
  </section>

  <section id="3.2.2" title="Bean types of a session bean">
    <assertion id="aa">
      <text>The unrestricted set of bean types for a session bean contains all local interfaces of the bean and their superinterfaces.</text>
    </assertion>

    <assertion id="ba">
      <text>If the session bean has a bean class local view, the set of bean types contains the bean class and all superclasses.</text>
    </assertion>

    <assertion id="c">
      <text>|java.lang.Object| is a bean type of every session bean</text>
    </assertion>

    <assertion id="d">
      <text>Remote interfaces are not included in the set of bean types</text>
    </assertion>
  </section>

  <section id="3.2.3" title="Declaring a session bean">
    <assertion id="aa">
      <text>A session bean does not require any special annotations apart from the component-defining annotation (or XML declaration) required by the EJB specification.</text>
    </assertion>

    <group>
      <text>A bean class may also specify a scope, name, stereotypes and/or qualifiers.</text>    
      
      <assertion id="ba">
        <text>Test a bean class with a scope.</text>
      </assertion>

      <assertion id="bb">
        <text>Test a bean class with a name.</text>
      </assertion>

      <assertion id="bd">
        <text>Test a bean class with a stereotype.</text>
      </assertion>

      <assertion id="be">
        <text>Test a bean class with a qualifier.</text>
      </assertion>
    </group>

    <assertion id="c">
      <text>A session bean class may extend another bean class.</text>
    </assertion>
  </section>

  <section id="3.2.4" title="Specializing a session bean">
    <assertion id="aa">
      <text>If a bean class of a session bean X is annotated |@Specializes|, then the bean class of X must directly extend the bean class of another session bean Y. Then X directly specializes Y, as defined in Section 4.3 "Specialization".</text>
    </assertion>

    <assertion id="da">
      <text>If the bean class of X does not directly extend the bean class of another session bean, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.2.5" title="Default name for a session bean">
    <assertion id="a">
      <text>The default name for a managed bean is the unqualified class name of the session bean class, after converting the first character to lower case.</text>
    </assertion>
  </section>

  <section id="3.3" title="Producer methods">
    <assertion id="aa">
      <text>A producer method must be a non-abstract method of a managed bean class or session bean class.</text>
    </assertion>

    <assertion id="b">
      <text>A producer method may be static.</text>
    </assertion>

    <assertion id="c">
      <text>A producer method may be non-static.</text>
    </assertion>

    <assertion id="d">
      <text>If the bean is a session bean, the producer method must be either a business method of the EJB or a static method of the bean class</text>
    </assertion>

    <assertion id="e">
      <text>If a producer method sometimes returns a null value, then the producer method must have scope |@Dependent|.</text>
    </assertion>

    <assertion id="f">
      <text>If a producer method returns a null value at runtime, and the producer method declares scope other than |@Dependent|, an |IllegalProductException| is thrown by the container. This restriction allows the container to use a client proxy, as defined in Section 5.4, "Client proxies".</text>
    </assertion>

    <assertion id="ga">
      <text>If the producer method return type is a parameterized type, it must specify an actual type parameter or type variable for each type parameter.</text>
    </assertion>

    <assertion id="ha">
      <text>If a producer method return type contains a wildcard type parameter the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="iaa">
      <text>If the producer method return type is a parameterized type with a type variable, it must have scope |@Dependent|.</text>
    </assertion>
    
    <assertion id="iab">
      <text>If a producer method with a parameterized return type with a type variable declares any scope other than |@Dependent|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ib">
      <text>If a producer method return type is a type variable the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="j">
      <text>The application may call producer methods directly. However, if the application calls a producer method directly, no parameters will be passed to the producer method by the container; the returned object is not bound to any context; and its lifecycle is not managed by the container.</text>
    </assertion>

    <assertion id="k">
      <text>A bean may declare multiple producer methods.</text>
    </assertion>
  </section>

  <section id="3.3.1" title="Bean types of a producer method">
    <assertion id="a">
      <text>If the return type of a producer method is an interface, the unrestricted set of bean types contains the return type, all interfaces it extends directly or indirectly and |java.lang.Object|</text>
    </assertion>

    <group>
      <text>If a return type of a producer method is primitive or is a Java array type, the unrestricted set of bean types contains exactly two types: the method return type and |java.lang.Object|.</text>
      <assertion id="ba">
        <text>Check primitive return type</text>
      </assertion>
    
      <assertion id="bb">
        <text>Check array return type</text>
      </assertion>
    </group>
    

    <assertion id="c">
      <text>If the return type of a producer method is a class, the unrestricted set of bean types contains the return type, every superclass and all interfaces it implements directly or indirectly.</text>
    </assertion>
  </section>

  <section id="3.3.2" title="Declaring a producer method">
    <assertion id="a">
      <text>A producer method may be declared by annotating a method with the |@javax.enterprise.inject.Produces| annotation</text>
    </assertion>

    <assertion id="ba">
      <text>A producer method may specify a scope.</text>
    </assertion>

    <assertion id="bb">
      <text>A producer method may specify a name.</text>
    </assertion>

    <assertion id="bd">
      <text>A producer method may specify stereotypes.</text>
    </assertion>

    <assertion id="be">
      <text>A producer method may specify qualifiers.</text>
    </assertion>

    <group>
      <text>If a producer method is annotated |@Inject|, has a parameter annotated |@Disposes|, or has a parameter annotated |@Observes|, the container automatically detects the problem and treats it as a definition error.</text>
      
      <assertion id="ca">
        <text>Test with a producer method annotated |@Inject|.</text>
      </assertion>

      <assertion id="da">
        <text>Test with a producer method annotated |@Disposes|.</text>
      </assertion>

      <assertion id="ea">
        <text>Test with a producer method annotated |@Observes|.</text>
      </assertion>
    </group>

    <assertion id="fa">
      <text>If a non-static method of a session bean class is annotated |@Produces|, and the method is not a business method of the session bean, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ga">
      <text>Interceptors ~and decorators~ may not declare producer methods. If an interceptor ~or decorator~ has a method annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="gb">
      <text>~Interceptors and~ decorators may not declare producer methods. If an ~interceptor or~ decorator has a method annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="h">
      <text>A producer method may have any number of parameters.</text>
    </assertion>

    <assertion id="i">
      <text>All producer method parameters are injection points.</text>
    </assertion>
  </section>

  <section id="3.3.3" title="Specializing a producer method">
    <assertion id="aa">
      <text>If a producer method X is annotated |@Specializes|, then it must be non-static and directly override another producer method Y. Then X directly specializes Y, as defined in Section 4.3 "Specialization".</text>
    </assertion>

    <assertion id="ba">
      <text>If a producer method is static, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ca">
      <text>If a producer method does not directly override another producer method, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.3.4" title="Disposer methods">
    <assertion id="aa">
      <text>A disposer method must be a non-abstract method of a managed bean class or session bean class.</text>
    </assertion>

    <assertion id="b">
      <text>A disposer method may be static.</text>
    </assertion>

    <assertion id="c">
      <text>A disposer method may be non-static.</text>
    </assertion>

    <assertion id="d">
      <text>If the bean is a session bean, the disposer method must be a business method of the EJB or a static method of the bean class.</text>
    </assertion>

    <assertion id="e">
      <text>A bean may declare multiple disposer methods.</text>
    </assertion>
  </section>

  <section id="3.3.5" title="Disposed parameter of a disposer method">
    <assertion id="a">
      <text>Each disposer method must have exactly one disposed parameter, of the same type as the corresponding producer method return type.</text>
    </assertion>

    <assertion id="ba">
      <text>When searching for disposer methods for a producer method, the container considers the type and qualifiers of the disposed parameter. If a disposed parameter resolves to a producer method declared by the same bean class, according to the rules of typesafe resolution defined in Section 5.2 "Typesafe resolution", the container must call this method when destroying an instance returned by that producer method.</text>
    </assertion>

    <assertion id="da">
      <text>A disposer method may resolve to multiple producer methods declared by the bean class, in which case the container must call it when destroying any instance returned by any of these producer methods.</text>
    </assertion>
  </section>

  <section id="3.3.6" title="Declaring a disposer method">
    <assertion id="a">
      <text>A disposer method may be declared by annotating a parameter |@javax.enterprise.inject.Disposes|. That parameter is the disposed parameter</text>
    </assertion>

    <assertion id="b0">
      <text>Qualifiers may be declared by annotating the disposed parameter.</text>
    </assertion>

    <assertion id="ba">
  <text>If a method has more than one parameter annotated |@Disposes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ca">
      <text>If a disposer method is annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="da">
      <text>If a disposer method is annotated |@Inject|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ea">
      <text>If a disposer method has a parameter annotated |@Observes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="fa">
      <text>If a non-static method of a session bean class has a parameter annotated |@Disposes|, and the method is not a business method of the session bean, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="ga">
      <text>Interceptors ~and decorators~ may not declare disposer methods.  If an interceptor ~or decorator~ has a method annotated |@Disposes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="gb">
      <text>~Interceptors and ~decorators may not declare disposer methods.  If ~an interceptor or~ decorator has a method annotated |@Disposes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="h">
      <text>In addition to the disposed parameter, a disposer method may declare additional parameters, which may also specify qualifiers. These additional parameters are injection points.</text>
    </assertion>
  </section>

  <section id="3.3.7" title="Disposer method resolution">
    <assertion id="aa">
      <text>A disposer method is bound to a producer method if the producer method is declared by the same bean class as the disposer method, and the producer method is assignable to the disposed parameter, according to the rules of typesafe resolution defined in Section 5.2, "Typesafe resolution".</text>
    </assertion>

    <assertion id="ba">
      <text>If there are multiple disposer methods for a single producer method, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ca">
      <text>If there is no producer method declared by the bean class that is assignable to the disposed parameter of a dispose method, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.3.8" title="Default name for a producer method">
    <assertion id="a">
      <text>The default name for a producer method is the method name, unless the method follows the JavaBeans property getter naming convention, in which case the default name is the JavaBeans property name</text>
    </assertion>
  </section>

  <section id="3.4" title="Producer fields">
    <assertion id="aa">
      <text>A producer field must be a field of a managed bean class ~or session bean class~</text>
      <note>Just test that a producer field on these works</note>
    </assertion>
    
    <assertion id="ab">
      <text>A producer field must be a field of a ~managed bean class or~ session bean class</text>
      <note>Just test that a producer field on these works</note>
    </assertion>

    <assertion id="b">
      <text>A producer field may be static.</text>
    </assertion>

    <assertion id="c">
      <text>A producer field may be non-static.</text>
    </assertion>
    
    <assertion id="ca">
      <text> If the bean is a session bean, the producer field must be a static field of the bean class.</text>
    </assertion>

    <assertion id="d">
      <text>If a producer field sometimes contains a null value when accessed, then the producer field must have scope |@Dependent|</text>
    </assertion>

    <assertion id="e">
      <text>If a producer method contains a null value at runtime, and the producer field declares any other scope, an |IllegalProductException| is thrown by the container. This restriction allows the container to use a client proxy, as defined in Section 5.4, "Client proxies"</text>
    </assertion>

    <assertion id="fa">
      <text>If the producer field type is a parameterized type, it must specify an _actual type parameter_ or type variable for each type parameter</text>
    </assertion>
    
    <assertion id="fb">
      <text>If the producer field type is a parameterized type, it must specify an actual type parameter or _type variable_ for each type parameter</text>
    </assertion>

    <assertion id="ga">
      <text>If a producer field type contains a wildcard type parameter the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="gb">
      <text>If the producer field type is a parameterized type with a type variable, it must have scope |@Dependent|. If a producer field with a parameterized type with a type variable declares any scope other than |@Dependent|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ha">
      <text>If a producer field type is a type variable the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="i" testable="false">
      <text>The application may access producer fields directly. However, if the application accesses a producer field directly, the returned object is not bound to any context; and its lifecycle is not managed by the container</text>
      <note>This is a statement of intent</note>
    </assertion>

    <assertion id="j">
      <text>A bean may declare multiple producer fields</text>
    </assertion>
  </section>

  <section id="3.4.1" title="Bean types of a producer field">
    <assertion id="a">
      <text>The bean types of a producer field depend upon the field type.  If the field type is an interface, the unrestricted set of bean types contains the field type, all interfaces it extends directly or indirectly and |java.lang.Object|.</text>
    </assertion>

    <group>
      <text>The bean types of a producer field depend upon the field type.  If a field type is primitive or is a Java array type, the unrestricted set of bean types contains exactly two types: the field type and |java.lang.Object|.</text>
      <assertion id="ba">
        <text>Check primitive type</text>
      </assertion>
    
      <assertion id="bb">
        <text>Check array type</text>
      </assertion>
    </group>
    

    <assertion id="c">
      <text>The bean types of a producer field depend upon the field type.  If the field type is a class, the unrestricted set of bean types contains the field type, every superclass and all interfaces it implements directly or indirectly</text>
    </assertion>
  </section>

  <section id="3.4.2" title="Declaring a producer field">
    <assertion id="a">
      <text>A producer field may be declared by annotating a field with the |@javax.enterprise.inject.Produces| annotation.</text>
    </assertion>

    <assertion id="b">
      <text>A producer field may specify a scope.</text>
    </assertion>

    <assertion id="c">
      <text>A producer field may specify a name.</text>
    </assertion>

    <assertion id="e">
      <text>A producer field may specify stereotypes.</text>
    </assertion>

    <assertion id="f">
      <text>A producer field may specify qualifiers.</text>
    </assertion>
    
    <assertion id="g">
      <text>If a producer field is annotated |@Inject|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="h">
      <text>If a non-static field of a session bean class is annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="ia">
      <text>Interceptors ~and decorators~ may not declare producer fields.  If an interceptor ~or decorator~ has a field annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="ib">
      <text>Interceptors ~and decorators~ may not declare producer fields.  If ~an interceptor or~ decorator has a field annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.4.3" title="Default name for a producer field">
    <assertion id="a">
      <text>The default name for a producer field is the field name</text>
    </assertion>
  </section>

  <section id="3.5" title="Resources">
    <assertion id="ka" testable="false">
      <text>The container is not required to support resources with scope other than |@Dependent|.</text>
      <note>Statement about non-portable behavior</note>
    </assertion>

    <assertion id="l" testable="false">
      <text>A resource may not declare a bean EL name</text>
      <note>Doesn't mention the consequences of this</note>
    </assertion>
  </section>

  <section id="3.5.1" title="Declaring a resource">
    <assertion id="aa" testable="false">
      <text>A resource may be declared by specifying a Java EE component environment injection annotation as part of a producer field declaration.</text>
      <note>Introductory text for the folloiwing assertions</note>
    </assertion>

    <assertion id="bb">
      <text>For a Java EE resource, |@Resource| must be specified.</text>
    </assertion>

    <assertion id="cc">
      <text>For a persistence context, |@PersistenceContext| must be specified.</text>
    </assertion>

    <assertion id="dd">
      <text>For a persistence unit, |@PersistenceUnit| must be specified.</text>
    </assertion>

    <assertion id="ee">
      <text>For a remote EJB, |@EJB| must be specified.</text>
    </assertion>

    <assertion id="ff">
      <text>For a web service, |@WebServiceRef| must be specified.</text>
    </assertion>

    <assertion id="gg" testable="false">
      <text>The injection annotation specifies the metadata needed to obtain the resources, entity manager, entity manager factory, remote EJB instance or web service reference from the component environment.</text>
      <note>This is defined in other specs</note>
    </assertion>

    <assertion id="hh">
      <text>The bean type and qualifiers of the resource are determined by the producer field declaration.</text>
    </assertion>
    
    <assertion id="i">
      <text>If the producer field declaration specifies an EL name, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="j">
      <text>If the matching object in the Java EE component environment is not of the same type as the producer field declaration, the container automatically detects the problem and treats it as a definition errors.</text>
    </assertion>

  </section>

  <section id="3.5.2" title="Bean types of a resource">
    <group>
      <text>The unrestricted set of bean types of a resource is determined by the declared type of the producer field, as specified by Section 3.4.1, “Bean types of a producer field”.</text>
      <assertion id="aa">
        <text>Check @Resource</text>
      </assertion>
      <assertion id="ab">
        <text>Check @PersistenceContext</text>
      </assertion>
      <assertion id="ac">
        <text>Check @PersistenceUnit</text>
      </assertion>
      <assertion id="ad">
        <text>Check @EJB</text>
      </assertion>
      <assertion id="ae">
        <text>Check @WebServiceRef</text>
      </assertion>
    </group>
  </section>

  <section id="3.6" title="Additional built-in beans">
    <assertion id="a">
      <text>A Java EE or embeddable EJB container must provide a bean with qualifier |@Default| and bean type |javax.transaction.UserTransaction|, allowing injection of a reference to the JTA |UserTransaction|.</text>
    </assertion>

    <assertion id="b">
      <text>A Java EE or embeddable EJB container must provide a bean with qualifier |@Default| and bean type |javax.security.Principal|, allowing injection of a |Principal| representing the current caller identity.</text>
    </assertion>

    <assertion id="c">
      <text>A Java EE or embeddable EJB container must provide a bean with qualifier |@Default| and bean type |javax.validation.ValidationFactory|, allowing injection of the default Bean Validation |ValidationFactory|.</text>
    </assertion>

    <assertion id="d">
      <text>A Java EE or embeddable EJB container must provide a bean with qualifier |@Default| and bean type |javax.validation.Validator|, allowing injection of a |Validator| for the default Bean Validation |ValidationFactory|.</text>
    </assertion>

    <assertion id="e">
      <text>If a Java EE component class has an injection point of type |UserTransaction| and qualifier |@Default|, and may not validly make use of the JTA |UserTransaction| according to the Java EE platform specification, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>
  
  <section id="3.7" title="Bean constructors">
    <assertion id="a">
      <text>When the container instantiates a bean, it calls the bean constructor. The bean constructor is a constructor of the bean class</text>
    </assertion>
  </section>

  <section id="3.7.1" title="Declaring a bean constructor">
    <group>
      <text>The bean constructor may be identified by annotating the constructor |@Inject|</text>
      <assertion id="aa">
         <text>Test an @Inject constructor is used on a managed bean</text>
      </assertion>
      <assertion id="ab">
         <text>Test an @Inject constructor is used on a session bean</text>
      </assertion>
    </group>
    
    <assertion id="ba">
      <text>If a bean class does not explicitly declare a constructor using |@Inject|, the constructor that accepts no parameters is the bean constructor.</text>
      <note>Can't check implicit constructor</note>
    </assertion>

    <assertion id="ca">
      <text>If a bean class has more than one constructor annotated |@Inject|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="da">
      <text>If a bean constructor has a parameter annotated |@Disposes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ea">
      <text>If a bean constructor has a parameter annotated |@Observes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="f">
      <text>A bean constructor may have any number of parameters.</text>
    </assertion>

    <assertion id="g">
      <text>All parameters of a bean constructor are injection points.</text>
    </assertion>
  </section>  

  <section id="3.8" title="Injected fields">
    <group>
      <text>An injected field is a non-static, non-final field of a bean class, or of any Java EE component class supporting injection.</text>
      <assertion id="a">
        <text>Test a bean class.</text>
      </assertion>

      <assertion id="b">
        <text>Test a Java EE component class.</text>
      </assertion>
    </group>

  </section>

  <section id="3.8.1" title="Declaring an injected field">
    <assertion id="aa">
      <text>An injected field may be declared by annotating the field |@javax.inject.Inject|.</text>
    </assertion>
    
    <assertion id="b">
      <text>If an injected field is annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="3.9" title="Initializer methods">
    <group>
      <text>An initializer method is a non-abstract, non-static method of a bean class, or of any Java EE component class supporting injection.</text>

      <assertion id="a">
        <text>Test a bean-class.</text>
      </assertion>
    
      <assertion id="b">
        <text>Test a Java EE component class.</text>
      </assertion>
    </group>

    <assertion id="e">
      <text>If the bean is a session bean, the initializer method is not required to be a business method of the session bean.</text>
    </assertion>

    <assertion id="f">
      <text>Method interceptors are never called when the container calls an initializer method</text>
    </assertion>
    
    <assertion id="g">
      <text>A bean class may declare multiple (or zero) initializer methods</text>
    </assertion>

    <assertion id="h" testable="false">
      <text>The application may call initializer methods directly, but then no parameters will be passed to the method by the container</text>
      <note>This is a statement of intent</note>
    </assertion>
  </section>

  <section id="3.9.1" title="Declaring an initializer method">
    <assertion id="a">
      <text>An initializer method may be declared by annotating the method |@javax.inject.Inject|</text>
    </assertion>

    <assertion id="ab">
      <text>If a generic method of a bean is annotated |@Inject|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ba">
      <text>If an initializer method is annotated |@Produces|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ca">
      <text>If an initializer method has a parameter annotated |@Disposes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="da">
      <text>If an initializer method has a parameter annotated |@Observes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="e">
      <text>An initializer method may have any number of parameters.</text>
    </assertion>

    <assertion id="f">
      <text>All initializer method parameters are injection points.</text>
    </assertion>
  </section>

  <section id="3.10" title="The default qualifier at injection points">
    <assertion id="a">
      <text>If an injection point declares no qualifier, the injection point has exactly one qualifier, the default qualifier |@Default|.</text>
    </assertion>
  </section>
  
  <section id="3.11" title="The qualifier @Named at injection points">
    <assertion id="a">
      <text>If an injected field declares a |@Named| annotation that does not specify the |value| member, the name of the field is assumed.</text>
    </assertion>
    
    <assertion id="b">
      <text>If any other injection point declares a |@Named| annotation that does not specify the |value| member, the container automatically detects the problem and treats it as a definition error.</text>   
    </assertion>
  </section>

  <section id="3.12" title="@New qualified beans">
    <assertion id="d">
      <text>For each managed bean, a second bean exists which has the same bean class.</text>
    </assertion>

    <assertion id="e">
      <text>For each managed bean, a second bean exists which has the same bean types.</text>
    </assertion>

    <assertion id="f">
      <text>For each managed bean, a second bean exists which has the same bean constructor.</text>
    </assertion>

    <assertion id="g">
      <text>For each managed bean, a second bean exists which has the same initializer methods.</text>
    </assertion>

    <assertion id="h">
      <text>For each managed bean, a second bean exists which has the same injected fields.</text>
    </assertion>

    <assertion id="i">
      <text>For each managed bean, a second bean exists which has the same interceptor bindings.</text>
    </assertion>

    <assertion id="j">
      <text>For each session bean, a second bean exists which has the same bean class.</text>
    </assertion>

    <assertion id="k">
      <text>For each session bean, a second bean exists which has the same bean types.</text>
    </assertion>

    <assertion id="l">
      <text>For each session bean, a second bean exists which has the same bean constructor.</text>
    </assertion>

    <assertion id="m">
      <text>For each session bean, a second bean exists which has the same initializer methods.</text>
    </assertion>

    <assertion id="n">
      <text>For each session bean, a second bean exists which has the same injected fields.</text>
    </assertion>

    <assertion id="o">
      <text>For each session bean, a second bean exists which has the same interceptor bindings.</text>
    </assertion>

    <assertion id="p">
      <text>This second bean has scope |@Dependent|.</text>
    </assertion>

    <assertion id="r">
      <text>This second bean has exactly one qualifier: |@javax.enterprise.inject.New(X.class)| where |x| is the bean class.</text>
    </assertion>

    <assertion id="s">
      <text>This second bean has no bean EL name.</text>
    </assertion>

    <assertion id="t">
      <text>This second bean has no stereotypes.</text>
    </assertion>

    <assertion id="u">
      <text>This second bean has no observer methods.</text>
    </assertion>

    <assertion id="v">
      <text>This second bean has no producer methods.</text>
    </assertion>

    <assertion id="w">
      <text>This second bean has no producer fields.</text>
    </assertion>

    <assertion id="x">
      <text>This second bean has no disposer methods.</text>
    </assertion>

    <assertion id="xb">
      <text>This second bean is not an alternative.</text>
    </assertion>
    
    <assertion id="xc">
      <text>This second bean is enabled, in the sense of Section 5.1.2, "Enabled and disabled beans", if and only if some other enabled bean has an injection point with the qualifier |@New(X.class)| where |X| is the bean class.</text>
    </assertion>
    
    <assertion id="xd" testable="false">
      <text>This bean is called the |@New| qualified bean for the class |X|.</text>
    </assertion>
    
    <group>
      <text>Note that this second bean exists, and may be enabled and available for injection even if the first bean is disabled, as defined by Section 5.1.2, “Enabled and disabled beans” or if the bean class is deployed outside of a bean deployment archive, as defined in Section 12.1, “Bean deployment archives”, and is therefore not discovered during the bean discovery process defined in Chapter 12, Packaging and deployment. The container discovers |@New| qualified beans by inspecting injection points of other enabled beans.</text>
      <assertion id="ya">
        <text>Check that @New on a field injection point outside the BDA, but in the classpath causes a bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yb">
        <text>Check that @New on a field injection point (which is a session bean class) outside the BDA, but in the classpath causes a session bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yc">
        <text>Check that @New on a initializer method injection point outside the BDA, but in the classpath causes a bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yd">
        <text>Check that @New on a initializer method injection point (which is a session bean class) outside the BDA, but in the classpath causes a session bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="ye">
        <text>Check that @New on a constructor injection point outside the BDA, but in the classpath causes a bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yf">
        <text>Check that @New on a constructor injection point (which is a session bean class) outside the BDA, but in the classpath causes a session bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yg">
        <text>Check that @New on a producer method injection point outside the BDA, but in the classpath causes a bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yh">
        <text>Check that @New on a producer method injection point (which is a session bean class) outside the BDA, but in the classpath causes a session bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yi">
        <text>Check that @New on a observer method injection point outside the BDA, but in the classpath causes a bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yj">
        <text>Check that @New on a observer method injection point (which is a session bean class) outside the BDA, but in the classpath causes a session bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yk">
        <text>Check that @New on a disposer method injection point outside the BDA, but in the classpath causes a bean with qualifier @New and the given type to be created</text>
      </assertion>
      <assertion id="yl">
        <text>Check that @New on a disposer method injection point (which is a session bean class) outside the BDA, but in the classpath causes a session bean with qualifier @New and the given type to be created</text>
      </assertion>
    </group>

    <assertion id="z">
      <text>When the qualifier |@New| is specified at an injection point and no |value| member is explicitly specified, the container defaults the |value| to the declared type of the injection point.</text>
    </assertion>
  </section>

  <section id="4" title="Inheritance and specialization">

  </section>

  <section id="4.1" title="Inheritance of type-level metadata">
    <group>
      <text>Suppose a class X is extended directly or indirectly by the bean class of a managed bean or session bean Y.  If X is annotated with a qualifier type, stereotype or interceptor binding type Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and neither Y nor any intermediate class that is a subclass of X and a superclass of Y declares an annotation of type Z.</text>
  
      <assertion id="aa">
        <text>Test qualifier type for directly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="aaa">
        <text>Test qualifier type for directly extended managed bean not annotated |@Inherited| is not inherited.</text>      
      </assertion>

      <assertion id="ab">
        <text>Test stereotype for directly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="aba">
        <text>Test stereotype for directly extended managed bean not annotated |@Inherited| is not inherited.</text>      
      </assertion>

      <assertion id="ad">
        <text>Test interceptor binding type for directly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="ada">
        <text>Test interceptor binding type for directly extended managed bean not annotated |@Inherited| is not inherited.</text>
      </assertion>
      
      <assertion id="ag">
        <text>Test qualifier type for indirectly extended managed bean annotated |@Inherited| is inherited.</text>      
      </assertion>
      
      <assertion id="aga">
        <text>Test qualifier type for indirectly extended managed bean not annotated |@Inherited| is not inherited.</text>            
      </assertion>

      <assertion id="ah">
        <text>Test stereotype for indirectly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="aha">
        <text>Test stereotype for indirectly extended managed bean not annotated |@Inherited| is not inherited.</text>
      </assertion>

      <assertion id="aj">
        <text>Test interceptor binding type for indirectly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="aja">
        <text>Test interceptor binding type for indirectly extended managed bean not annotated |@Inherited| is not inherited.</text>
      </assertion>
      
      <assertion id="al">
        <text>Test qualifier type for directly extended session bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="ala">
        <text>Test qualifier type for directly extended session bean not annotated |@Inherited| is not inherited.</text>
      </assertion>

      <assertion id="am">
        <text>Test stereotype for directly extended session bean annotated |@Inherited| is inherited.</text>      
      </assertion>
      
      <assertion id="ama">
        <text>Test stereotype for directly extended session bean not annotated |@Inherited| is not inherited.</text>
      </assertion>

      <assertion id="an">
        <text>Test interceptor binding type for directly extended session bean annotated |@Inherited| is inherited.</text>      
      </assertion>
      
      <assertion id="ana">
        <text>Test interceptor binding type for directly extended session bean not annotated |@Inherited| is not inherited.</text>      
      </assertion>      

      <assertion id="ap">
        <text>Test qualifier type for indirectly extended session bean annotated |@Inherited| is inherited.</text>
      </assertion>

      <assertion id="apa">
        <text>Test qualifier type for indirectly extended session bean not annotated |@Inherited| is not inherited.</text>            
      </assertion>      

      <assertion id="aq">
        <text>Test stereotype for indirectly extended session bean annotated |@Inherited| is inherited.</text>
      </assertion>

      <assertion id="aqa">
        <text>Test stereotype for indirectly extended session bean not annotated |@Inherited| is not inherited.</text>
      </assertion>
      
      <assertion id="ar">
        <text>Test interceptor binding type for indirectly extended session bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="ara">
        <text>Test interceptor binding type for indirectly extended session bean not annotated |@Inherited| is not inherited.</text>
      </assertion>      
    </group>

    <group>
      <text>Suppose a class X is extended directly or indirectly by the bean class of a managed bean or session bean Y.  If X is annotated with a scope type Z then Y inherits the annotation if and only if Z declares the |@Inherited| meta-annotation and neither Y nor any intermediate class that is a subclass of X and a superclass of Y declares a scope type.</text>
      
      <assertion id="ba">
        <text>Test scope type for directly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="baa">
        <text>Test scope type for directly extended managed bean not annotated |@Inherited| is not inherited.</text>
      </assertion>      

      <assertion id="bc">
        <text>Test scope type for indirectly extended managed bean annotated |@Inherited| is inherited.</text>
      </assertion>

      <assertion id="bca">
        <text>Test scope type for indirectly extended managed bean not annotated |@Inherited| is not inherited.</text>
      </assertion>
      
      <assertion id="be">
        <text>Test scope type for directly extended session bean annotated |@Inherited| is inherited.</text>      
      </assertion>
      
      <assertion id="bea">
        <text>Test scope type for directly extended session bean not annotated |@Inherited| is not inherited.</text>
      </assertion>      

      <assertion id="bh">
        <text>Test scope type for indirectly extended session bean annotated |@Inherited| is inherited.</text>
      </assertion>
      
      <assertion id="bha">
        <text>Test scope type for indirectly extended session bean not annotated |@Inherited| is not inherited.</text>
      </assertion>      
    </group>

    <assertion id="hhh">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, a scope type explicitly declared by X and inherited by Y from X takes precedence over default scopes of stereotypes declared or inherited by Y.</text>
    </assertion>
    
    <assertion id="hhi">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, a scope type explicitly declared by X and inherited by Y from X takes precedence over default scopes of stereotypes declared or inherited by Y.</text>
    </assertion>    
    
    <assertion id="hhj">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, a scope type explicitly declared by X and inherited by Y from X takes precedence over default scopes of stereotypes declared or inherited by Y.</text>
    </assertion>
    
    <assertion id="hhk">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, a scope type explicitly declared by X and inherited by Y from X takes precedence over default scopes of stereotypes declared or inherited by Y.</text>
    </assertion>    

    <assertion id="i" testable="false">
      <text>For annotations defined by the bean specification, all built-in _scope types_ are declared |@Inherited|</text>
      <note>sigtest</note>
    </assertion>

    <assertion id="j" testable="false">
      <text>For annotations defined by the bean specification, all built-in _stereotypes_ are declared |@Inherited|</text>
      <note>sigtest</note>
    </assertion>

    <assertion id="k" testable="false">
      <text>For annotations defined by the bean specification, _no built-in qualifier type is declared |@Inherited|_</text>
      <note>sigtest</note>
    </assertion>

    <assertion id="m" testable="false">
      <text>The |@Named| annotation is not declared |@Inherited| and bean EL names are not inherited unless specialization is used</text>
      <note>sigtest</note>
    </assertion>

  </section>

  <section id="4.2" title="Inheritance of member-level metadata">

    <assertion id="aa">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares an injected field x then Y inherits x.</text>
    </assertion>

    <assertion id="ab">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, if X declares an injected field x then Y inherits x.</text>
    </assertion>

    <assertion id="ac">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares an injected field x then Y inherits x.</text>
    </assertion>

    <assertion id="ad">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, if X declares an injected field x then Y inherits x.</text>
    </assertion>

    <assertion id="baa">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares a _|@PostConstruct|_ method x() then Y inherits x() if and only if Y does not override the method x()</text>
    </assertion>

    <assertion id="bab">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, if X declares a _|@PostConstruct|_ method x() then Y inherits x() if and only if Y does not override the method x()</text>
    </assertion>

    <assertion id="bac">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares a _|@PostConstruct|_ method x() then Y inherits x() if and only if neither Y nor any intermediate class that is a subclass of X and a superclass of Y overrides the method x()</text>
    </assertion>

    <assertion id="bad">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, if X declares a _|@PostConstruct|_ method x() then Y inherits x() if and only if neither Y nor any intermediate class that is a subclass of X and a superclass of Y overrides the method x()</text>
    </assertion>

    <assertion id="bba">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares a _|@PreDestroy|_ method x() then Y inherits x() if and only if Y does not override the method x()</text>
    </assertion>

    <assertion id="bbb">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, if X declares a _|@PreDestroy|_ method x() then Y inherits x() if and only if Y does not override the method x()</text>
    </assertion>

    <assertion id="bbc">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares a _|@PreDestroy|_ method x() then Y inherits x() if and only if neither Y nor any intermediate class that is a subclass of X and a superclass of Y overrides the method x()</text>
    </assertion>

    <assertion id="bbd">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, if X declares a _|@PreDestroy|_ method x() then Y inherits x() if and only if neither Y nor any intermediate class that is a subclass of X and a superclass of Y overrides the method x()</text>
    </assertion>

    <assertion id="da">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares a _non-static producer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="db">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares a _non-static disposer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dc">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares a _non-static observer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dd">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, if X declares a _non-static producer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="de">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, if X declares a _non-static disposer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="df">
      <text>For class X which is extended _directly_ by the bean class of a _session_ bean Y, if X declares a _non-static observer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dg">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares a _non-static producer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dh">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares a _non-static disposer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="di">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares a _non-static observer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dj">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, if X declares a _non-static producer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dk">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, if X declares a _non-static disposer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="dl">
      <text>For class X which is extended _indirectly_ by the bean class of a _session_ bean Y, if X declares a _non-static observer method_ x() then Y does not inherit this method unless Y is explicitly declared to specialize X</text>
    </assertion>

    <assertion id="ea">
      <text>For class X which is extended _directly_ by the bean class of a _managed_ bean Y, if X declares a _non-static producer field_ x then Y does not inherit this field unless Y is explicitly declared to specialize X.</text>
      <note>We don't test session beans, as they can't have non-static producer fields</note>
    </assertion>

    <assertion id="ec">
      <text>For class X which is extended _indirectly_ by the bean class of a _managed_ bean Y, if X declares a _non-static producer field_ x then Y does not inherit this field unless Y is explicitly declared to specialize X.</text>
      <note>We don't test session beans, as they can't have non-static producer fields</note>
    </assertion>

    <assertion id="f">
      <text>If X is a generic type, and an injection point declared by X is inherited by Y, and the declared type of the injection point contains type variables declared by X, the type of the injection point inherited in Y is the declared type, after substitution of actual type arguments declared by Y or any intermediate class that is a subclass of X and a superclass of Y.</text>
    </assertion>

    <assertion id="g">
      <text>If X is a generic type, and a producer method declared by X is inherited by Y, and the declared type of the producer method contains type variables declared by X, the type of the producer method inherited in Y is the declared type, after substitution of actual type arguments declared by Y or any intermediate class that is a subclass of X and a superclass of Y.</text>
    </assertion>

    <assertion id="h">
      <text>If X is a generic type, and a producer field declared by X is inherited by Y, and the declared type of the producer field contains type variables declared by X, the type of the producer field inherited in Y is the declared type, after substitution of actual type arguments declared by Y or any intermediate class that is a subclass of X and a superclass of Y.</text>
    </assertion>

    <assertion id="i">
      <text>If X is a generic type, and a disposer method declared by X is inherited by Y, and the declared type of the disposed parameter contains type variables declared by X, the type of the disposed parameter inherited in Y is the declared type, after substitution of actual type arguments declared by Y or any intermediate class that is a subclass of X and a superclass of Y.</text>
    </assertion>

    <assertion id="j">
      <text>If X is a generic type, and an observer method declared by X is inherited by Y, and the declared type of the event parameter contains type variables declared by X, the type of the event parameter inherited in Y is the declared type, after substitution of actual type arguments declared by Y or any intermediate class that is a subclass of X and a superclass of Y.</text>
    </assertion>
  </section>

  <section id="4.3" title="Specialization">
    <assertion id="a" testable="false">
      <text>If two beans both support a certain bean type, and share at least one qualifier, then they are both eligible for injection to any injection point with that declared type and qualifier.</text>
    </assertion>

    <assertion id="ca">
      <text>When an enabled bean specializes a second bean, we can be certain that the second bean is never instantiated or called by the container.</text>
    </assertion>
    
    <assertion id="cb">
      <text>When an enabled bean specializes a second bean, we can be certain ~that the second bean is never instantiated or called by the container.~ Even if the second bean defines a producer or observer method, the method will be called upon an instance of the first bean. </text>
    </assertion>

  </section>

  <section id="4.3.1" title="Direct and indirect specialization">
    <assertion id="ia">
      <text>A bean X is said to specialize another bean Y if X directly specializes Y.</text>
    </assertion>

    <assertion id="ib">
      <text>A bean X is said to specialize another bean Y if a bean Z exists, such that X directly specializes Z and Z specializes Y.</text>
    </assertion>

    <assertion id="j">
      <text>A bean X that specializes bean Y will include all qualifiers of Y, together with all qualifiers declared explicitly by X.</text>
    </assertion>

    <assertion id="k">
      <text>A bean X that specializes bean Y will have the same name as Y if Y has a name.</text>
    </assertion>
    
    <assertion id="l">
      <text>X must have all bean types of Y.  If X does not support some bean type of Y, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <group>
      <text>If Y has a name and X declares a name explicitly, using |@Named|, the container automatically detects the problem and treats it as a definition error.</text>
            
      <assertion id="la">
        <text>Test that a specializing producer method with a name throws a deployment exception.</text>
      </assertion>
      
      <assertion id="lb">
        <text>Test that a specializing managed bean with a name throws a deployment exception.</text>
      </assertion>
      
      <assertion id="lc">
        <text>Test that a specializing enterprise bean with a name throws a deployment exception.</text>
      </assertion>            
    </group>
    
    <assertion id="n">
      <text>If an interceptor or decorator is annotated |@Specializes|, non-portable behavior results.</text>
    </assertion>
  </section>

  <section id="5" title="Dependency injection, lookup, and EL">

    <assertion id="b">
      <text>The container is required to support circularities in the bean dependency graph where at least one bean participating in every circular chain of dependencies has a normal scope, as defined in Section 6.3, "Normal scopes and pseudo-scopes".</text>
      <note>The RI has unit tests for this atm</note>
    </assertion>
    
    <assertion id="c" testable="false">
      <text>The container is not required to support circular chains of dependencies where every bean participating in the chain has a pseudo-scope.</text>
    </assertion>
  </section>

  <section id="5.1" title="Modularity">
    <group>
      <text>Beans packaged in a certain Java EE module or library are available for injection, lookup and EL resolution to classes and JSP/JSF pages packaged in some other Java EE module or library if and only if the first module or library is required to be accessible to the other module or library by the Java EE platform specification.</text>
            
      <assertion id="aa">
        <text>Test with injection.</text>
      </assertion>
      
      <assertion id="ab">
        <text>Test with lookup.</text>
      </assertion>
      
      <assertion id="ac">
        <text>Test with EL resolution.</text>
      </assertion>
    </group>
    
    <assertion id="d">
      <text>An alternative is never available for injection, lookup or EL resolution in a Java EE module or library that is not a bean deployment archive (a module or library with no |beans.xml| file.</text>
    </assertion>
    
    <assertion id="e">
      <text>Nor is an alternative available for injection, lookup or EL resolution in every bean deployment archive. An alternative must be explicitly selected in every bean deployment archive in which the alternative should be available for injection, lookup and EL resolution.</text>
    </assertion>
  </section>
  
  <section id="5.1.1" title="Declaring selected alternatives for a bean deployment archive">
    <assertion id="c">
      <text>By default, a bean deployment archive has no selected alternatives. An alternative must be explicitly declared using the &lt;alternatives&gt; element of the |beans.xml| file of the bean deployment archive.</text>
    </assertion>

    <assertion id="d" testable="false">
      <text>The &lt;alternatives&gt; element contains a list of bean classes and stereotypes. </text>
    </assertion>

    <group>
      <text>An alternative is selected for the bean deployment archive if the alternative is a managed bean or session bean and the bean class of the bean is listed.</text>
            
      <assertion id="ea">
        <text>Test with a managed bean.</text>
      </assertion>
      
      <assertion id="eb">
        <text>Test with a session bean.</text>
      </assertion>
    </group>

    <group>
	    <text>An alternative is selected for the bean deployment archive if the policy is a producer method, field or resource, and the bean class that declares the method or field is listed.</text>
	   
	   <assertion id="fa">
       <text>Test for enablement of a producer method and field.</text>
     </assertion>
       
	   <assertion id="fb">
       <text>Test for enablement of a resource.</text>
     </assertion>
  	</group>

    <assertion id="g">
      <text>An alternative is selected for the bean deployment archive if any |@Alternative| stereotype of the alternative is listed.</text>
    </assertion>

    <assertion id="h">
      <text>Each child |&lt;class&gt;| element must specify the name of a alternative bean class.  If there is no class with the specified name, or if the class with the specified name is not an alternative bean class, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <assertion id="i">
      <text>Each child |&lt;stereotype&gt;| element must specify the name of a |@Alternative| stereotype annotation. If there is no annotation with the specified name, or the annotation is not a |@Alternative| stereotype, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <assertion id="j">
      <text>If the same type is listed twice under the |&lt;alternatives&gt;| element, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <assertion id="k">
      <text>For a custom implementation of the |Bean| interface defined in Section 11.1, "The Bean interface", the container calls |isAlternative()| to determine whether the bean is an alternative, and |getBeanClass()| and |getStereotypes()| to determine whether an alternative is selected in a certain bean deployment archive.</text>
    </assertion>
  </section>
  
  <section id="5.1.2" title="Enabled and disabled beans">
    <assertion id="a" testable="false">
      <text>A bean is said to be enabled if it is deployed in a bean deployment archive, and it is not a producer method or field of a disabled bean, and it is not specialized by any other enabled bean, as defined in Section 4.3, "Specialization", and either it is not an alternative, or it is a selected alternative of at least one bean deployment archive. Otherwise, the bean is said to be disabled.</text>
      <note>Tested in 5.1.4</note>
    </assertion>
  </section>
  
  <section id="5.1.3" title="Inconsistent specialization">
    <assertion id="a">
      <text>Suppose an enabled bean X specializes a second bean Y. If there is another enabled bean that specializes Y we say that inconsistent specialization exists. The container automatically detects inconsistent specialization and treats it as a deployment problem.</text>
    </assertion>
  </section>
  
  <section id="5.1.4" title="Inter-module injection">
    <group>
      <text>A bean is available for injection in a certain module if the bean is not an interceptor or decorator, the bean is enabled, the bean is either not an alternative, or the module is a bean archive and the bean is a selected alternative of the bean archive, and the bean class is required to be accessible to classes in the module, according to the class accessibility requirements of the module architecture.</text>
      
      <assertion id="a">
        <text>Check a decorator can not be injected</text>
      </assertion>
      
      <assertion id="b">
        <text>Check an interceptor can not be injected</text>
      </assertion>
      
      <assertion id="c">
        <text>Check an enabled managed bean can be injected</text> 
      </assertion>
      
      <assertion id="d">
        <text>Check an enabled session bean can be injected</text> 
      </assertion>
      
      <assertion id="e">
        <text>Check an enabled producer field can be injected</text> 
      </assertion>
      
      <assertion id="f">
        <text>Check an enabled producer method can be injected</text> 
      </assertion>
      
      <assertion id="g">
        <text>Check producer method of a disabled bean is not injectable</text> 
      </assertion>
      
      <assertion id="h">
        <text>Check producer field of a disabled bean is not injectable</text> 
      </assertion>
      
      <assertion id="i">
        <text>Check a disabled managed bean is not injectable</text> 
      </assertion>
      
      <assertion id="j">
        <text>Check a disabled session bean is not injectable</text> 
      </assertion>
      
      <assertion id="k">
        <text>Check a specialized session bean is not injectable</text> 
      </assertion>
      
      <assertion id="l">
        <text>Check a specialized managed bean is not injectable</text> 
      </assertion>
      
      <assertion id="m">
        <text>Check a specialized producer field is not injectable</text> 
      </assertion>
      
      <assertion id="n">
        <text>Check a specialized producer method is not injectable</text> 
      </assertion>
      
      <assertion id="o">
        <text>Check a selected alternative is injected for a managed bean</text> 
      </assertion>
      
      <assertion id="p">
        <text>Check a selected alternative is injected for a session bean</text> 
      </assertion>
      
    </group>
    
    <group>
      <text>For a custom implementation of the |Bean| interface defined in Section 11.1, "The Bean interface, the container calls |getBeanClass()| to determine the bean class of the bean and |InjectionPoint.getMember()| and then |Member.getDeclaringClass()| to determine the class that declares an injection point.</text>
      <assertion id="q">
        <text>Check |Bean.getBeanClass()| is used to determine the bean class</text>
      </assertion>
      
      <assertion id="r">
        <text>Check |InjectionPoint.getMember().getDeclaringClass()| is used to determine the class declaring the injection point</text>
      </assertion>
    </group>
  </section>

  <section id="5.2" title="Typesafe resolution">
  
    <assertion id="hc" implied="true">
      <text>Check multiple types resolve to a single getBeans()</text>
    </assertion>  
    <group>
      <text>A bean is assignable to a given injection point if the bean has a bean type that matches the required type.  For this purpose, primitive types are considered to match their corresponding wrapper types in |java.lang| and array types are considered to match only if their element types are identical. Parameterized and raw types are considered to match if they are identical or if the bean type is assignable to the required type, as defined in Section 5.2.3, "Assignability of raw and parameterized types".</text>
              
      <assertion id="i">
        <text>Test with a primitive type.</text>
      </assertion>

      <assertion id="j">
        <text>Test with an array type.</text>
      </assertion>

      <assertion id="ka">
        <text>Test with a parameterized type.</text>
      </assertion>
    
      <assertion id="kb">
        <text>Test with a raw type.</text>
      </assertion>
      
      <assertion id="kc">
        <text>Test with a |@Named| bean.</text>
      </assertion>
    </group>

    <group>
      <text>A bean is assignable to a given injection point if the bean has all the required qualifiers.  If no required qualifiers were explicitly specified, the container assumes the required qualifier |@Default|. A bean has the required qualifier if it has a qualifier with (a) the same type and (b) the same annotation member value for each member which is not annotated |@javax.enterprise.util.NonBinding|.</text>
            
      <assertion id="la">
        <text>Test with beans with required qualifiers.</text>
      </assertion>
      
      <assertion id="lb">
        <text>Test with beans without required qualifiers.</text>
      </assertion>
      
      <assertion id="lc">
        <text>Test with matching beans with matching qualifier with same type.</text>
      </assertion>
      
      <assertion id="ld">
        <text>Test with matching beans with matching qualifier with same annotation member value for each member which is not annotated |@javax.enterprise.util.NonBinding|.</text>
      </assertion>
    </group>
    
    <assertion id="n">
      <text>A bean is eligible for injection to a certain injection point if it is available for injection in the module that contains the class that declares the injection point, and it is assignable to the injection point.</text>
    </assertion>

    <group>
      <text>For a custom implementation of the |Bean| interface defined in Section 11.1, "The Bean interface", the container calls |getTypes()| and |getQualifiers()| to determine the bean types and qualifiers.</text>
            
      <assertion id="na">
        <text>Test |getTypes()| determines bean types.</text>
      </assertion>
      
      <assertion id="nb">
        <text>Test |getQualifiers()| determines qualifiers.</text>
      </assertion>
    </group>
  </section>

  <section id="5.2.1" title="Unsatisfied and ambiguous dependencies">
    <assertion id="aa">
      <text>The container must validate all injection points of all enabled beans and of all other Java EE component classes supporting injection when the application is initialized to ensure that there are no unsatisfied or ambiguous dependencies. If an unsatisfied or ambiguous dependency exists, the container automatically detects the problem and treats it as a deployment problem.</text>
      <note>These need expanding out - one for each assertion that results in an exception in 5.7.1</note>
    </assertion>

    <assertion id="b">
      <text>For a custom implementation of the |Bean| interface defined in Section 11.1, "The Bean interface", the container calls  |getInjectionPoints()| to determine the set of injection points.</text>
    </assertion>
  </section>
  
  <section id="5.2.2" title="Legal injection point types">
    <assertion id="a">
      <text>Any legal bean type, as defined in Section 2.2.1, "Legal bean types" may be the required type of an injection point.</text>
    </assertion>
    
    <assertion id="b">
  <text>The required type of an injection point may contain a wildcard type parameter.  However, a type variable is not a legal injection point type.</text>
    </assertion>
    
    <assertion id="c">
      <text>If an injection point type is a type variable, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>    
  </section>

  <section id="5.2.3" title="Assignability of raw and parameterized types">
    <assertion id="a">
      <text>A parameterized bean type is considered assignable to a raw required type if the raw types are identical and all type parameters of the bean type are either unbounded type variables or |java.lang.Object|.</text>
    </assertion>
  
    <group>
      <text>A parameterized bean type is considered assignable to a parameterized required type if they have identical raw type and for each parameter: the required type parameter and the bean type parameter are actual types with identical raw type, and, if the type is parameterized, the bean type parameter is assignable to the required type parameter according to these rules, or the required type parameter is a wildcard, the bean type parameter is an actual type and the actual type is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or the required type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is assignable to or assignable from the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or the required type parameter is an actual type, the bean type parameter is a type variable and the actual type is as- signable to the upper bound, if any, of the type variable, or the required type parameter and the bean type parameter are both type variables and the upper bound of the required type parameter is assignable to the upper bound, if any, of the bean type parameter.</text>
      <assertion id="aa">
        <text>Check all type parameters of the bean type and required type are unbounded type variables.</text>
      </assertion>
      
      <assertion id="ab">
        <text>Check all type parameters of the bean type and required type are |java.lang.Object|s.</text>
      </assertion>

      <assertion id="ba">
        <text>Check the required type parameter and the bean type parameter are actual types with identical raw type</text>
      </assertion>
      
      <assertion id="bb">
        <text>Check the required type parameter and the bean type parameter are actual types with identical raw type for nested type parameters</text>
      </assertion>
      
      <assertion id="c">
        <text>Check the required type parameter is a wildcard, the bean type parameter is an actual type and the actual type is assignable to the upper bound of the wildcard and assignable from the lower bound of the wildcard</text>
      </assertion>

      <assertion id="da">
        <text>Check the required type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is _assignable to_ the upper bound of the wildcard and assignable from the lower bound of the wildcard</text>
      </assertion>
      
      <assertion id="db">
        <text>Check the required type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is _assignable from_ the upper bound of the wildcard and assignable from the lower bound of the wildcard</text>
      </assertion>

      <assertion id="e">
        <text>Check the required type parameter is an actual type, the bean type parameter is a type variable and the actual type is assignable to the upper bound of the type variable</text>
      </assertion>

      <assertion id="f">
        <text>Check the required type parameter and the bean type parameter are both type variables and the upper bound of the required type parameter is assignable to the upper bound of the bean type parameter.</text>
      </assertion>
    </group>
  
  </section>

  <section id="5.2.4" title="Primitive types and null values">
    <group>
      <text>If necessary, the container performs boxing or unboxing when it injects a value to a field or parameter of primitive or wrapper type.</text>
            
      <assertion id="aa">
        <text>Test boxing.</text>
      </assertion>
      
      <assertion id="ab">
        <text>Test unboxing.</text>
      </assertion>
    </group>

    <assertion id="aa">
      <text>If an injection point of primitive type resolves to a bean that may have null values, such as a producer method with a nonprimitive return type or a producer field with a non-primitive type, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <assertion id="ba">
      <text>For a custom implementation of the Bean interface defined in Section 11.1, "The Bean interface", the container calls |isNullable()| to determine whether the bean may have null values.</text>
    </assertion>
  </section>

  <section id="5.2.5" title="Qualifier annotations with members">
    <assertion id="a" testable="false">
      <text>Qualifier types may have annotation members.</text>
      <note>A statement of intent</note>
    </assertion>

    <assertion id="b">
      <text>An annotation member may be excluded from consideration using the |@NonBinding| annotation.</text>
    </assertion>

    <assertion id="c" testable="false">
      <text>Array-valued or annotation-valued members of a qualifier type should be annotated |@NonBinding| in a portable application. If an array-valued or annotation-valued member of a qualifier is not annotated |@NonBinding|, non-portable behavior results.</text>
    </assertion>
  </section>

  <section id="5.2.6" title="Multiple qualifiers">
    <assertion id="a">
      <text>A bean class may declare multiple qualifiers.</text>
    </assertion>

    <assertion id="b">
      <text>A producer method may declare multiple qualifiers.</text>
    </assertion>

    <assertion id="c">
      <text>A producer field may declare multiple qualifiers.</text>
    </assertion>

    <assertion id="d">
      <text>A bean must declare all of the qualifiers that are specified at the injection point to be considered a candidate for injection.</text>
    </assertion>
  </section>

  <section id="5.3" title="EL Name resolution">   
    <assertion id="d">
      <text>An EL name resolves to a bean if the bean has the given EL name, and the bean is available for injection in the war containing the JSP or JSF page with the EL expression.</text>
    </assertion>

    <assertion id="e">
      <text>For a custom implementation of the |Bean| interface defined in Section 11.1, "The Bean interface", the container calls |getName()| to determine the bean EL name.</text>
    </assertion>
  </section>

  <section id="5.3.1" title="Ambiguous EL names">
    <assertion id="ca">
      <text>An ambiguous EL name exists in an EL expression when an EL name resolves to multiple beans.  When an ambiguous EL name exists, the container attempts to resolve the ambiguity.  If any of the beans are alternatives, the container eliminates all beans that are not alternatives.  If there is exactly one bean remaining, the container will select this bean, and the ambiguous EL name is called resolvable.</text>
    </assertion>

    <group>
      <text>All unresolvable ambiguous EL names are detected by the container when the application is initialized. Suppose two beans are both accessible to classes in a certain war, and either the two beans have the same EL name and the name is not resolvable, or the EL name of one bean is of the form |x.y|, where |y| is a valid bean EL name, and |x| is the EL name of the other bean, the container automatically detects the problem and treats it as a deployment problem.</text>
            
      <assertion id="da">
         <text>Test with two beans with the same EL name.</text>
       </assertion>
    
       <assertion id="db">
         <text>Test with with an EL name in the form |x.y|.</text>
       </assertion>
	</group>    
  </section>

  <section id="5.4" title="Client proxies">
    <assertion id="b">
      <text>A contextual reference to a bean with a normal scope, as defined in Section 6.3, “Normal scopes and pseudo-scopes”, is not a direct reference to a contextual instance of the bean (the object returned by |Contextual.create()|).  Instead, the contextual reference is a client proxy object.</text>
    </assertion>

    <assertion id="a" testable="false">
      <text>Client proxies are never required for a bean whose scope is a pseudo-scope such as |@Dependent|.</text>
    </assertion>
    
    <assertion id="c" implied="true">
      <text>Client proxies are serializable</text>
      <note>For the statement "Client proxies may be passivated, even when the bean itself may not be. Therefore the container must use a client proxy whenever a bean with normal scope is injected into a bean with a passivating scope" to hold true the client proxy must be serializable.</note>
    </assertion>

    <assertion id="d">
      <text>The container must guarantee that when any valid injected reference to a bean of normal scope is invoked, the invocation is always processed by the current instance of the injected bean.</text>
    </assertion>
    
    <assertion id="e" testable="false">
      <text>Client proxies may be shared between multiple injection points.</text>
    </assertion>
  </section>

  <section id="5.4.1" title="Unproxyable bean types">
    <assertion id="aa">
      <text>Classes which don't have a non-private constructor with no parameters cannot be proxied by the container. If an injection point whose declared type cannot be proxied by the container resolves to a bean with a normal scope, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <group>
      <text>Classes which are declared final or have final methods cannot be proxied by the container. If an injection point whose declared type cannot be proxied by the container resolves to a bean with a normal scope, the container automatically detects the problem and treats it as a deployment problem.</text>
      
      <assertion id="baa">
        <text>Test with a final class.</text>
      </assertion>

      <assertion id="bba">
        <text>Test with a class that has final methods.</text>
      </assertion>
    </group>

    <assertion id="ca">
      <text>Primitive types cannot be proxied by the container. If an injection point whose declared type cannot be proxied by the container resolves to a bean with a normal scope, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <assertion id="da">
      <text>Array types cannot be proxied by the container. If an injection point whose declared type cannot be proxied by the container resolves to a bean with a normal scope, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>
    
  </section>

  <section id="5.4.2" title="Client proxy invocation">
    <assertion id="aa">
  <text>Every time a method of the bean is invoked upon a client proxy, the client proxy must obtain a contextual instance of the bean, as defined in Section 6.5.2, "Contextual instance of a bean", and invoke the method upon this instance.</text>
    </assertion>

    <assertion id="ab">
      <text>If the scope is not active, as specified in Section 6.5.1, "The active context object for a scope", the client proxy rethrows |ContextNotActiveException| or |IllegalStateException|.</text>
    </assertion>

    <assertion id="b" testable="false">
      <text>The behavior of all methods declared by |java.lang.Object|, except for |toString()|, is undefined for a client proxy.</text>
    </assertion>

  </section>

  <section id="5.5" title="Dependency injection">
    <assertion id="a">
      <text>The container is required to perform dependency injection whenever it creates a contextual instance of a session bean.</text>
    </assertion>

    <assertion id="b">
      <text>The container is required to perform dependency injection whenever it creates a contextual instance of a managed bean.</text>
    </assertion>

    <assertion id="c">
      <text>The container is required to perform dependency injection whenever it instantiates non-contextual instances of session beans (for example, session beans obtained by the application from JNDI or injected using |@EJB|).</text>
    </assertion>

    <assertion id="d">
      <text>The container is required to perform dependency injection whenever it instantiates non-contextual instances of managed beans.</text>
    </assertion>

    <group>
      <text>The container is required to perform dependency injection whenever it instantiates instances of any other Java EE component class supporting injection.</text>
      <assertion id="ea">
        <text>Test injection into a servlet listener</text>
      </assertion>
      <assertion id="eb">
        <text>Test injection into a tag handler</text>
      </assertion>
      <assertion id="ec">
        <text>Test injection into a tag library listener</text>
      </assertion>
      <assertion id="ed">
        <text>Test injection into an EJB Interceptor</text>
      </assertion>
      <assertion id="ee">
        <text>Test injection into a WS endpoint</text>
      </assertion>
      <assertion id="ef">
        <text>Test injection into a servlet</text>
      </assertion>
      <assertion id="eg">
        <text>Test injection into a filter</text>
      </assertion>
    </group>

    <assertion id="f" testable="false">
      <text>In a Java EE 5 environment, the container is not required to support injection for non-contextual objects.</text>
    </assertion>

    <assertion id="g">
      <text>The container interacts with instances of beans and other Java EE component classes supporting injection by calling methods and getting and setting the field values.</text>
    </assertion>
    
    <assertion id="h">
      <text>The object injected by the container may not be a direct reference to a contextual instance of the bean.  Instead, it is an injectable reference, as defined by Section 6.5.5, "Injectable references".</text>
    </assertion>
  </section>
  
  <section id="5.5.1" title="Injection using the bean constructor">
    <group>
  		<text>When the container instantiates a managed bean or session bean with a constructor annotated |@Inject|, the container calls this constructor, passing an injectable reference to each parameter. If there is no constructor annotated |@Inject|, the container calls the constructor with no parameters.</text>
    <assertion id="aa">
    	<text>Test managed bean with a constructor annotated |@Inject|.</text>
    </assertion>
    <assertion id="ab">
    	<text>Test session bean with a constructor annotated |@Inject|.</text>
    </assertion>
    <assertion id="ba">
    	<text>Test constructor with no parameters is used for a managed bean</text>
    </assertion>
    <assertion id="bb">
    	<text>Test constructor with no parameters is used for a session bean</text>
    </assertion>
    </group>
  </section>

  <section id="5.5.2" title="Injection of fields and initializer methods">
    <group>
      <text>When the container creates a new instance of a managed bean, session bean, or of any other Java EE component class supporting injection, the container must: Initialize the values of all injected fields. The container sets the value of each injected field to an injectable reference. Call all initializer methods, passing an injectable reference to each parameter.</text>
      <assertion id="aa">
        <text>Test session bean fields injected</text>
      </assertion>
      <assertion id="ab">
        <text>Test session bean initializer methods called</text>
      </assertion>
      <assertion id="ac">
        <text>Test managed bean fields injected</text>
      </assertion>
      <assertion id="ad">
        <text>Test managed bean initializer methods called</text>
      </assertion>
      <assertion id="ae">
        <text>Test Servlet fields injected</text>
      </assertion>
      <assertion id="af">
        <text>Test Servlet initializer methods called</text>
      </assertion>
      <assertion id="ag">
        <text>Test Servlet Filter fields injected</text>
      </assertion>
      <assertion id="ah">
        <text>Test Servlet Filter initializer methods called</text>
      </assertion>
      <assertion id="ai">
        <text>Test Servlet Listener fields injected</text>
      </assertion>
      <assertion id="aj">
        <text>Test Servlet Listener initializer methods called</text>
      </assertion>
      <assertion id="ak">
        <text>Test non-contextual session bean fields injected</text>
      </assertion>
      <assertion id="al">
        <text>Test non-contextual session bean initializer methods called</text>
      </assertion>
      <assertion id="am">
        <text>Test tag handler fields injected</text>
      </assertion>
      <assertion id="an">
        <text>Test tag handler initializer methods called</text>
      </assertion>
      <assertion id="ao">
        <text>Test EJB interceptor fields injected</text>
      </assertion>
      <assertion id="ap">
        <text>Test EJB interceptor initializer methods called</text>
      </assertion>
      <assertion id="aq">
        <text>Test WS endpoint fields injected</text>
      </assertion>
      <assertion id="ar">
        <text>Test WS endpoint bean initializer methods called</text>
      </assertion>
      <assertion id="as">
        <text>Test tag handler listener fields injected</text>
      </assertion>
      <assertion id="at">
        <text>Test tag handler listener initializer methods called</text>
      </assertion>
      <assertion id="au">
        <text>Test JSF managed bean fields injected</text>
      </assertion>
      <assertion id="av">
        <text>Test JSF managed bean initializer methods called</text>
      </assertion>
    </group> 
    
    <group>
      <text>The container must ensure that: Initializer methods declared by a class X in the type hierarchy of the bean are called after all injected fields declared by X or by superclasses of X have been initialized, and after all Java EE component environment resource dependencies declared by X or by superclasses of X have been injected. Any |@PostConstruct| callback declared by a class X in the type hierarchy of the bean is called after all initializer meth- ods declared by X or by superclasses of X have been called, after all injected fields declared by X or by superclasses of X have been initialized, and after all Java EE component environment resource dependencies declared by X or by superclasses of X have been injected. Any servlet |init()| method is called after all initializer methods have been called, all injected fields have been initialized and all Java EE component environment resource dependencies have been injected.</text>
      <assertion id="ba">
        <text>Test session bean initializer methods called after injected field of X</text>
      </assertion>
      <assertion id="bb">
        <text>Test session bean initializer methods called after injected field of superclass of X</text>
      </assertion>
      <assertion id="bc">
        <text>Test session bean initializer methods called after EE resource injection of X</text>
      </assertion>
      <assertion id="bd">
        <text>Test session bean initializer methods called after EE resource injection of superclass of X</text>
      </assertion>
      <assertion id="be">
        <text>Test session bean @PostConstruct called after initializer of X</text>
      </assertion>
      <assertion id="bf">
        <text>Test session bean @PostConstruct called after initializer of superclass of X</text>
      </assertion>
      <assertion id="bg">
        <text>Test managed bean initializer methods called after injected field of X</text>
      </assertion>
      <assertion id="bh">
        <text>Test managed bean initializer methods called after injected field of superclass of X</text>
      </assertion>
      <assertion id="bi">
        <text>Test managed bean initializer methods called after EE resource injection of X</text>
      </assertion>
      <assertion id="bj">
        <text>Test managed bean initializer methods called after EE resource injection of superclass of X</text>
      </assertion>
      <assertion id="bk">
        <text>Test managed bean @PostConstruct called after initializer of X</text>
      </assertion>
      <assertion id="bl">
        <text>Test managed bean @PostConstruct called after initializer of superclass of X</text>
      </assertion>
      <assertion id="bm">
        <text>Servlet |init()| method called after initializer method</text>
      </assertion>
      <assertion id="bn">
        <text>Servlet |init()| method called after injected fields</text>
      </assertion>
      <assertion id="bo">
        <text>Servlet |init()| method called after Java EE resource injection</text>
      </assertion>
      <assertion id="bp">
        <text>Servlet Filter |init()| method called after initializer method</text>
      </assertion>
      <assertion id="bq">
        <text>Servlet Filter |init()| method called after injected fields</text>
      </assertion>
      <assertion id="br">
        <text>Servlet Filter |init()| method called after Java EE resource injection</text>
      </assertion>
    </group>
  </section>

  <section id="5.5.3" title="Destruction of dependent objects">
    <assertion id="a">
      <text>When the container destroys an instance of a bean or of any Java EE component class supporting injection, the container destroys all dependent objects, as defined in Section 6.4.2, "Destruction of objects with scope @Dependent", after the |@PreDestroy| callback completes and after the servlet |destroy()| method is called.</text>
    </assertion>
  </section>

  <section id="5.5.4" title="Invocation of producer or disposer methods">
    <assertion id="a">
      <text>When the container calls a producer method, if the method is static, the container must invoke the method.</text>
    </assertion>

    <assertion id="b">
      <text>When the container calls a disposer method, if the method is static, the container must invoke the method.</text>
    </assertion>

    <assertion id="c">
      <text>When the container calls a producer method, if the method is non-static the container must obtain a contextual instance of the most specialized bean, as defined by Section 6.5.2 "Contextual instance of a bean", then invoke the method upon this instance.</text>
    </assertion>

    <assertion id="d">
      <text>When the container calls a disposer method, if the method is non-static the container must obtain a contextual instance of the most specialized bean, as defined by Section 6.5.2 "Contextual instance of a bean", then invoke the method upon this instance.</text>
    </assertion>

    <assertion id="e">
      <text>The container passes an injectable reference to each injected method parameter.  The container is also responsible for destroying dependent objects created during this invocation, as defined in Section 6.4.2, "Destruction of objects with scope @Dependent".</text>
    </assertion>
  </section>

  <section id="5.5.5" title="Access to producer field values">
    <assertion id="a">
      <text>When the container accesses the value of a producer field, if the producer field is static, the container must access the field value.</text>
    </assertion>

    <assertion id="b">
      <text>When the container accesses the value of a producer field, if the producer field is non-static, the container must obtain a contextual instance of the bean which declares the producer field, as defined by Section 6.5.2 "Contextual instance of a bean", then access the field value of this instance.</text>
    </assertion>
  </section>

  <section id="5.5.6" title="Invocation of observer methods">
    <assertion id="a">
      <text>When the container calls an observer method (defined in Section 10.4 "Observer methods"), if the observer method is static, the container must invoke the method.</text>
    </assertion>

    <assertion id="baa">
      <text>When the container calls an observer method (defined in Section 10.5 "Observer methods"), if the observer method is non-static, the container must obtain a contextual instance of the bean according to Section 6.5.2 "Contextual instance of a bean".  If this observer method is a conditional observer method, obtain the contextual instance that already exists, only if the scope of the bean that declares the observer method is currently active, without creating a new contextual instance.  Finally, the container must invoke the observer method on the resulting instance, if any, as a business method invocation, as defined in Section 7.2 "Container invocations and interception".</text>
    </assertion>

    <assertion id="c">
      <text>The container must pass the event object to the event parameter and an injectable instance to each injected method parameter.</text>
    </assertion>

    <assertion id="d">
      <text>The container is also responsible for destroying dependent objects created during this invocation, as defined in Section 6.4.2, "Destruction of objects with scope @Dependent".</text>
    </assertion>
  </section>

  <section id="5.5.7" title="Injection point metadata">
    <assertion id="aa">
  <text>The |javax.enterprise.inject.spi.InjectionPoint.getBean()| method returns the Bean object representing the bean that defines the injection point.  If the injection point does not belong to a bean, |getBean()| returns a null value.</text>
    </assertion>

    <assertion id="ba">
      <text>The |javax.enterprise.inject.spi.InjectionPoint.getType()| method returns the declared type of the injection point.</text>
    </assertion>

    <assertion id="bc">
      <text>The |javax.enterprise.inject.spi.InjectionPoint.getQualifiers()| method returns the declared qualifiers of the injection point.</text>
    </assertion>

    <assertion id="ca">
  <text>The |javax.enterprise.inject.spi.InjectionPoint.getMember()| method returns the |Field| object in the case of field injection.</text>
    </assertion>

    <assertion id="cb">
      <text>The |javax.enterprise.inject.spi.InjectionPoint.getMember()| method returns the |Method| object in the case of method parameter injection.</text>
    </assertion>

    <assertion id="cc">
      <text>The |javax.enterprise.inject.spi.InjectionPoint.getMember()| method returns the |Constructor| object in the case of constructor parameter injection.</text>
    </assertion>

    <assertion id="daa">      
      <text>The |getAnnotated()| method returns an instance of |javax.enterprise.inject.spi.AnnotatedField| or |javax.enterprise.inject.spi.AnnotatedParameter|, depending upon whether the injection point is an injected field or a constructor/method parameter.</text>
    </assertion>

    <assertion id="dba">
      <text>The |isDelegate()| method returns true if the injection point is a decorator delegate injection point, and false otherwise.</text>
    </assertion>

    <assertion id="dca">
      <text>The |isTransient()| method returns true if the injection point is a transient field, and false otherwise.</text>
    </assertion>

    <assertion id="ea">
      <text>The container must provide a bean with scope |@Dependent|, bean type |InjectionPoint| and qualifier |@Default|, allowing dependent objects, as defined in Section 6.4.1, "Dependent objects", to obtain information about the injection point to which they belong.</text>
    </assertion>

	<assertion id="eb">
	   <text>The built-in implementation must be a passivation capable dependency, as defined in Section 6.6.2, "Passivation capable dependencies".</text>
	</assertion>

    <assertion id="f">
      <text>If a bean that declares any scope other than |@Dependent| has an injection point of type |InjectionPoint| and qualifier |@Default|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="ga">
      <text>If a Java EE component class supporting injection that is not a bean has an injection point of type |InjectionPoint| and qualifier |@Default|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="5.6" title="Programmatic lookup">
    <assertion id="aa">
      <text>An instance of the |javax.enterprise.inject.Instance| interface may be injected.</text>
    </assertion>

    <assertion id="ba">
      <text>The method |javax.enterprise.inject.Instance.get()| returns a contextual reference.</text>
    </assertion>

    <assertion id="ca">
      <text>Any combination of qualifiers may be specified at the injection point.</text>
    </assertion>

    <assertion id="da">
      <text>The |@Any| qualifier may be used to allow the application to specify qualifiers dynamically.</text>
    </assertion>
    
    <assertion id="e">
      <text>The |@New| qualifier may be used, allowing the application to obtain a |@New| qualified bean, as defined in Section 3.12, "@New qualified beans".</text>
    </assertion>
  </section>

  <section id="5.6.1" title="The Instance interface">
    <assertion id="aa">
      <text>The |Instance| interface provides a method for obtaining instances of beans with a specified combination of required type and qualifiers, and inherits the ability to iterate beans with that combination of required type and qualifiers from |java.lang.Iterable|.</text>
    </assertion>

    <assertion id="ab">
      <text>For an injected |Instance|, the required type is the type parameter specified at the injection point, and the required qualifiers are the qualifiers specified at the injection point.</text>
    </assertion>

    <assertion id="ba">
    <text>The |select()| method returns a child |Instance| for a given required type and additional required qualifiers.  If no required type is given, the required type is the same as the parent.</text>
    </assertion>

    <assertion id="da">
      <text>If two instances of the same qualifier type are passed to |select()|, an |IllegalArgumentException| is thrown.</text>
    </assertion>

    <assertion id="e">
      <text>If an instance of an annotation that is not a qualifier type is passed to |select()|, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="fa">
      <text>The |get()| method must identify a bean that has the required type and required qualifiers and is eligible for injection into the class into which the parent |Instance| was injected, according to the rules of typesafe resolution, as defined in Section 5.2, "Typesafe resolution", resolving ambiguities according to Section 5.2.1, "Unsatisfied and ambiguous dependencies".</text>
    </assertion>

    <assertion id="fba">
      <text>If typesafe resolution results in an unsatisfied dependency, throw an |UnsatisfiedResolutionException|.</text>
    </assertion>
    
    <assertion id="fbb">
      <text>If typesafe resolution results in an unresolvable ambiguous dependency, throw an |AmbiguousResolutionException|.</text>
    </assertion>

    <assertion id="fc">
      <text>Otherwise, obtain a contextual reference for the bean and the required type, as defined in Section 6.5.3, "Contextual reference for a bean".</text>
    </assertion>

    <assertion id="ja">
      <text>The |iterator()| method must identify the set of beans that have the required type and required qualifiers and are eligible for injection into the class into which the parent |Instance| was injected, according to the rules of typesafe resolution, as defined in Section 5.2, "Typesafe resolution".</text>
    </assertion>

    <assertion id="ka">
      <text>The |iterator()| method must return an |Iterator|, that iterates over the set of contextual references for the resulting beans and required type, as defined in Section 6.5.3, "Contextual reference for a bean".</text>
    </assertion>

    <assertion id="l">
      <text>The method |isUnsatisfied()| returns |true| if there is no bean that has the required type and qualifiers and is eligible for injection into the class into which the parent |Instance| was injected, or |false| otherwise.</text>
    </assertion>

    <assertion id="m">
      <text>The method |isAmbiguous()| returns |true| if there is more than one bean that has the required type and qualifiers and is eligible for injection into the class into which the parent |Instance| was injected, or |false| otherwise.</text>
    </assertion>
  </section>

  <section id="5.6.2" title="The built-in Instance">
    <assertion id="a">
      <text>The container must provide a built-in bean with |Instance&lt;X&gt;| and |Provider&lt;X&gt;| for every legal bean type |x| in its set of bean types.</text>
    </assertion>

    <assertion id="b">
      <text>The container must provide a built-in bean with every qualifier type in its set of qualifier types.</text>
    </assertion>

    <assertion id="d">
      <text>The container must provide a built-in bean with scope @Dependent.</text>
    </assertion>

    <assertion id="e">
      <text>The container must provide a built-in bean with no bean EL name.</text>
    </assertion>

    <assertion id="f">
      <text>The container must provide a built-in bean with an implementation provided automatically by the container. </text>
    </assertion>

    <assertion id="g">
    <text>The built-in implementation must be a passivation capable dependency, as defined in Section 6.6.2, "Passivation capable dependencies".</text>
    </assertion>
  </section>

  <section id="5.6.3" title="Using AnnotationLiteral and TypeLiteral">
    <assertion id="a" implied="true">
      <text>Test |javax.enterprise.util.AnnotationLiteral| when using |Instance.select()| to specify qualifiers.</text>
    </assertion>
    
    <assertion id="b" implied="true">
      <text>Test |javax.enterprise.util.TypeLiteral| when specifying a parameterized type with actual type parameters when calling |Instance.select()|.</text>
    </assertion>
  </section>

  <section id="6" title="Scopes and contexts">

  </section>

  <section id="6.1" title="The Contextual interface">
    <assertion id="a0">
      <text>If an exception occurs while creating an instance, the exception is rethrown by the |create()| method. If the exception is a checked exception, it must be wrapped and rethrown as an (unchecked) |CreationException|.</text>
    </assertion>

    <assertion id="a1">
      <text>If an exception occurs while destroying an instance, the exception must be caught by the |destroy()| method.</text>
    </assertion>

    <assertion id="a2" testable="false">
      <text>If the application invokes a contextual instance after it has been destroyed, the behavior is undefined.</text>
      <note>A statement about container specific behavior which is not spec defined</note>
    </assertion>

    <assertion id="a" testable="false">
      <text>The container and portable extensions may define implementations of the |Contextual| interface that do not extend |Bean|, but it is not recommended that applications directly implement |Contextual|.</text>
      <note>Advice only</note>
    </assertion>
  </section>

  <section id="6.1.1" title="The CreationalContext interface">
    <assertion id="ca" testable="false">
      <text>The interface |javax.enterprise.context.spi.CreationalContext| provides operations that are used by the |Contextual| implementation during instance creation and destruction.</text>
      <note>introductory text</note>
    </assertion>

    <assertion id="d">
  <text>|push()| registers an incompletely initialized contextual instance with the container.  A contextual instance is considered incompletely initialized until it is returned by the |create()| method.</text>
    </assertion>

    <assertion id="e">
      <text>|release()| destroys all dependent objects, as defined in Section 6.4.1, "Dependent objects", of the instance which is being destroyed, by passing each dependent object to the |destroy()| method of its |Contextual| object.</text>
    </assertion>

    <assertion id="f" testable="false">
      <text>The implementation of |Contextual| is not required to call |push()|. However, for certain bean scopes, invocation of |push()| between instantiation and injection helps the container minimize the use of client proxy objects (which would otherwise be required to allow circular dependencies).</text>
    </assertion>

    <assertion id="g">
      <text>If |Contextual.create()| calls |push()|, it must also return the instance passed to |push()|.</text>
    </assertion>

    <assertion id="h" testable="false">
      <text>|Contextual.create()| should use the given |CreationalContext| when obtaining contextual references to inject, as defined in Section 6.5.3, "Contextual reference for a bean", in order to ensure that any dependent objects are associated with the contextual instance that is being created.</text>
      <note>Advice</note>
    </assertion>

    <assertion id="i" testable="false">
      <text>|Contextual.destroy()| should call |release()| to allow the container to destroy dependent objects of the contextual instance.</text>
      <note>Advice</note>
    </assertion>
  </section>

  <section id="6.2" title="The Context interface">
    <assertion id="aa" testable="false">
      <text>The |javax.enterprise.context.spi.Context| interface provides an operation for obtaining contextual instances with a particular scope of any contextual type.</text>
      <note>Introductory text</note>
    </assertion>

    <assertion id="ab">
      <text>The method |getScope()| returns the scope type of the context object.</text>
    </assertion>

    <assertion id="ha">
      <text>When a context object is active the |isActive()| method returns |true|. Otherwise, we say that the context object is inactive and the |isActive()| method returns false.</text>
    </assertion>

    <assertion id="j">
      <text>The |Context.get()| method may either return an existing instance of the given contextual type, ~or if no |CreationalContext| is given, return a null value, or if a |CreationalContext| is given, create a new instance of the given contextual type by calling |Contextual.create()| and return the new instance~.</text>
    </assertion>

    <assertion id="k">
      <text>The |Context.get()| method may either ~return an existing instance of the given contextual type~, or if no |CreationalContext| is given, return a null value, ~or if a |CreationalContext| is given, create a new instance of the given contextual type by calling |Contextual.create()| and return the new instance~.</text>
    </assertion>

    <assertion id="l">
      <text>The |Context.get()| method may either ~return an existing instance of the given contextual type, or if no |CreationalContext| is given, return a null value~, or if a |CreationalContext| is given, create a new instance of the given contextual type by calling |Contextual.create()| and return the new instance.</text>
    </assertion>

    <assertion id="m">
      <text>If the context object is inactive, the |get()| method must throw a |ContextNotActiveException|.</text>
    </assertion>

    <assertion id="na">
      <text>The |get()| method may not return a null value _unless no |CreationalContext| is given_, or |Contextual.create()| returns a null value.</text>
    </assertion>

    <assertion id="nb">
      <text>The |get()| method may not return a null value unless no |CreationalContext| is given, or _|Contextual.create()| returns a null value_.</text>
    </assertion>

    <assertion id="o">
      <text>The |get()| method may not create a new instance of the given contextual type unless a |CreationalContext| is given.</text>
    </assertion>

    <assertion id="p">
      <text>The context object is responsible for destroying any contextual instance it creates by passing the instance to the |destroy()| method of the |Contextual| object representing the contextual type.</text>
    </assertion>

    <assertion id="q">
      <text>A destroyed instance must not subsequently be returned by the |get()| method.</text>
    </assertion>

    <assertion id="r">
      <text>The context object must pass the same instance of |CreationalContext| to |Contextual.destroy()| that it passed to |Contextual.create()| when it created the instance.</text>
    </assertion>
  </section>

  <section id="6.3" title="Normal scopes and pseudo-scopes">
    <assertion id="a" testable="false">
      <text>There may be no more than one mapped instance of a context object per contextual type per thread</text>
      <note>Not testable through API</note>
    </assertion>

    <assertion id="b" testable="false">
      <text>A context may be associated with one or more threads</text>
      <note>A statement of intent</note>
    </assertion>

    <assertion id="c">
      <text>The |get()| operation of the |Context| object for an active normal scope returns the current instance of the given contextual type.</text>
    </assertion>

    <assertion id="d">
      <text>When a context is destroyed, all mapped instances belonging to that context are destroyed by passing them to the |Contextual.destroy()| method.</text>
    </assertion>

    <assertion id="e">
      <text>Contexts with normal scopes must obey the following rule: Suppose beans A, B and Z all have normal scopes. Suppose A has an injection point x, and B has an injection point y. Suppose further that both x and y resolve to bean Z according to the typesafe resolution algorithm. If a is the current instance of A, and b is the current instance of B, then both a.x and b.y refer to the same instance of Z. This instance is the current instance of Z.</text>
    </assertion>
    
    <assertion id="ea" testable="false">
      <text>All normal scopes must be explicitly declared |@NormalScope|, to indicate to the container that a client proxy is required.</text>
      <note>A statement of intent</note>
    </assertion>

    <assertion id="fa" testable="false">
      <text>All pseudo-scopes must be explicitly declared |@Scope|, to indicate to the container that no client proxy is required.</text>
      <note>A statement of intent</note>
    </assertion>

    <assertion id="g" testable="false">
      <text>All scopes defined by this specification, except for the |@Dependent| pseudo-scope, are normal scopes</text>
      <note>A statement of intent</note>
    </assertion>
  </section>

  <section id="6.4" title="Dependent pseudo-scope">
    <assertion id="a">
      <text>When a bean is declared to have |@Dependent| scope, no injected instance of the bean is ever shared between multiple injection points.</text>
    </assertion>

    <assertion id="b">
      <text>When a bean is declared to have |@Dependent| scope, any instance of the bean injected into an object that is being created by the container is bound to the lifecycle of the newly created object.</text>
    </assertion>

    <assertion id="ca">
      <text>When a bean is declared to have |@Dependent| scope, when a unified EL expression in a JSF or JSP page that refers to the bean by its EL name is evaluated, at most one instance of the bean is instantiated.  This instance exists to service just a single evaluation of the EL expression.  It is reused if the bean EL name appears multiple times in the EL expression, but is never reused when the EL expression is evaluated again, or when another EL expression is evaluated.</text>
    </assertion>

    <group>
      <text>When a bean is declared to have |@Dependent| scope, any instance of the bean that receives a producer method, producer field, disposer method or observer method invocation exists to service that invocation only</text>
        
      <assertion id="da">
        <text>Test with a producer method.</text>
      </assertion>

      <assertion id="db">
        <text>Test with a producer field.</text>
      </assertion>

      <assertion id="dc">
        <text>Test with a disposer method.</text>
      </assertion>

      <assertion id="dd">
        <text>Test with an observer method.</text>
      </assertion>
    </group>
    
    <assertion id="dg">
      <text>When a bean id declared to have |@Dependent| scope, any instance of the bean injected into method parameters of a disposer method or observer method exists to service the method invocation only (except for observer methods of container lifecycle events).</text>
    </assertion>

    <assertion id="e">
      <text>Every invocation of the |get()| operation of the |Context| object for the |@Dependent| scope with a |CreationalContext| returns a new instance of the given bean.</text>
    </assertion>

    <assertion id="f">
      <text>Every invocation of the |get()| operation of the |Context| object for the |@Dependent| scope with no |CreationalContext| returns a null value.</text>
    </assertion>

    <assertion id="g">
      <text>The |@Dependent| scope is always active.</text>
    </assertion>
  </section>

  <section id="6.4.1" title="Dependent objects">
    <group>
      <text>Instances of interceptors or decorators with scope |@Dependent| are dependent objects of the bean instance they decorate.</text>
      <assertion id="aa">
        <text>Test with a |@Dependent|-scoped interceptor.</text>
      </assertion>
      
      <assertion id="ab">
        <text>Test with a |@Dependent|-scoped decorator.</text>
      </assertion>
    </group>

    <group>
      <text>An instance of a bean with scope |@Dependent| injected into a field, bean constructor or initializer method is a dependent object of the bean or Java EE component class instance into which it was injected.</text>
            
      <assertion id="ga">
        <text>Test with |@Dependent|-scoped bean injected into field.</text>
      </assertion>
      
      <assertion id="gb">
        <text>Test with |@Dependent|-scoped bean injected into bean constructor.</text>
      </assertion>
      
      <assertion id="gc">
        <text>Test with |@Dependent|-scoped bean injected into initializer method.</text>
      </assertion>      
    </group>
    
    <assertion id="h">
      <text>An instance of a bean with scope |@Dependent| injected into a producer method is a dependent object of the producer method bean instance that is being produced.</text>
    </assertion>
    
    <assertion id="i">
      <text>An instance of a bean with scope |@Dependent| obtained by direct invocation of an |Instance| is a dependent object of the instance of |Instance|.</text>
    </assertion>
  </section>

  <section id="6.4.2" title="Destruction of objects with scope @Dependent">
  
    <group>
      <text>The container must ensure that all dependent objects of a non-contextual instance of a bean or other Java EE component class are destroyed when the instance is destroyed by the container.</text>
            
      <assertion id="aaaa">
        <text>Test with a managed bean.</text>
      </assertion>
    
      <assertion id="aaab">
        <text>Test with a Java EE component.</text>
      </assertion>
    </group>
    
    <assertion id="bbb">
      <text>The container must ensure that all |@Dependent| scoped contextual instances injected into method parameters of an observer method of any container lifecycle event, as defined in Section 11.5, "Container lifecycle events", are destroyed after all observers of the |BeforeShutdown| event complete.</text>
    </assertion>
    
    <group>
      <text>The container must ensure that all |@Dependent| scoped contextual instances injected into method parameters of a disposer method or observer method of any other event are destroyed when the invocation completes.</text>
      <assertion id="ccc">
         <text>Check disposer method</text>
      </assertion>
      
      <assertion id="ccd">
         <text>Check observer method</text>
      </assertion>
    </group>
    
    <group>
      <text>The container must ensure that any |@Dependent| scoped contextual instance created to receive a producer method, producer field, disposer method or observer method invocation is destroyed when the invocation completes.</text>
      
      <assertion id="ddd">
         <text>Check producer method</text>
      </assertion>
      
      <assertion id="dde">
         <text>Check producer field</text>
      </assertion>
      
      <assertion id="ddf">
         <text>Check disposer method</text>
      </assertion>
      
      <assertion id="ddg">
         <text>Check observer method</text>
      </assertion>
    </group>
    
    
    <assertion id="eee">
      <text>The container must ensure that all |@Dependent| scoped contextual instances created during evaluation of a Unified EL expression in a JSP or JSF page are destroyed when the evaluation completes.</text>
    </assertion>

    <assertion id="e" testable="false">
      <text>The container is permitted to destroy any |@Dependent| scoped contextual instance at any time if the instance is no longer referenced by the application (excluding weak, soft and phantom references).</text>
      <note>In other words this is unspecified</note>
    </assertion>
  </section>
  
  <section id="6.4.3" title="Dependent pseudo-scope and Unified EL">
    <assertion id="a">
      <text>Suppose a Unified EL expression in a JSF or JSP page refers to a bean with scope |@Dependent| by its EL name.  Each time the EL expression is evaluated the bean is instantiated at most once, and the resulting instance is reused for every appearance of the EL name, and the resulting instance is destroyed when the evaluation completes.</text>
    </assertion>
    
    <assertion id="b">
      <text>Portable extensions that integrate with the container via Unified EL should also ensure that these rules are enforced.</text>
    </assertion>
  </section>

  <section id="6.5" title="Contextual instances and contextual references">

  </section>

  <section id="6.5.1" title="The active context object for a scope">
    <assertion id="a">
      <text>From time to time, the container must obtain an active context object for a certain scope type. The container must search for an active instance of |Context| associated with the scope type. If no active context object exists for the scope type, the container throws a |ContextNotActiveException|.</text>
    </assertion>

    <assertion id="b">
      <text>If more than one active context object exists for the given scope type, the container must throw an |IllegalStateException|.</text>
    </assertion>
  </section>

  <section id="6.5.2" title="Contextual instance of a bean">
    <assertion id="a">
      <text>From time to time, the container must obtain a contextual instance of a bean.  The container must obtain the active context object for the bean scope, then obtain an instance of the bean by calling |Context.get()|, passing the |Bean| instance representing the bean and an instance of |CreationalContext|.</text>
    </assertion>

    <assertion id="b">
      <text>From time to time, the container attempts to obtain a contextual instance of a bean that already exists, without creating a new contextual instance. The container must determine if the scope of the bean is active and if it is, obtain the active context object for the bean scope, then attempt to obtain an instance of the bean by calling |Context.get()|, passing the |Bean| instance representing the bean without passing any instance of |CreationalContext|.</text>
    </assertion>
    
    <assertion id="c" testable="false">
      <text>If the scope is not active, or if |Context.get()| returns a null value, there is no contextual instance that already exists.</text>
      <note>Statement of intent</note>
    </assertion>
    
    <assertion id="e">
      <text>For a custom implementation of the |Bean| interface defined in Section 11.1, "The Bean interface", the container calls |getScope()| to determine the bean scope.</text>
    </assertion>
  </section>

  <section id="6.5.3" title="Contextual reference for a bean">
    <assertion id="a0">
      <text>Contextual references must be obtained with a given |CreationalContext|, allowing any instance of scope |@Dependent| that is created to be later destroyed.</text>
    </assertion>
    
    <assertion id="a">
      <text>If the bean has a normal scope and the given bean type cannot be proxied by the container, as defined in Section 5.4.1, "Unproxyable bean types", the container throws an |UnproxyableResolutionException|.</text>
    </assertion>

    <assertion id="b">
      <text>If the bean has a normal scope, then the contextual reference for the bean is a client proxy, as defined in Section 5.4, "Client proxies", created by the container, that implements the given bean type and all bean types of the bean which are Java interfaces.</text>
    </assertion>

    <assertion id="c">
  <text>If the bean has a pseudo-scope, the container must obtain a contextual instance of the bean. If the bean has scope |@Dependent|, the container must associate it with the |CreationalContext|.</text>
    </assertion>

    <assertion id="d">
      <text>The container must ensure that every injection point of type |InjectionPoint| and qualifier |@Default| of any dependent object instantiated during this process receives an instance of |InjectionPoint| representing the injection point into which the dependent object will be injected, or a null value if it is not being injected into any injection point.</text>
    </assertion>
  </section>

  <section id="6.5.4" title="Contextual reference validity">
    <assertion id="a">
      <text>Any reference to a bean with a normal scope is valid as long as the application maintains a hard reference to it.  However, it may only be invoked when the context associated with the normal scope is active.  If it is invoked when the context is inactive, a |ContextNotActiveException| is thrown by the container.</text>
    </assertion>

    <assertion id="b" testable="false">
      <text>Any reference to a bean with a pseudo-scope (such as |@Dependent|) is valid until the bean instance to which it refers is destroyed. It may be invoked even if the context associated with the pseudo-scope is not active. If the application invokes a method of a reference to an instance that has already been destroyed, the behavior is undefined.</text>
      <note>Describes unspecified behavior</note>
    </assertion>
  </section>
  
  <section id="6.5.5" title="Injectable references">
    <assertion id="a">
      <text>From time to time, the container must obtain an injectable reference for an injection point.  The container must identify a bean according to the rules defined in Section 5.2, "Typesafe resolution" and resolving ambiguities according to Section 5.2.1, "Unsatisfied and ambiguous dependencies", then obtain a contextual reference for this bean and the type of the injection point according to Section 6.5.3, "Contextual reference for a bean".</text>
    </assertion>
    
    <assertion id="b">
      <text>For certain combinations of scopes, the container is permitted to optimize the procedure for obtaining an injectable reference for an injection point - the container is permitted to directly inject a contextual instance of the bean, as defined in Section 6.5.2, "Contextual instance of a bean", and if an incompletely initialized instance of the bean is registered with the current |CreationalContext|, as defined in Section 6.1, "The Contextual interface", the container is permitted to directly inject this instance.</text>
    </assertion>
  </section>
  
  <section id="6.5.6" title="Injectable reference validity">
    <assertion id="a">
      <text>Injectable references to a bean must respect the rules of contextual reference validity, with the following exceptions - a reference to a bean injected into a field, bean constructor or initializer method is only valid until the object into which it was injected is destroyed, a reference to a bean injected into a producer method is only valid until the producer method bean instance that is being produced is destroyed, and a reference to a bean injected into a disposer method or observer method is only valid until the invocation of the method completes.</text>
    </assertion>
    
    <assertion id="b" testable="false">
      <text>The application should not invoke a method of an invalid injected reference.  If the application invokes a method of an invalid injected reference, the behavior is undefined.</text>
      <note>Behavior is undefined.</note>
    </assertion>
  </section>

  <section id="6.6" title="Passivation and passivating scopes">
    <assertion id="a" implied="true">
      <text>Test that passivation occurs.</text>
    </assertion>
  </section>

  <section id="6.6.1" title="Passivation capable beans">
    <assertion id="a" testable="false">
      <text>As defined by the EJB specification, all stateful session beans are passivation capable. Stateless and singleton session beans are not passivation capable.</text>
      <note>Defined by EJB spec</note>
    </assertion>

    <group>
      <text>A managed bean is passivation capable if and only if the bean class is serializable and all interceptors and decorators of the bean are serializable.</text>
      
      <assertion id="ba">
        <text>Tests with a serializable bean class.</text>
      </assertion>
      
      <assertion id="bb">
        <text>Tests with a serializable interceptor.</text>
      </assertion>
      
      <assertion id="bc">
        <text>Tests with a serializable decorator.</text>
      </assertion>
    </group>

    <group>
      <text>A producer method is passivation capable if and only if it never returns a value which is not passivation capable at runtime. A producer method with a primitive return type or a return type that implements or extends |Serializable| is passivation capable. A producer method with a return type that is declared |final| and does not implement |Serializable| is not passivation capable.</text>
      
      <assertion id="caa">
        <text>Test that a producer method with a primitive return type is passivation capable.</text>
      </assertion>
          
      <assertion id="ca">
        <text>Test that a producer method with a serializable return type is passivation capable.</text>
      </assertion>
      
      <assertion id="cb">
        <text>Test that a producer method with a final, non-serializable return type is not passivation capable.</text>
      </assertion>
    </group>

    <group>
      <text>A producer field is passivation capable if and only if it never refers to a value which is not passivation capable at runtime. A producer field with a primitive type or a type that implements or extends |Serializable| is passivation capable. A producer field with a type that is declared |final| and does not implement |Serializable| is not passivation capable.</text>
      
      <assertion id="daa">
        <text>Test that a producer field with a primitive type is passivation capable.</text>
      </assertion>
    
      <assertion id="da">
        <text>Test that a producer field with a serializable type is passivation capable.</text>
      </assertion>
      
      <assertion id="db">
        <text>Test that a producer field with a final, non-serializable type is not passivation capable.</text>
      </assertion>
    </group>

    <assertion id="ea">
      <text>A custom implementation of Bean is passivation capable if it implements the interface |PassivationCapable|.</text>
    </assertion>
    
    <assertion id="f">
      <text>An implementation of |Contextual| that is not a bean is passivation capable if it implements both |PassivationCapable| and |Serializable|.</text>
    </assertion>
    
    <assertion id="g" testable="false">
      <text>The |getId()| method of the |PassivationCapable| implementation must return a value that uniquely identifies the instance of |Bean| or |Contextual|.</text>
      <note>This is a requirement of the implementation</note>
    </assertion>
    
    <assertion id="h" testable="false">
      <text>The |getId()| ~method of the |PassivationCapable| implementation must return a value that uniquely identifies the instance of |Bean| or |Contextual|.  It~ is recommended that the string contain the package name of the class that implements |Bean| or |Contextual|.</text>
      <note>Recommendation only</note>
    </assertion>
  </section>
  
  <section id="6.6.2" title="Passivation capable dependencies">
    <assertion id="a">
      <text>The container must guarantee that all session beans are passivation capable dependencies.</text>
    </assertion>

    <assertion id="b">
      <text>The container must guarantee that all beans with normal scope are passivation capable dependencies.</text>
    </assertion>

    <assertion id="c">
      <text>The container must guarantee that all passivation capable beans with scope |@Dependent| are passivation capable dependencies.</text>
    </assertion>

    <assertion id="da">
      <text>The container must guarantee that all resources are passivation capable dependencies.</text>
    </assertion>

    <assertion id="e">
      <text>The container must guarantee that the built-in beans of type |Instance|, |Event|, |InjectionPoint| and |BeanManager| are passivation capable dependencies.</text>
    </assertion>

    <assertion id="fa">
      <text>A custom implementation of |Bean| is a passivation capable dependency if it implements |PassivationCapable| or if |getScope()| returns a normal scope type.</text>
    </assertion>
  </section>

  <section id="6.6.3" title="Passivating scopes">
    <group>
      <text>A passivating scope requires that beans with the scope are passivation capable, and implementations of |Contextual| passed to any context object for the scope are passivation capable.</text>
            
      <assertion id="a">
        <text>Test that a bean with the scope is passivation capable.</text>
      </assertion>
      
      <assertion id="b">
        <text>Test that an implementation of |Contextual| passed to the context object for the scope is passivation capable.</text>
      </assertion>
    </group>
    
    <assertion id="b" testable="false">
      <text>Passivating scopes must be explicitly declared |@NormalScope(passivating=true)|.</text>
      <note>A statement of intent</note>
    </assertion>
  </section>

  <section id="6.6.4" title="Validation of passivation capable beans and dependencies">
    <assertion id="aaa">
      <text>If a managed bean which declares a passivating scope is not passivation capable, then the container automatically detects the problem and treats it as a deployment problem.</text>
      <note>Here we check the class, as interceptors and decorators are tested below</note>
    </assertion>
    
    <group>
      <text>If a managed bean which declares a passivating scope has a non-transient injected field, bean constructor parameter or initializer method parameter that does not resolve to a passivation capable dependency, then the container automatically detects the problem and treats it as a deployment problem.</text>    
      <assertion id="aaba">
        <text>Test with injected field.</text>
      </assertion>
      
      <assertion id="aabb">
        <text>Test with bean constructor parameter.</text>
      </assertion>
      
      <assertion id="aabc">
        <text>Test with initializer method parameter.</text>
      </assertion>
    </group>
    
    <group>
      <text>If a managed bean which declares a passivating scope has an interceptor or decorator with a non-transient injected field, bean constructor parameter or initializer method parameter that does not resolve to a passivation capable dependency, then the container automatically detects the problem and treats it as a deployment problem.</text>
    
      <assertion id="aac">
        <text>Test interceptor with injected field.</text>
      </assertion>
      
      <assertion id="aad">
        <text>Test interceptor with bean constructor parameter.</text>
      </assertion>
      
      <assertion id="aae">
        <text>Test interceptor with initializer method parameter.</text>
      </assertion>
      
      <assertion id="aaf">
        <text>Test decorator with injected field.</text>
      </assertion>
      
      <assertion id="aag">
        <text>Test decorator with bean constructor parameter.</text>
      </assertion>
      
      <assertion id="aah">
        <text>Test decorator with initializer method parameter.</text>
      </assertion>
    </group>

    <group>
      <text>If a stateful session bean has a non-transient injected field, bean constructor parameter or initializer method parameter that does not resolve to a passivation capable dependency, then the container automatically detects the problem and treats it as a deployment problem.</text>    
      
      <assertion id="ba">
        <text>Test with an injected field.</text>
      </assertion>

      <assertion id="bb" testable="false">
        <text>Test with a bean constructor parameter.</text>
        <note>Session beans don't have bean constructors</note>
      </assertion>

      <assertion id="bc">
        <text>Test with an initializer method parameter.</text>
      </assertion>
    </group>
    
    <group>
      <text>If a stateful session bean has an interceptor or decorator with a non-transient injected field, bean constructor parameter or initializer method parameter that does not resolve to a passivation capable dependency, then the container automatically detects the problem and treats it as a deployment problem.</text>
            
      <assertion id="bda">
        <text>Test an interceptor with an injected field.</text>
      </assertion>
      
      <assertion id="bdb">
        <text>Test an interceptor with a bean constructor parameter.</text>
      </assertion>
      
      <assertion id="bdc">
        <text>Test an interceptor with an initializer method parameter.</text>
      </assertion>
      
      <assertion id="bdd">
        <text>Test a decorator with an injected field.</text>
      </assertion>
      
      <assertion id="bde">
        <text>Test a decorator with a bean constructor parameter.</text>
      </assertion>
      
      <assertion id="bdf">
        <text>Test a decorator with an initializer method parameter.</text>
      </assertion>
    </group>

    <group>
      <text>If a producer method declares a passivating scope and the container is able to determine that it is not passivation capable by inspecting its return type, or has a parameter that does not resolve to a passivation capable dependency, then the container automatically detects the problem and treats it as a deployment problem.</text>
            
      <assertion id="ca">
        <text>Test a producer method with a non passivation-capable return type.</text>
      </assertion>

      <assertion id="cb">
        <text>Test a producer method with a parameter that does not resolve to a passivation capable dependency.</text>
      </assertion>
    </group>

    <assertion id="d">
      <text>If a producer field declares a passivating scope and the container is able to determine that it is not passivation capable by inspecting its type, then the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <group>
      <text>If a producer method or field which declares a passivating scope returns an unserializable object at runtime, the container must throw an |IllegalProductException|.</text>
      
      <assertion id="ea">
        <text>Test with a producer method.</text>
      </assertion>
      
      <assertion id="eb">
        <text>Test with a producer field.</text>
      </assertion>
    </group>

    <group>
      <text>If a producer method or field of scope |@Dependent| returns an unserializable object for injection into an injection point that requires a passivation capable dependency, the container must throw an |IllegalProductException|</text>
      
      <assertion id="fa">
        <text>Test for a deployment exception with a producer method.</text>
      </assertion>
      
      <assertion id="fab">
        <text>Test for a runtime exception with a producer method.</text>
      </assertion>
      
      <assertion id="fb">
        <text>Test for a deployment exception with a producer field.</text>
      </assertion>
      
      <assertion id="fbb">
        <text>Test for a runtime exception with a producer field.</text>
      </assertion>
    </group>

    <group>
      <text>For a custom implementation of |Bean|, the container calls |getInjectionPoints()| to determine the injection points, and |InjectionPoint.isTransient()| to determine whether the injected point is a transient field.</text>    
    
      <assertion id="ga">
        <text>Test calling |getInjectionPoints()|.</text>
      </assertion>
      
      <assertion id="gb">
        <text>Test calling |InjectionPoint.isTransient()|.</text>
      </assertion>
    </group>

    <group>
      <text>If a bean which declares a passivating scope type, or any stateful session bean, has a decorator which is not a passivation capable dependency, the container automatically detects the problem and treats it as a deployment problem.</text>    
      
      <assertion id="ha">
        <text>Test with a bean which declares a passivating scope type.</text>
      </assertion>
      
      <assertion id="hb">
        <text>Test with a stateful session bean.</text>
      </assertion>
    </group>
  </section>

  <section id="6.7" title="Context management for built-in scopes">
    <group>
      <text>The built-in context object is active during servlet, web service and EJB invocations, or in the case of the conversation context object, for JSF requests.</text>
    </group>
    
  </section>

  <section id="6.7.1" title="Request context lifecycle">
    <assertion id="aa">
      <text>The request scope is active during the |service()| method of any servlet in the web application~, during the |doFilter()| method of any servlet filter and when the container calls any |ServletRequestListener| or |AsyncListener|.~</text>
    </assertion>

    <assertion id="ab">
      <text>The request scope is active ~during the |service()| method of any servlet in the web application~, during the |doFilter()| method of any servlet filter and when the container calls any |ServletRequestListener| or |AsyncListener|.</text>
    </assertion>

    <assertion id="c">
      <text>The request scope is active during any Java EE web service invocation.</text>
    </assertion>
    
    <assertion id="e">
      <text>The request scope is active during any asynchronous observer method notification.</text>
    </assertion>
    
    <group>
      <text>The request scope is active during any remote method invocation of any EJB, during any asynchronous method invocation of any EJB, during any call to an EJB timeout method and during message delivery to any EJB message-driven bean.</text>
    
      <assertion id="ga">
        <text>Test the request scope is active during a remote method invocation of any EJB.</text>
      </assertion>    

      <assertion id="gb">
        <text>Test the request scope is active during any asynchronous method invocation of any EJB.</text>
      </assertion>

      <assertion id="gc">
        <text>Test the request scope is active during any call to an EJB timeout method.</text>
      </assertion>

      <assertion id="gd">
        <text>Test the request scope is active during message delivery to any EJB message-driven bean.</text>
      </assertion>
    </group>
      
    <assertion id="ge">
      <text>The request scope is active during any message delivery to a |MessageListener| for a JMS topic or queue obtained from the Java EE component environment.</text>
    </assertion>        
            
    <group>
      <text>The request context is destroyed at the end of the servlet request, after the |service()| method and all |doFilter()| methods, and all |requestDestroyed()| and |onComplete()| notifications return.</text>
            
      <assertion id="baa">
        <text>Test the request context is destroyed at the end of the servlet request, after the |service()| method.</text>
      </assertion>

      <assertion id="bba">
        <text>Test the request context is destroyed after all |doFilter()| methods, and all |requestDestroyed()| and |onComplete()| notifications return.</text>
      </assertion>
    </group>

    <assertion id="d">
      <text>The request context is destroyed after the web service invocation completes.</text>
    </assertion>

    <assertion id="fa">
      <text>The request context is destroyed after the asynchronous observer notification completes</text>
    </assertion>
    
    <group>
      <text>The request context is destroyed after the EJB remote method invocation, asynchronous method invocation, timeout or message delivery completes.</text>
            
      <assertion id="ha">
        <text>Test the request context is destroyed after an EJB remote method invocation.</text>
      </assertion>

      <assertion id="hb">
        <text>Test the request context is destroyed after an EJB asynchronous method invocation.</text>
      </assertion>

      <assertion id="hc">
        <text>Test the request context is destroyed after the EJB timeout.</text>
      </assertion>

      <assertion id="hd">
        <text>Test the request context is destroyed after the message delivery completes.</text>
      </assertion>
    </group>

    <assertion id="i">
      <text>The request context is destroyed after the message delivery to the |MessageListener| completes.</text>
    </assertion>
  </section>

  <section id="6.7.2" title="Session context lifecycle">
    <assertion id="aa">
      <text>The session scope is active during the |service()| method of any servlet in the web application ~, during the |doFilter()| method of any servlet filter~ and when the container calls any |HttpSessionListener|, |AsyncListener| or |ServletRequestListener|.</text>
    </assertion>

    <assertion id="ab">
      <text>The session scope is active ~during the |service()| method of any servlet in the web application~, during the |doFilter()| method of any servlet filter and when the container calls any |HttpSessionListener|, |AsyncListener| or |ServletRequestListener|.</text>
    </assertion>

    <assertion id="b">
      <text>The session context is shared between all servlet requests that occur in the same HTTP servlet session.</text>
    </assertion>

    <assertion id="ca">
      <text>The session context is destroyed when the ~|HTTPSession| times out, after all |HttpSessionListener|s have been called~, and at the very end of any request in which |invalidate()| was called, after all filters and |ServletRequestListeners| have been called.</text>
    </assertion>
    
    <assertion id="cb">
      <text>The session context is destroyed when the |HTTPSession| times out, ~after all |HttpSessionListener|s have been called, and at the very end of any request in which |invalidate()| was called~, after all filters and |ServletRequestListeners| have been called.</text>
    </assertion>
  </section>

  <section id="6.7.3" title="Application context lifecycle">
    <group>
      <text>The application scope is active during the |service()| method of any servlet in the web application, during the |doFilter()| method of any servlet filter and when the container calls any |ServletContextListener|, |HttpSessionListener|, |AsyncListener| or |ServletRequestListener|.</text>
      <assertion id="aa">
        <text>Check service method</text>
      </assertion>

      <assertion id="ab">
        <text>Check filter.</text>
      </assertion>
      
      <assertion id="ac">
        <text>Check |ServletContextListener|.</text>
      </assertion>
      
      <assertion id="ad">
         <text>Check  |HttpSessionListener|</text>
      </assertion>
      
      <assertion id="ae">
         <text>Check |AsyncListener|</text>
      </assertion>
      
      <assertion id="af">
         <text>Check |ServletRequestListener|</text>
      </assertion>
    </group>

    <assertion id="b">
      <text>The application scope is active during any Java EE web service invocation.</text>
    </assertion>

    <assertion id="c">
      <text>The application scope is active during any asynchronous observer method notification.</text>
    </assertion>

    <group>
      <text>The application scope is also active during any remote method invocation of any EJB, during any asynchronous method invocation of any EJB, during any call to an EJB timeout method and during message delivery to any EJB message-driven bean.</text>
      <assertion id="da">
        <text>Test remote method invocation</text>
      </assertion>

      <assertion id="db">
        <text> Test asynchronous method invocation</text>
      </assertion>

      <assertion id="dc">
        <text>Test EJB timeout method</text>
      </assertion>

      <assertion id="dd">
        <text>Test message delivery to any EJB message-driven bean.</text>
      </assertion>
    </group>
   
    <group>
      <text>The application scope is active during any message delivery to a |MessageListener| for a JMS topic or queue obtained from the Java EE component environment.</text>
      <assertion id="de">
        <text>Test JMS topic</text>
      </assertion>
      <assertion id="df">
        <text>Test JMS queue</text>
      </assertion>
    </group>
    
    <group>
      <text>The application scope is active when the disposer method or |@PreDestroy| callback of any bean with any normal scope other than |@ApplicationScoped| is called.</text>
      <assertion id="dg">
        <text>Test disposer method</text>
      </assertion>
      <assertion id="dh">
        <text>Test |@PreDestroy| method</text>
      </assertion>
    </group>

    <assertion id="e">
      <text>The application context is shared between all servlet requests, asynchronous observer method notifications, web service invocations, EJB remote method invocations, EJB asynchronous method invocations, EJB timeouts and message deliveries to message driven beans that execute within the same application.</text>
      <note>A single test needs check *all* these request types</note>
    </assertion>

    <assertion id="f">
      <text>The application context is destroyed when the application is undeployed.</text>
    </assertion>
  </section>

  <section id="6.7.4" title="Conversation context lifecycle">
    <assertion id="a">
      <text>The conversation scope is active during all standard lifecycle phases of any JSF faces or non-faces request.</text>
    </assertion>

    <assertion id="c">
      <text>Any JSF request has exactly one associated conversation.</text>
    </assertion>

    <assertion id="da">
    <text>The conversation associated with a JSF request is determined at the beginning of the restore view phase and does not change during the request.</text>
    </assertion>

    <assertion id="e">
      <text>By default, a conversation is transient.</text>
    </assertion>

    <assertion id="f">
      <text>A transient conversation may be marked long-running by calling |Conversation.begin()|</text>
    </assertion>

    <assertion id="g">
      <text>A long-running conversation may be marked transient by calling |Conversation.end()|</text>
    </assertion>

    <assertion id="ha">
      <text>All long-running conversations have a string-valued unique identifier, _which may be set by the application_ when the conversation is marked long-running~, or generated by the container~</text>
    </assertion>

    <assertion id="hb">
      <text>All long-running conversations have a string-valued unique identifier, _which may be_ ~set by the application when the conversation is marked long-running, or~ _generated by the container_</text>
    </assertion>
        
    <assertion id="j">
      <text>If the conversation associated with the current JSF request is in the transient state at the end of a JSF request, it is destroyed, and the conversation context is also destroyed.</text>
    </assertion>

    <assertion id="k">
      <text>If the conversation associated with the current JSF request is in the long-running state at the end of a JSF request, it is not destroyed.</text>
    </assertion>

    <assertion id="l">
      <text>The long-running conversation context associated with a request that renders a JSF view is automatically propagated to any faces request (JSF form submission) that originates from that rendered page.</text>
    </assertion>

    <assertion id="m">
      <text>The long-running conversation context associated with a request that results in a JSF redirect (via a navigation rule) is automatically propagated to the resulting non-faces request, and to any other subsequent request to the same URL. This is accomplished via use of a GET request parameter named |cid| containing the unique identifier of the conversation.</text>
    </assertion>

    <assertion id="n">
      <text>The long-running conversation associated with a request may be propagated to any non-faces request via use of a GET request parameter named |cid| containing the unique identifier of the conversation. In this case, the application must manage this request parameter.</text>
    </assertion>

    <assertion id="o">
      <text>When no conversation is propagated to a JSF request, the request is associated with a new transient conversation.</text>
    </assertion>

    <assertion id="p">
      <text>All long-running conversations are scoped to a particular HTTP servlet session and may not cross session boundaries.</text>
    </assertion>

    <assertion id="qa">
  <text>When the HTTP servlet session is invalidated, all long-running conversation contexts created during the current session are destroyed, after the servlet |service()| method completes.</text>
    </assertion>

    <assertion id="r" testable="false">
      <text>The container is permitted to arbitrarily destroy any long-running conversation that is associated with no current JSF request, in order to conserve resources</text>
      <note>In other words, this is unspecified</note>
    </assertion>

    <assertion id="ta" testable="false">
      <text>The conversation timeout, which may be specified by calling |Conversation.setTimeout()| is a hint to the container that a conversation should not be destroyed if it has been active within the last given interval in milliseconds.</text>
      <note>Not required</note>
    </assertion>
    
    <assertion id="tb">
  <text>If the propagated conversation cannot be restored, the container must associate the request with a new transient conversation and throw an exception of type |javax.enterprise.context.NonexistentConversationException| from the restore view phase of the JSF lifecycle.  The application may handle this exception using the JSF |ExceptionHandler|.</text>
    </assertion>    

    <assertion id="ua">
  <text>The container ensures that a long-running conversation may be associated with at most one request at a time, by blocking or rejecting concurrent requests.  If the container rejects a request, it must associate the request with a new transient conversation and throw an exception of type |javax.enterprise.context.BusyConversationException| from the restore view phase of the JSF lifecycle.  The application may handle this exception using the JSF |ExceptionHandler|.</text>
    </assertion>
  </section>
  
  <section id="6.7.5" title="The Conversation interface">
    <group>
      <text>The container provides a built-in bean with bean type |Conversation|, scope |@RequestScoped|, and qualifier |@Default|, named |javax.enterprise.context.conversation|.</text>      
      <assertion id="iaa">
        <text>Test the bean type is correct.</text>
      </assertion>

      <assertion id="ib">
        <text>Test the scope is correct.</text>
      </assertion>

      <assertion id="id">
        <text>Test the qualifier is correct.</text>
      </assertion>

      <assertion id="ie">
        <text>Test the bean name is correct.</text>
      </assertion>          
    </group>
    
    <assertion id="j">
      <text>|begin()| marks the current transient conversation long-running.  A conversation identifier may, optionally, be specified.  If no conversation identifier is specified, an identifier is generated by the container.</text>
    </assertion>
    
    <assertion id="k">
      <text>|end()| marks the current long-running conversation transient.</text>
    </assertion>
    
    <assertion id="l">
      <text>|getId()| returns the identifier of the current long-running conversation, or a null value if the current conversation is transient.</text>
    </assertion>
    
    <assertion id="m">
      <text>|getTimeout()| returns the timeout, in milliseconds, of the current conversation.</text>
    </assertion>
    
    <assertion id="n">
      <text>|setTimeout()| sets the timeout of the current conversation.</text>
    </assertion>
    
    <assertion id="o">
      <text>|isTransient()| returns |true| if the conversation is marked transient, or |false| if it is marked long-running.</text>
    </assertion>
    
    <assertion id="p">
      <text>If any method of |Conversation| is called when the conversation scope is not active, a |ContextNotActiveException| is thrown.</text>
    </assertion>
    
    <assertion id="q">
      <text>If |end()| is called, and the current conversation is marked transient, an |IllegalStateException| is thrown.</text>
    </assertion>
    
    <assertion id="r">
      <text>If |begin()| is called, and the current conversation is already marked long-running, an |IllegalStateException| is thrown.</text>
    </assertion>
    
    <assertion id="s">
      <text>If |begin()| is called with an explicit conversation identifier, and a long-running conversation with that identifier already exists, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>

  <section id="7" title="Lifecycle of contextual instances">
    
  </section>
  
  <section id="7.1" title="Restriction upon bean instantiation">
    
  </section>
  
  <section id="7.2" title="Container invocations and interception">
    <assertion id="a0" testable="false">
      <text>When the application invokes a method of a bean via a contextual reference to the bean, as defined in Section 6.5.3, "Contextual reference for a bean", or a business method of a session bean via an EJB remote or local reference, the invocation is treated as a business method invocation.</text>
    </assertion>

    <assertion id="a1">
      <text>Invocations of initializer methods by the container are not business method invocations.</text>
    </assertion>
        
    <group>
      <text>Invocations of producer, disposer and observer methods by the container are business method invocations are are intercepted by method interceptors and decorators.</text>
      
      <assertion id="ia">
        <text>Verify producer methods are intercepted</text>
      </assertion>
      
      <assertion id="ib">
        <text>Verify producer methods are decorated</text>
      </assertion>
      
      <assertion id="ic">
        <text>Verify disposer methods are intercepted</text>
      </assertion>
      
      <assertion id="id">
        <text>Verify disposer methods are decorated</text>
      </assertion>
      
      <assertion id="ie">
        <text>Verify observer methods are intercepted</text>
      </assertion>
      
      <assertion id="if">
        <text>Verify observer methods are decorated</text>
      </assertion>
    </group>
    
    <assertion id="ig">
      <text>Invocation of EJB timer service timeouts by the container are not business method invocations, but are intercepted by interceptors for EJB timeouts.</text>
    </assertion>
    
    <assertion id="j">
      <text>Invocation of lifecycle callbacks by the container are not business method invocations, but are intercepted by interceptors for lifecycle callbacks.</text>
    </assertion>
    
    <group>
      <text>Invocations of interceptors and decorator methods during method or lifecycle callback interception are not business method invocations, and therefore no recursive interception occurs.</text>
      <assertion id="ka">
         <text>Verify decorators callbacks are not intercepted</text>
      </assertion>
      
      <assertion id="kb">
         <text>Verify decorators callbacks are not decorated</text>
      </assertion>
      
      <assertion id="kc">
         <text>Verify interceptor callbacks are not intercepted</text>
      </assertion>
      
      <assertion id="kd">
         <text>Verify interceptor callbacks are not decorated</text>
      </assertion>
    </group>
    
    <assertion id="a5">
      <text>Invocations of message listener methods of message-driven beans during message delivery are business method invocations.</text>
    </assertion>
  
    <group>
      <text>If, and only if, the invocation is a business method invocation it passes through method interceptors and decorators, and in the case of a session bean, it is subject to EJB services such a declarative transaction management, concurrency, security and asynchronicity, as defined by the EJB specification.</text>
      
      <assertion id="a">
        <text>Verify that a managed bean's business methods are intercepted</text>
      </assertion>
      
      <assertion id="b">
        <text>Verify that a managed bean's business methods are decorated</text>
      </assertion>
      
      <assertion id="c">
        <text>Verify that a session bean's business methods are intercepted</text>
      </assertion>
      
      <assertion id="d">
        <text>Verify that a session bean's business methods are decorated</text>
      </assertion>
    
      <assertion id="f" testable="false">
        <text>Verify that a session bean's business methods receive EJB services</text>
        <note>This is tested by the EJB TCK</note>
      </assertion>
    </group>
    
    <assertion id="g">
      <text>If the invocation is not a business method invocation, it is treated as a normal Java method call and is not intercepted by the container.</text>
    </assertion>

    <assertion id="h" implied="true">
      <text>Verify that a non-contextual session bean reference is intercepted</text> 
    </assertion>

  </section>
  
  <section id="7.3" title="Lifecycle of contextual instances">
    
  </section>

  <section id="7.3.1" title="Lifecycle of managed beans">
    <assertion id="aa">
      <text>When the |create()| method of the |Bean| object that represents a managed bean is called, the container obtains an instance of the bean, as defined by the Managed Beans specification, calling the bean constructor as defined by Section 5.5.1, "Injection using the bean constructor", and performing dependency injection as defined in Section 5.5.2, "Injection of fields and initializer methods".</text>
    </assertion>
    
    <assertion id="ba">
      <text>When the |destroy()| method is called, the container destroys the instance, as defined by the Managed Beans specification, and any dependent objects, as defined in Section 5.5.3, "Destruction of dependent objects".</text>
    </assertion>
  </section>

  <section id="7.3.2" title="Lifecycle of stateful session beans">
    <assertion id="aa">
      <text>When the |create()| method of a |Bean| object that represents a stateful session bean that is called, the container creates and returns a container-specific internal local reference to a new session bean instance. The reference must be passivation capable. This reference is not directly exposed to the application.</text>
    </assertion>

    <assertion id="bb">
      <text>Before injecting or returning a contextual instance to the application, the container transforms its internal reference into an object that implements the bean types expected by the application and delegates method invocations to the underlying stateful session bean instance. This object must be passivation capable.</text>
    </assertion>

    <assertion id="bc">
      <text>When the |destroy()| method is called, and if the underlying EJB was not already removed by direct invocation of a remove method by the application, the container removes the stateful session bean. The |@PreDestroy| callback must be invoked by the container.</text>
    </assertion>
  </section>

  <section id="7.3.3" title="Lifecycle of stateless session and singleton beans">
    <assertion id="a">
      <text>When the |create()| method of a Bean object that represents a stateless session or singleton session bean is called, the container
creates and returns a container-specific internal local reference to the session bean. This reference is not directly exposed to the application.</text>
    </assertion>

    <assertion id="b">
      <text>Before injecting or returning a contextual instance to the application, the container transforms its internal reference into an object that implements the bean types expected by the application and delegates method invocations to the underlying session bean. This object must be passivation capable.</text>
    </assertion>

    <assertion id="c">
      <text>When the |destroy()| method is called, the container simply discards this internal reference.</text>
    </assertion>
  </section>

  <section id="7.3.4" title="Lifecycle of producer methods">
    <assertion id="ea">
      <text>When the create() method of a |Bean| object that represents a producer method is called, the container must invoke the producer method as defined by Section 5.5.4, "Invocation of producer or disposer methods". The return value of the producer method, after method interception completes, is the new contextual instance to be returned by |Bean.create()|.</text>
    </assertion>

    <assertion id="k">
      <text>If the producer method returns a null value and the producer method bean has the scope |@Dependent|, the |create()| method returns a null value.</text>
    </assertion>

    <assertion id="l">
    <text>If the producer method returns a null value, and the scope of the producer method is not |@Dependent|, the |create()| method throws an |IllegalProductException|.</text>
    </assertion>

    <assertion id="ma">
      <text>When the |destroy()| method is called, and if there is a disposer method for this producer method, the container must invoke the disposer method as defined by Section 5.5.4, "Invocation of producer or disposer methods", passing the instance given to |destroy()| to the disposed parameter.</text>
    </assertion>

    <assertion id="r">
      <text>Finally, the container destroys dependent objects, as defined in Section 5.5.3, "Destruction of dependent objects".</text>
    </assertion>
  </section>

  <section id="7.3.5" title="Lifecycle of producer fields">
    <assertion id="ga">
      <text>When the |create()| method of a |Bean| object that represents a producer field is called, the container must access the producer field as defined by Section 5.5.5, "Access to producer field values" to obtain the current value of the field. The value of the producer field is the new contextual instance to be returned by |Bean.create()|.</text>
    </assertion>

    <assertion id="m">
      <text>If the producer field contains a null value and the producer field bean has the scope |@Dependent|, the |create()| method returns a null value.</text>
    </assertion>

    <assertion id="n">
    <text>If the producer field contains a null value, and the scope of the producer method is not |@Dependent|, the |create()| method throws an |IllegalProductException|.</text>
    </assertion>
  </section>

  <section id="7.3.6" title="Lifecycle of resources">
    <group>
      <text>When the |create()| method of a |Bean| object that represents a resource is called, the container creates and returns a container-specific internal reference to the Java EE component environment resource, entity manager, entity manager factory, remote EJB instance or web service reference. This reference is not directly exposed to the application.</text>
      
      <assertion id="la">
         <text>Check Java EE component environment resource</text>
      </assertion>

      <assertion id="lb">
         <text>Check Entity Manager</text>
      </assertion>

      <assertion id="lc">
         <text>Check Entity Manager Factory</text>
      </assertion>
    
      <assertion id="ld">
         <text>Check Remote EJB instance</text>
      </assertion>
      <assertion id="le">
         <text>Check Web Service Reference</text>
      </assertion>
    </group>
    
    <group>
      <text>Before injecting or returning a contextual instance to the application, the container transforms its internal reference into an object that implements the bean types expected by the application and delegates method invocations to the underlying resource, entity manager, entity manager factory, remote EJB instance or web service reference. This object must be passivation capable.</text>
      
      <assertion id="ma">
         <text>Check delegations to underlying Java EE component environment resource</text> 
      </assertion>
      
      <assertion id="mb">
         <text>Check injected Java EE component environment resource is passivation capable</text> 
      </assertion>
      
      <assertion id="mc">
         <text>Check delegations to underlying Entity Manager</text>
      </assertion>
      
      <assertion id="md">
         <text>Check injected Entity Manager is passivation capable</text> 
      </assertion>
      
      <assertion id="me">
         <text>Check delegations to Entity Manager Factory</text>
      </assertion>
      
      <assertion id="mf">
         <text>Check injected Entity Manager Factory is passivation capable</text> 
      </assertion>
      
      <assertion id="mg">
         <text>Check delegations to underlying Remote EJB instance</text>
      </assertion>
      
      <assertion id="mh">
         <text>Check injected Remote EJB instance is passivation capable</text>
      </assertion>
      
      <assertion id="mj">
         <text>Check delegations to underlying Web Service Reference</text>
      </assertion>
      
      <assertion id="mk">
         <text>Check injected Web Service Reference is passivation capable</text> 
      </assertion>
    </group>
    
    <group>
      <text>When the |destroy()| method is called, the container discards this internal reference and performs any cleanup required of state associated with the client or transaction.</text>
      
      <assertion id="na" testable="false">
         <text>Check Java EE component environment resource</text>
         <note>No behavior specified by platform spec</note>
      </assertion>
      
      <assertion id="nb">
         <text>Check Entity Manager</text>
      </assertion>
      
      <assertion id="nc" testable="false">
         <text>Check Entity Manager Factory</text>
         <note>No behavior specified by platform spec</note>
      </assertion>
      
      <assertion id="nd" testable="false">
         <text>Check Remote EJB instance</text>
         <note>No behavior specified by platform spec</note>
      </assertion>
      
      <assertion id="ne" testable="false">
         <text>Check Web Service Reference</text>
         <note>No behavior specified by platform spec</note>
      </assertion>
    </group>
    
    <group>
      <text>The container must perform ordinary Java EE component environment injection upon any non-static field that functions as a resource declaration, as defined by the Java EE platform and Common Annotations for the Java platform specifications.</text>
      <assertion id="o">
         <text>Check @Resource injection</text>
      </assertion>
    </group>
    
    
    <assertion id="p" testable="false">
      <text>The container is not required to perform Java EE component environment injection upon a static field. Portable applications should not rely upon the value of a static field that functions as a resource declaration.</text>
      <note>Defines non-portable behavior</note>
    </assertion>
  </section>

  <section id="8" title="Decorators">
    <assertion id="a" testable="false">
      <text>Decorators may be associated with any managed bean that is not itself an interceptor or decorator or with any EJB session bean.</text>
      <note>Doesn't specify an error</note>
    </assertion>        
    
    <assertion id="b">
      <text>A decorator instance is a dependent object of the object it decorates.</text>
    </assertion>
  </section>

  <section id="8.1" title="Decorator beans">
    <assertion id="a" testable="false">
      <text>A decorator is a managed bean.</text>
      <note>Statement of intent</note>
    </assertion>

    <assertion id="b">
      <text>The set of decorated types of a decorator includes all bean types of the managed bean which are Java interfaces, except for |java.io.Serializable|.</text>
    </assertion>

    <assertion id="c">
      <text>The decorator bean class and its superclasses are not decorated types of the decorator.</text>
    </assertion>

    <assertion id="d">
      <text>The decorator class may be abstract.</text>
    </assertion>
    
    <assertion id="e">
      <text>Decorators of a session bean must comply with the bean provider programming restrictions defined by the EJB specification.</text>
    </assertion>
    
    <assertion id="f">
      <text>Decorators of a stateful session bean must comply with the rules for instance passivation and conversational state defined by the EJB specification.</text>
    </assertion>
  </section>

  <section id="8.1.1" title="Declaring a decorator">
    <assertion id="a">
      <text>A decorator is declared by annotating the bean class with the |@javax.decorator.Decorator| stereotype.</text>
    </assertion>
  </section>

  <section id="8.1.2" title="Decorator delegate injection points">
    <assertion id="a">
      <text>All decorators have a delegate injection point.  A delegate injection point is an injection point of the bean class. The type and qualifiers of the injection point are called the delegate type and delegate qualifiers. The decorator applies to beans that are assignable to the delegate injection point. The delegate injection point must be be declared by annotating the injection point with the annotation |@javax.decorator.Delegate|.</text>
    </assertion>

    <group>
      <text>A decorator must have exactly one delegate injection point. If a decorator has more than one delegate injection point, or does not have a delegate injection point, the container automatically detects the problem and treats it as a definition error.</text>
      
      <assertion id="ca">
        <text>Test with more than one delegate injection point.</text>
      </assertion>

      <assertion id="cb">
        <text>Test a decorator without a delegate injection point.</text>
      </assertion>
    </group>
    
    <group>
      <text>The delegate injection point must be an injected field, initializer method parameter or bean constructor method parameter. If an injection point that is not an injected field, initializer method parameter or bean constructor method parameter is annotated |@Delegate|, the container automatically detects the problem and treats it as a definition error.</text>
    
      <assertion id="cc">
        <text>Check an injected field is ok</text>
      </assertion>
    
      <assertion id="cd">
        <text>Check an initializer method parameter is ok</text>
      </assertion>
    
      <assertion id="ce">
        <text>Check a bean constructor method parameter is ok</text>
      </assertion>
    
      <assertion id="cf">
        <text>Check that a producer method parameter is not ok</text>
      </assertion>
      
    </group>
    
    <assertion id="cg">
      <text>If a bean class that is not a decorator has an injection point annotated |@Delegate|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="f">
      <text>The container must inject a delegate object to the delegate injection point.  The delegate object implements the delegate type and delegates method invocations to the remaining uninvoked decorators and eventually to the bean.  When the container calls a decorator during business method interception, the decorator may invoke any method of the delegate object.</text>
    </assertion>
    
    <assertion id="g">
      <text>If a decorator invokes the delegate object at any other time, the invoked method throws an |IllegalStateException|.</text>
    </assertion>

  </section>

  <section id="8.1.3" title="Decorated types of a decorator">
    <assertion id="a">
      <text>The delegate type of a decorator must implement or extend every decorated type. If the delegate type does not implement or extend a decorated type of the decorator, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="ab">
      <text>If a decorated type is a parameterized type and the delegate type does not have exactly the same type parameters as the decorated type, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="b">
      <text>A decorator is not required to implement the delegate type.</text>
    </assertion>

    <assertion id="c">
      <text>A decorator may be an abstract Java class, and is not required to implement every method of every decorated type.</text>
    </assertion>

    <assertion id="d">
      <text>The decorator intercepts every method declared by a decorated type of the decorator, and that is implemented by the bean class of the decorator.</text>
    </assertion>
  </section>

  <section id="8.2" title="Decorator enablement and ordering">
    <assertion id="a">
    <text>By default, decorators are not enabled. A decorator must be explicitly enabled by listing its bean class under the |&lt;decorators&gt;| element in |beans.xml| file of the bean archive.</text>
    </assertion>

    <assertion id="b">
      <text>The order of the decorator declarations determines the decorator ordering. Decorators which occur earlier in the list are called first.</text>
    </assertion>
    
    <group>
      <text>Each child |&lt;class&gt;| element must specify the name of a decorator bean class.  If there is no class with the specified name, or if the class with the specified name is not a decorator bean class, the container automatically detects the problem and treats it as a deployment problem.</text>
      <assertion id="ba">
        <text>Test with a nonexistent class name.</text>
      </assertion>
    
      <assertion id="bb">
        <text>Test with a non-decorator class.</text>
      </assertion>
    </group>
    
    <assertion id="bc">
      <text>If the same class is listed twice under the |&lt;decorators&gt;| element, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

    <assertion id="f">
      <text>Decorators are called after interceptors.</text>
    </assertion>
  </section>

  <section id="8.3" title="Decorator resolution">
    <assertion id="aa">
      <text>The process of matching decorators to a certain bean is called decorator resolution.  A decorator is bound to a bean if the bean is assignable to the delegate injection point according to the rules defined in Section 5.2, "Typesafe resolution", and the decorator is enabled in the bean archive containing the bean.</text>
    </assertion>
    
    <assertion id="ab">
      <text>If a decorator matches a managed bean, and the managed bean class is declared final, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>
    
    <assertion id="ac">
      <text>If a decorator matches a managed bean with a non-static, non-private, final method, and the decorator also implements that method, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>
    
    <assertion id="b">
      <text>For a custom implementation of the |Decorator| interface defined in Section 11.1.1, "The Decorator interface", the container calls |getDelegateType()|, |getDelegateQualifiers()| and |getDecoratedTypes()| to determine the delegate type and qualifiers and decorated types of the decorator.</text>
    </assertion>
  </section>
  
  <section id="8.3.1" title="Assignability of raw and parameterized types for delegate injection points">
    <group>
      <text>A raw bean type is considered assignable to a parameterized delegate type if the raw types are identical and all type parameters of the delegate type are either unbounded type variables or |java.lang.Object|.</text>
      
      <assertion id="aa">
        <text>Check all type parameters are unbounded type variables</text>    
      </assertion>
      
      <assertion id="ab">
        <text>Check all type parameters are Object</text>    
      </assertion>
      
      <assertion id="ac">
        <text>Check mix</text>    
      </assertion>
    </group>
    
    <group>
      <text>A parameterized bean type is considered assignable to a parameterized delegate type if they have identical raw type and for each parameter: the delegate type parameter and the bean type parameter are actual types with identical raw type, and, if the type is parameterized, the bean type parameter is assignable to the delegate type parameter according to these rules, or the delegate type parameter is a wildcard, the bean type parameter is an actual type and the actual type is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or the delegate type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or the delegate type parameter and the bean type parameter are both type variables and the upper bound of the bean type parameter is assignable to the upper bound, if any, of the delegate type parameter, or the delegate type parameter is a type variable, the bean type parameter is an actual type, and the actual type is assignable to the upper bound, if any, of the type variable.</text>
      
      <assertion id="c">
        <text>Check both have identical type parameters</text>
      </assertion>
      
      <assertion id="d">
        <text>Check nested identical type parameters</text>
      </assertion>
      
      <assertion id="e">
        <text>Check delegate type parameter is a wildcard, the bean type parameter is an actual type and the actual type is assignable to the upper bound of the wildcard and assignable from the lower bound of the wildcard</text>
      </assertion>
      
      <assertion id="f">
        <text>Check delegate type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is assignable to the upper bound of the wildcard and assignable from the lower bound of the wildcard</text>
      </assertion>
      
      <assertion id="g">
        <text>Check the delegate type parameter and the bean type parameter are both type variables and the upper bound of the bean type parameter is assignable to the upper bound of the delegate type parameter</text>
      </assertion>
      
      <assertion id="h">
        <text>Check the delegate type parameter is a type variable, the bean type parameter is an actual type, and the actual type is as- signable to the upper bound of the type variable</text>
      </assertion>
    </group>


  </section>

  <section id="8.4" title="Decorator invocation">
    <assertion id="a">
      <text>Whenever a business method is invoked on an instance of a bean with decorators, the container intercepts the business method invocation and, after processing all interceptors of the method, invokes decorators of the bean. The container searches for the first decorator of the instance that implements the method that is being invoked as a business method.</text>
    </assertion>

    <assertion id="b">
      <text>If no such decorator exists, the container invokes the business method of the intercepted instance.</text>
    </assertion>

    <assertion id="c">
      <text>Otherwise, the container calls the method of the decorator.</text>
    </assertion>

    <assertion id="d">
      <text>When any decorator is invoked by the container, it may in turn invoke a method of the delegate. The container intercepts the delegate invocation and searches for the first decorator of the instance such that the decorator occurs after the decorator invoking the delegate, and the decorator implements the method that is being invoked upon the delegate.</text>
    </assertion>

    <assertion id="e">
      <text>If no such decorator exists, the container invokes the business method of the intercepted instance.</text>
    </assertion>

    <assertion id="f">
      <text>Otherwise, the container calls the method of the decorator.</text>
    </assertion>
  </section>

  <section id="9" title="Interceptor bindings">

  </section>

  <section id="9.1" title="Interceptor binding types">
    <assertion id="a">
      <text>An interceptor binding type is a Java annotation defined as |@Target({TYPE, METHOD})| or |@Target(TYPE)| and |@Retention(RUNTIME)|.</text>
    </assertion>

    <assertion id="b">
      <text>An interceptor binding type may be declared by specifying the |@javax.interceptor.InterceptorBinding| meta-annotation.</text>
    </assertion>

    <assertion id="c">
      <text>Multiple interceptors may be bound to the same interceptor binding type or types.</text>
    </assertion>
  </section>

  <section id="9.1.1" title="Interceptor binding types with additional interceptor bindings">
    <assertion id="a">
      <text>An interceptor binding type may declare other interceptor bindings.</text>
    </assertion>

    <assertion id="b">
      <text>Interceptor bindings are transitive - an interceptor binding declared by an interceptor binding type is inherited by all beans and other interceptor binding types that declare that interceptor binding type.</text>
    </assertion>

    <assertion id="c" testable="false">
      <text>Interceptor binding types declared |@Target(TYPE)| may not be applied to interceptor binding types declared |@Target({TYPE, METHOD})|.</text>
      <note>The behaviour here is undefined.</note>
    </assertion>
  </section>

  <section id="9.1.2" title="Interceptor bindings for stereotypes">
    <assertion id="a">
      <text>Interceptor bindings may be applied to a stereotype by annotating the stereotype annotation</text>
    </assertion>

    <assertion id="b">
      <text>An interceptor binding declared by a stereotype are inherited by any bean that declares that stereotype.</text>
    </assertion>

    <assertion id="c" testable="false">
      <text>If a stereotype declares interceptor bindings, it must be defined as |@Target(TYPE)|.</text>
      <note>The behaviour here is undefined.</note>
    </assertion>
  </section>

  <section id="9.2" title="Declaring the interceptor bindings of an interceptor">
    <assertion id="a">
      <text>The interceptor bindings of an interceptor are specified by annotating the interceptor class with the binding types and the |@javax.interceptor.Interceptor| annotation.</text>
    </assertion>
    
    <assertion id="ab">
      <text>An interceptor class may declare multiple interceptor bindings.</text>
    </assertion>

    <assertion id="b">
      <text>If an interceptor does not declare an |@Interceptor| annotation, it must be bound to beans using |@Interceptors| or |ejb-jar.xml|.</text>
    </assertion>

    <assertion id="c" testable="false">
      <text>All interceptors declared using |@Interceptor| must specify at least one interceptor binding. If an interceptor declared using |@Interceptor| does not declare any interceptor binding, non-portable behavior results.</text>
    </assertion>

    <assertion id="d">
      <text>An interceptor for lifecycle callbacks may only declare interceptor binding types that are defined as |@Target(TYPE)|. If an interceptor for lifecycle callbacks declares an interceptor binding type that is defined |@Target({TYPE, METHOD})|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="9.3" title="Binding an interceptor to a bean">
    <assertion id="a">
      <text>An interceptor binding may be declared by annotating the bean class, or a method of the bean class, with the interceptor binding type.</text>
    </assertion>
    
    <assertion id="b">
      <text>A bean class or method of a bean class may declare multiple interceptor bindings.</text>
    </assertion>
    
    <assertion id="c">
      <text>If the bean class of a managed bean declares or inherits a class level interceptor binding or a stereotype with interceptor bindings, it must not be declared final, or have any non-static, non-private, final methods.  If a managed bean has a class-level interceptor binding and is declared final or has a non-static, non-private, final method, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="d">
      <text>If a non-static, non-private method of a bean class of a managed bean declares a method level interceptor binding, neither the method nor the bean class may be declared final.  If a non-static, non-private, final method of a managed bean has a method level interceptor binding, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="9.4" title="Interceptor enablement and ordering">
    <assertion id="a">
      <text>By default, a bean deployment archive has no enabled interceptors bound via interceptor bindings. An interceptor must be explicitly enabled by listing its class under the |&lt;interceptors&gt;| element of the |beans.xml| file of the bean archive.</text>
    </assertion>

    <assertion id="b">
      <text>The order of the interceptor declarations determines the interceptor ordering. Interceptors which occur earlier in the list are
called first.</text>
    </assertion>

    <group>
      <text>Each child |&lt;class&gt;| element must specify the name of an interceptor class.  If there is no class with the specified name, or if the class with the specified name is not an interceptor class, the container automatically detects the problem and treats it as a deployment problem.</text>

      <assertion id="caa">
        <text>Test with a non-existant class.</text>
      </assertion>
      
      <assertion id="cab">
        <text>Test with a class that isn't an interceptor.</text>
      </assertion>
    </group>
    
    <assertion id="cb">
      <text>If the same class is listed twice under the |&lt;interceptors&gt;| element, the container automatically detects the problem and treats it as a deployment problem.</text>
    </assertion>

     <group>
        <text>Interceptors declared using |@Interceptors| or in |ejb-jar.xml| are called before interceptors declared
           using interceptor bindings.
        </text>

        <assertion id="fa">
           <text>Test with a managed bean</text>
        </assertion>

        <assertion id="fb">
           <text>Test with session bean</text>
        </assertion>
     </group>

    <assertion id="g">
      <text>Interceptors are called before decorators.</text>
    </assertion>
  </section>

  <section id="9.5" title="Interceptor resolution">
    <assertion id="a">
      <text>For a lifecycle callback method, the interceptor bindings include the interceptor bindings declared or inherited by the bean at the class level, including, recursively, interceptor bindings declared as meta-annotations of other interceptor bindings and stereotypes.
      </text>
    </assertion>

    <group>
      <text>For a business method, or EJB timeout method, the bean interceptor bindings include the interceptor bindings declared or inherited by the bean at the class level, including, recursively, interceptor bindings declared as meta-annotations of other interceptor bindings and stereotypes, together with all interceptor bindings declared at the method level, including, recursively, interceptor bindings declared as meta-annotations of other interceptor bindings.</text>
      <assertion id="ba">
         <text>Check a business method</text>
      </assertion>
      <assertion id="ba">
         <text>Check an EJB timeout method</text>
      </assertion>
    </group>
    
    <assertion id="ca">
      <text>An interceptor is bound to a method if the method has all the interceptor bindings of the interceptor.  A method has an interceptor binding of an interceptor if it has an interceptor binding with (a) the same type and (b) the same annotation member value for each member which is not annotated |@javax.enterprise.util.NonBinding|, and the interceptor intercepts the given kind of lifecycle callback or business method, and the interceptor is enabled in the bean archive containing the bean.</text>
    </assertion>
   
    <group>
      <text>For a custom implementation of the Interceptor interface defined in Section 11.1.2, "The Interceptor interface", the container calls |getInterceptorBindings()| to determine the interceptor bindings of the interceptor and |intercepts()| to determine if the interceptor intercepts a given kind of lifecycle callback, EJB timeout or business method.</text>
      <assertion id="fa">
         <text>Check for @PostConstruct</text>
      </assertion>
      <assertion id="fb">
         <text>Check for @PreDestroy</text>
      </assertion>
      <assertion id="fc">
         <text>Check for @PostActivate</text>
      </assertion>
      <assertion id="fd">
         <text>Check for @PrePassivate</text>
      </assertion>
      <assertion id="fe">
         <text>Check for @AroundInvoke</text>
      </assertion>
      <assertion id="ff">
         <text>Check for @AroundTimeout</text>
      </assertion>
    </group>
    
  </section>

  <section id="9.5.1" title="Interceptors with multiple bindings">
    <group>
      <text>An interceptor class may specify multiple interceptor bindings.</text>
      <assertion id="a">
        <text>Test that the interceptor is applied to a bean with all of the bindings.</text>
      </assertion>
      
      <assertion id="b">
        <text>Test that the interceptor it not applied to a bean with only some of the interceptor bindings.</text>
      </assertion>
    </group>
  </section>

  <section id="9.5.2" title="Interceptor binding types with members">
    <assertion id="a">
      <text>Interceptor binding types may have annotation members.</text>
    </assertion>
    
    <assertion id="ab">
      <text>Annotation member values are compared using |equals()|.</text>
    </assertion>

    <assertion id="b">
      <text>An annotation member may be excluded from consideration using the |@Nonbinding| annotation.</text>
    </assertion>

    <assertion id="ca" testable="false">
      <text>Array-valued or annotation-valued members of an interceptor binding type should be annotated |@Nonbinding| in a portable application. If an array-valued or annotation-valued member of an interceptor binding type is not annotated |@Nonbinding|, non-portable behavior results.</text>
    </assertion>
    
    <assertion id="d">
      <text>If the set of interceptor bindings of a bean or interceptor, including bindings inherited from stereotypes and other interceptor bindings, has two instances of a certain interceptor binding type and the instances have different values of some annotation member, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
  </section>

  <section id="10" title="Events">

  </section>

  <section id="10.1" title="Event types and qualifier types">

    <assertion id="aa">
      <text>An event object is an instance of a concrete Java class with no type variables.</text>
    </assertion>

    <assertion id="c">
      <text>The event types of the event include all superclasses and interfaces of the runtime class of the event object.</text>
    </assertion>
    
    <assertion id="cb" testable="false">
      <text>An event type may not contain a type variable.</text>
      <note>Doesn't specify an error condition</note>
    </assertion>

    <assertion id="d">
      <text>An event qualifier type is a Java annotation defined as |@Target({FIELD, PARAMETER})| ~or |@Target({METHOD, FIELD, PARAMETER, TYPE})| and |@Retention(RUNTIME)|~</text>
    </assertion>

    <assertion id="e">
      <text>An event qualifier type is a Java annotation defined as ~|@Target({FIELD, PARAMETER})| or~ |@Target({METHOD, FIELD, PARAMETER, TYPE})| ~and |@Retention(RUNTIME)|~</text>
    </assertion>

    <assertion id="f">
      <text>An event qualifier type is a Java annotation defined as ~|@Target({FIELD, PARAMETER})| or |@Target({METHOD, FIELD, PARAMETER, TYPE})| and ~|@Retention(RUNTIME)|</text>
    </assertion>

    <assertion id="g">
      <text>All event qualifier types must specify the |@javax.inject.Qualifier| meta-annotation</text>
    </assertion>

    <assertion id="i">
      <text>Every event has the qualifier |@javax.enterprise.inject.Any|, even if it does not explicitly declare this qualifier.</text>
    </assertion>
    
    <assertion id="j">
      <text>Any Java type may be an observed event type.</text>
    </assertion>
  </section>

  <section id="10.2" title="Observer resolution">   
    <assertion id="a" testable="false">
      <text>The process of matching an event to its observer methods is called observer resolution.  The container considers event type and qualifiers when resolving observers.</text>
      <note>Statement of intent</note>
    </assertion>
    
    <assertion id="b" testable="false">
      <text>Observer resolution usually occurs at runtime.</text>
      <note>Describes non-portable behavior</note>
    </assertion>
    
    <assertion id="i">
      <text>An event is delivered to an observer method if the observer method belongs to an enabled bean, the event object is assignable to the observed event type, taking type parameters into consideration, the observer method has all the event qualifiers.  An observer method has an event qualifier if it has an observed event qualifier with (a) the same type and (b) the same annotation member value for each member which is not annotated |@javax.enterprise.util.Nonbinding|.  Also the event is not a container lifecycle event, as defined in Section 11.5 "Container lifecycle events", or the observer method belongs to an extension.</text>
    </assertion>

    <assertion id="j">
      <text>If the runtime type of the event object contains a type variable, the container must throw an |IllegalArgumentException|.</text>
    </assertion>
    
    <assertion id="k">
      <text>For a custom implementation of the |ObserverMethod| interface defined in Section 11.1.3, "The ObserverMethod interface", the container must call |getObservedType()| and |getObservedQualifiers()| to determine the observed event type and qualifiers.</text>
    </assertion>
  </section>
  
  <section id="10.2.1" title="Assignability of type variables, raw and parameterized types">
    <assertion id="a">
      <text>An event type is considered assignable to a type variable if the event type is assignable to the upper bound, if any.</text>
    </assertion>
    
    <assertion id="b">
      <text>A parameterized event type is considered assignable to a raw observed event type if the raw types are identical.</text>
    </assertion>
    
    <assertion id="c">
      <text>A parameterized event type is considered assignable to a parameterized observed event type if they have identical raw type and for each parameter the observed event type parameter is an actual type with identical raw type to the event type parameter, and, if the type is parameterized, the event type parameter is assignable to the observed event type parameter according to these rules, or the observed event type parameter is a wildcard and the event type parameter is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or the observed event type parameter is a type variable and the event type parameter is assignable to the upper bound, if any, of the type variable.</text>
    </assertion>
  </section>

  <section id="10.2.2" title="Event qualifier types with members">
    <assertion id="a">
      <text>The qualifier type for an |Event| qualifier may have annotation members.</text>
    </assertion>

    <assertion id="b" testable="false">
      <text>The container uses |equals()| to compare event qualifier type member values.</text>
      <note>Since only primitive types are allowed, the call to equals() cannot be checked</note>
    </assertion>
  </section>

  <section id="10.2.3" title="Multiple event qualifiers">
    <assertion id="a">
      <text>An event parameter may have multiple qualifiers.</text>
    </assertion>

    <assertion id="b">
      <text>An observer method will only be notified if all the observed event qualifiers are specified when the event is fired.</text>
    </assertion>

    <assertion id="c">
      <text>Other, less specific, observers will also be notified of events with multiple event qualifiers.</text>
    </assertion>
  </section>

  <section id="10.3" title="Firing events">
    <assertion id="a">
      <text>Beans fire events via an instance of the |javax.enterprise.event.Event| interface, which may be injected.</text>
    </assertion>

    <assertion id="b">
      <text>The method |fire()| accepts an event object.</text>
    </assertion>

    <assertion id="c">
      <text>Any combination of qualifiers may be specified at the injection point.</text>
    </assertion>

    <assertion id="d">
      <text>Or, the |@Any| qualifier may be used, allowing the application to specify qualifiers dynamically.</text>
    </assertion>
  </section>

  <section id="10.3.1" title="The Event interface">
    <assertion id="ca">
      <text>The |Event| interface provides a method for firing events with a specified combination of type and qualifiers.</text>
    </assertion>
    
    <assertion id="cb">qualifiers
      <text>For an injected |Event|, the specified type is the type parameter specified at the injection point, and the specified qualifiers are the qualifiers specified at the injection point.</text>
    </assertion>

    <assertion id="eaa">
      <text>The |select()| method returns a child |Event| for a given specified type and additional specified qualifiers.  If no specified type is given, the specified type is the same as the parent.</text>
    </assertion>
    
    <assertion id="eab">
      <text>If the specified type contains a type variable, an |IllegalArgumentException| is thrown.</text>
    </assertion>

    <assertion id="eba">
      <text>If two instances of the same qualifier type are passed to |select()|, an |IllegalArgumentException| is thrown.</text>
    </assertion>

    <assertion id="ec">
      <text>If an instance of an annotation that is not a qualifier type is passed to |select()|, an |IllegalArgumentException| is thrown.</text>
    </assertion>

    <assertion id="eda">
      <text>The method |fire()| fires an event with the specified qualifiers and notifies observers, as defined by Section 10.5, "Observer notification".</text>
    </assertion>

    <assertion id="f">
      <text>If the runtime type of the event object contains a type variable, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>

  <section id="10.3.2" title="The built-in Event">
    <assertion id="a">
      <text>The container must provide a built-in bean with |Event&lt;X&gt;| in its set of bean types, for every Java type |x| that does not contain a type variable.</text>
    </assertion>

    <assertion id="b">
      <text>The container must provide a built-in bean with every event qualifier type in its set of qualifier types.</text>
    </assertion>

    <assertion id="d">
      <text>The container must provide a built-in bean with scope |@Dependent|.</text>
    </assertion>

    <assertion id="e">
      <text>The container must provide a built-in bean with no bean EL name.</text>
    </assertion>

    <assertion id="f">
      <text>The container must provide a built-in bean with an implementation provided automatically by the container.</text>
    </assertion>

    <assertion id="g">
      <text>The built-in implementation must be a passivation capable dependency, as defined in Section 6.6.2, "Passivation capable
dependencies".</text>
    </assertion>
  </section>

  <section id="10.4" title="Observer methods">
    <assertion id="a0" testable="false">
      <text>An observer method allows the application to receive and respond to event notifications.</text>
      <note>A general statement.</note>
    </assertion>
  
    <assertion id="aa">
      <text>An observer method is a non-abstract method of a managed bean class or session bean class (or of an extension, as defined in Section 11.5, "Container lifecycle events").</text>
    </assertion>
    
    <assertion id="c">
      <text>An observer method may be either static or non-static.</text>
    </assertion>

    <assertion id="d">
      <text>If the bean is a session bean, the observer method must be either a business method of the EJB or a static method of the bean class.</text>
    </assertion>

    <assertion id="e">
      <text>There may be arbitrarily many observer methods with the same event parameter type and qualifiers.</text>
    </assertion>

    <assertion id="f">
      <text>A bean (or extension) may declare multiple observer methods.</text>
    </assertion>
  </section>

  <section id="10.4.1" title="Event parameter of an observer method">
    <assertion id="a">
      <text>Each observer method must have exactly one event parameter, of the same type as the event type it observes.  When searching for observer methods for an event, the container considers the type and qualifiers of the event parameter</text>
    </assertion>

    <assertion id="b">
      <text>If the event parameter does not explicitly declare any qualifier, the observer method observes events with no qualifier.</text>
    </assertion>

    <group>
      <text>The event parameter type may contain a type variable or wildcard.</text>
      <assertion id="ca">
        <text>Test with a type variable.</text>
      </assertion>

      <assertion id="cb">
        <text>Test with a wildcard.</text>
      </assertion>
    </group>

  </section>

  <section id="10.4.2" title="Declaring an observer method">
    <assertion id="a">    <assertion id="ea">
      <text>For a Producer that represents a producer _method_ or field, |produce()| _calls the producer method on_, or accesses the producer field of, a contextual instance of the most specialized bean that specializes the bean that declares the producer method, as defined in Section 5.6.6, "Invocation of producer or disposer methods".</text>
    </assertion>
    
    <assertion id="eb">
      <text>For a Producer that represents a producer method or _field_, |produce()| calls the producer method on, _or accesses the producer field of_, a contextual instance of the most specialized bean that specializes the bean that declares the producer method, as defined in Section 5.6.6, "Invocation of producer or disposer methods".</text>
    </assertion>

      <text>An observer method may be declared by annotating a parameter |@javax.enterprise.event.Observes|. That parameter is the event parameter. The declared type of the parameter is the observed event type.</text>
    </assertion>

    <assertion id="b">
      <text>If a method has more than one parameter annotated |@Observes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="c">
      <text>Observed event qualifiers may be declared by annotating the event parameter.</text>
    </assertion>

    <assertion id="d">
      <text>If an observer method is annotated |@Produces| the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="e">
      <text>If an observer method is annotated |@Inject| the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="f">
      <text>If an observer method has a parameter annotated |@Disposes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="g">
      <text>If a non-static method of a session bean class has a parameter annotated |@Observes|, and the method is not a business method of the EJB, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="h">
      <text>Interceptors and decorators may not declare observer methods. If an interceptor or decorator has a method with a parameter annotated |@Observes|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>

    <assertion id="i">
      <text>In addition to the event parameter, observer methods may declare additional parameters, which may declare qualifiers. These additional parameters are injection points.</text>
    </assertion>
  </section>

  <section id="10.4.3" title="Conditional observer methods">
    <assertion id="a">
      <text>A conditional observer method may be declared by specifying |receive=IF_EXISTS|.</text>
    </assertion>
    
    <assertion id="b">
      <text>Beans with scope |@Dependent| may not have conditional observer methods. If a bean with scope |@Dependent| has an observer method declared |receive=IF_EXISTS|, the container automatically detects the problem and treats it as a definition error.</text>
    </assertion>
    
    <assertion id="c">
      <text>The enumeration |javax.enterprise.event.Reception| identifies the possible values of |receive|.</text>
    </assertion>
  </section>

  <section id="10.4.4" title="Transactional observer methods">
    <assertion id="a">
      <text>Transactional observer methods are observer methods which receive event notifications during the before or after completion phase of the transaction in which the event was fired. If no transaction is in progress when the event is fired, they are notified at the same time as other observers</text>
    </assertion>

    <assertion id="b">
      <text>A before completion observer method is called during the before completion phase of the transaction</text>
    </assertion>

    <assertion id="c">
      <text>An after completion observer method is called during the after completion phase of the transaction</text>
    </assertion>

    <assertion id="d">
      <text>An after success observer method is called during the after completion phase of the transaction, only when the transaction completes successfully</text>
    </assertion>

    <assertion id="e">
      <text>An after failure observer method is called during the after completion phase of the transaction, only when the transaction fails</text>
    </assertion>
    
    <assertion id="f" testable="false">
      <text>The enumeration |javax.enterprise.event.TransactionPhase| identifies the kind of transactional observer method.</text>
      <note>Should we just sigtest this?</note>
    </assertion>

    <assertion id="gaa">
    <text>A transactional observer method may be declared by specifying any value other than |IN_PROGRESS| for |during|.</text>
    </assertion>
  </section>

  <section id="10.5" title="Observer notification">
    <assertion id="aa">
      <text>When an event is fired by the application, the container must determine the observers for that event according to the observer resolution defined by Section 10.2, "Observer resolution", then then for each observer method, either invoke the observer method immediately or register the observer method for later invocation during the transaction completion phase, using a JTA |Synchronization|.</text>
    </assertion>

    <assertion id="ba">
      <text>The container calls observer methods as defined in Section 5.5.6, "Invocation of observer methods".</text>
    </assertion>
    
    <assertion id="bb">
      <text>If the observer method is a transactional observer method and there is currently a JTA transaction in progress, the container calls the observer method during the appropriate transaction completion phase.  ~Otherwise, the container calls the observer immediately.~</text>
    </assertion>
    
    <assertion id="bc">
      <text>If the observer method is a transactional observer method and there is currently a JTA transaction in progress, ~the container calls the observer method during the appropriate transaction completion phase.~  Otherwise, the container calls the observer immediately.</text>
    </assertion>
    
    <assertion id="bcb">
      <text>The order in which observer methods are called is not defined, and so portable applications should not rely upon the order in which observers are called.</text>
    </assertion>
    
    <assertion id="bd">
      <text>Any observer method called before completion of a transaction may call |setRollbackOnly()| to force a transaction rollback.</text>
    </assertion>
    
    <assertion id="bd" testable="false">
      <text>An observer method may not directly initiate, commit or rollback JTA transactions.</text>
      <note>Doesn't specify what happens if they do</note>
    </assertion>

    <assertion id="ca" testable="false">
      <text>Observers may throw exceptions. If an observer method is a transactional observer method, any exception is caught and logged by the container.</text>
      <note>We can't verify what is logged</note>
    </assertion>
    
    <assertion id="cb">
      <text>Observers may throw exceptions. If an observer method is a transactional observer method, ~any exception is caught and logged by the container.~  Otherwise, the exception aborts processing of the event.</text>
    </assertion>
    
    <assertion id="cc">
      <text>Observers may throw exceptions. ~If an observer method is a transactional observer method, any exception is caught and logged by the container.  Otherwise, the exception aborts processing of the event.  No other observer methods of that event will be called.~  The |BeanManager.fireEvent()| or |Event.fire()| method rethrows the exception.  ~If the exception is a checked exception, it is wrapped and rethrown as an (unchecked) |ObserverException|~.</text>
    </assertion>
    
    <assertion id="cd">
      <text>Observers may throw exceptions. ~If an observer method is a transactional observer method, any exception is caught and logged by the container.  Otherwise, the exception aborts processing of the event.  No other observer methods of that event will be called.  The |BeanManager.fireEvent()| or |Event.fire()| method rethrows the exception.~  If the exception is a checked exception, it is wrapped and rethrown as an (unchecked) |ObserverException|.</text>
    </assertion>

    <assertion id="f">
      <text>For a custom implementation of the |ObserverMethod| interface defined in Section 11.1.3, "The ObserverMethod interface", the container must call |getReception()| and |getTransactionPhase()| to determine if the observer method is a conditional or transactional observer method, and |notify()| to invoke the method.</text>
    </assertion>
  </section>

  <section id="10.5.1" title="Observer method invocation context">
    <assertion id="ba">
      <text>If the observer method is a before completion transactional observer method, it is called within the context of the transaction that is about to complete and with the same client security context and lifecycle contexts.</text>
    </assertion>

    <assertion id="c">
      <text>If the observer method is any other kind of transactional observer method, it is called in an unspecified transaction context, but with the same client security context and lifecycle contexts as the transaction that just completed.</text>
    </assertion>

    <assertion id="da">
      <text>If an observer method is not a before completion transactional method, and not any other kind of transactional observer method, then the observer method is called in the same transaction context, client security context and lifecycle contexts as the invocation of |Event.fire()| or |BeanManager.fireEvent()|.</text>
    </assertion>

    <assertion id="e">
      <text>The transaction and security contexts for a business method of a session bean also depend upon the transaction attribute and |@RunAs| descriptor, if any.</text>
    </assertion>
  </section>

  <section id="11" title="Portable extensions">
    <assertion id="a" testable="false">
    <text>A portable extension may integrate with the container by providing its own beans, interceptors and decorators to the container.</text>
    </assertion>

    <assertion id="b" testable="false">
      <text>A portable extension may integrate with the container by injecting dependencies into its own objects using the dependency injection service.</text>
    </assertion>

    <assertion id="c" testable="false">
      <text>A portable extension may integrate with the container by providing a context implementation for a custom scope.</text>
    </assertion>

    <assertion id="f" testable="false">
      <text>Augmenting or overriding the annotation-based metadata with metadata from some other source.</text>
    </assertion>
  </section>

  <section id="11.1" title="The Bean interface">
    <assertion id="aa">
      <text>Implementations of |Bean| must also implement the inherited operations defined by the |Contextual| interface defined in Section 6.1, "The Contextual interface".</text>
    </assertion>

    <assertion id="ba">
      <text>|getTypes()|, |getQualifiers()|, |getScope()|, |getName()| and |getStereotypes()| must return the bean types, qualifiers, scope type, EL name and stereotypes of the bean, as defined in Chapter 2, Concepts.</text>
    </assertion>
    
    <assertion id="bb">
      <text>|getBeanClass()| returns the bean class of the managed bean or session bean or of the bean that declares the producer method or field.</text>
    </assertion>
    
    <assertion id="bc">
      <text>|isAlternative()| must return |true| if the bean is an alternative, and |false| otherwise.</text>
    </assertion>

    <assertion id="bd">
      <text>|isNullable()| must return |true| if the method |create()| sometimes returns a |null| value, and |false| otherwise, as defined in Section 5.2.4, "Primitive types and null values".</text>
    </assertion>

    <assertion id="c">
      <text>|getInjectionPoints()| returns a set of |InjectionPoint| objects, defined in Section 5.5.7, "Injection point metadata", representing injection points of the bean, that will be validated by the container at initialization time.</text>
    </assertion>
    
    <assertion id="f">
      <text>An instance of |Bean| exists for every enabled bean.</text>
    </assertion>

    <assertion id="g" testable="false">
      <text>A portable extension may add support for new kinds of beans beyond those defined by the this specification (managed beans, session beans, producer methods, producer fields and resources) by implementing |Bean| and registering beans with the container, using the mechanism defined in Section 11.5.2, "AfterBeanDiscovery event".</text>
    </assertion>
  </section>

  <section id="11.1.1" title="The Decorator interface">
    <assertion id="a">
      <text>The |Bean| object for a decorator must implement the interface |javax.enterprise.inject.spi.Decorator|.</text>
    </assertion>

    <assertion id="b">
      <text>|getDecoratedTypes()| returns the decorated types of the decorator.</text>
    </assertion>

    <assertion id="c">
      <text>|getDelegateType()| and |getDelegateQualifiers()| return the delegate type and qualifiers of the decorator.</text>
    </assertion>
    
    <assertion id="d">
      <text>An instance of |Decorator| exists for every enabled decorator.</text>
    </assertion>
  </section>

  <section id="11.1.2" title="The Interceptor interface">
    <assertion id="a">
      <text>The |Bean| object for an interceptor must implement |javax.enterprise.inject.spi.Interceptor|.</text>
    </assertion>

    <assertion id="b">
      <text>|getInterceptorBindings()| returns the interceptor bindings of the interceptor.</text>
    </assertion>

    <assertion id="c">
      <text>|intercepts()| returns |true| if the interceptor intercepts the specified kind of lifecycle callback or method invocation, and |false| otherwise.</text>
    </assertion>

    <assertion id="d">
      <text>|intercept()| invokes the specified kind of lifecycle callback or method invocation interception upon the given instance of the interceptor.</text>
    </assertion>

    <assertion id="e">
      <text>An |InterceptionType| identifies the kind of lifecycle callback, EJB timeout method or business method.</text>
    </assertion>
    
    <assertion id="f">
      <text>An instance of |Interceptor| exists for every enabled interceptor.</text>
    </assertion>
  </section>
  
  <section id="11.1.3" title="The ObserverMethod interface">
    <assertion id="a" testable="false">
      <text>The interface |javax.enterprise.inject.spi.ObserverMethod| defines everything the container needs to know about an observer method.</text>
    </assertion>
    
    <assertion id="b">
      <text>|getBeanClass()| returns the bean class of the bean that declares the observer method.</text>
    </assertion>
    
    <assertion id="c">
      <text>|getObservedType()| and |getObservedQualifiers()| return the observed event type and qualifiers.</text>
    </assertion>
    
    <assertion id="d">
      <text>|getReception()| returns |IF_EXISTS| for a conditional observer and |ALWAYS| otherwise.</text>
    </assertion>
    
    <assertion id="e">
      <text>|getTransactionPhase()| returns the appropriate transaction phase for a transactional observer method or |IN_PROGRESS| otherwise.</text>
    </assertion>
    
    <assertion id="f">
      <text>|notify()| calls the observer method, as defined in Section 5.5.6 "Invocation of observer methods".</text>
    </assertion>
    
    <assertion id="ga">
      <text>An instance of |ObserverMethod| exists for every observer method of every enabled bean.</text>
    </assertion>
  </section>
  
  <section id="11.2" title="The Producer and InjectionTarget interfaces">
    <assertion id="a" testable="false">
      <text>The interface |javax.enterprise.inject.spi.Producer| provides a generic operation for producing an instance of a type.</text>
      <note>Statement of intent</note>
    </assertion>

    <group>
      <text>For a |Producer| that represents a class, |produce()| calls the constructor annotated |@Inject| if it exists, or the constructor with no parameters otherwise, as defined in Section 5.5.1, "Injection using the bean constructor". and returns the resulting instance. If the class has interceptors, |produce()| is responsible for building the interceptors and decorators of the instance.</text>
      <assertion id="ba">
         <text>Test field injection occurs</text>
      </assertion>
      <assertion id="bb">
         <text>Test initializer methods called</text>
      </assertion>
      <assertion id="bc">
         <text>Test constructor injected</text>
      </assertion>
      <assertion id="bd">
         <text>Test decorator stack built</text>
      </assertion>
      <assertion id="be">
         <text>Test interceptor stack built</text>
      </assertion>
    </group>
    
        
    <assertion id="c">
      <text>For a |Producer| that represents a class, |dispose()| does nothing.</text>
    </assertion>
    
    <group>
      <text>For a |Producer| that represents a class, |getInjectionPoints()| returns a set of |InjectionPoint| objects representing all injected fields, bean constructor parameters and initializer method parameters.</text>
            
      <assertion id="da">
        <text>Test injected fields.</text>
      </assertion>
      
      <assertion id="db">
        <text>Test bean constructor parameters.</text>
      </assertion>
      
      <assertion id="dc">
        <text>Test initializer method parameters.</text>
      </assertion>
    </group>
    
    <group>
      <text>For a |Producer| that represents a producer method or field, |produce()| calls the producer method on, or accesses the producer field of, a contextual instance of the bean that declares the producer method, as defined in Section 5.5.4, "Invocation of producer or disposer methods".</text>

      <assertion id="eaa">
        <text>Test with producer method.</text>
      </assertion>
      
      <assertion id="eba">
        <text>Test with producer field.</text>
      </assertion>            
    </group>
    
    <group>
      <text>For a Producer that represents a producer method or field, |dispose()| calls the disposer method, if any, on a contextual instance of the bean that declares the disposer method, as defined in Section 5.5.4, "Invocation of producer or disposer methods", or performs any additional required cleanup, if any, to destroy state associated with a resource.</text>
          
      <assertion id="faa">
        <text>Test with producer method.</text>
      </assertion>
      
    </group>
    
    <assertion id="g">
      <text>For a Producer that represents a producer method, |getInjectionPoints()| returns the set of |InjectionPoint| objects representing all parameters of the producer method.</text>
    </assertion>
    
    <assertion id="h" testable="false">
      <text>The subinterface |javax.enterprise.inject.spi.InjectionTarget| provides operations for performing dependency injection and lifecycle callbacks on an instance of a type.</text>
      <note>Statement of intent</note>
    </assertion>
    
    <assertion id="i">
      <text>|inject()| performs dependency injection upon the given object. The container performs Java EE component environment injection, according to the semantics required by the Java EE platform specification, sets the value of all injected fields, and calls all initializer methods, as defined in Section 5.5.2, "Injection of fields and initializer methods".</text>
    </assertion>
    
    <assertion id="j">
      <text>|postConstruct()| calls the |@PostConstruct| callback, if it exists, according to the semantics required by the Java EE platform specification.</text>
    </assertion>
    
    <assertion id="k">
      <text>|preDestroy()| calls the |@PreDestroy| callback, if it exists, according to the semantics required by the Java EE platform specification.</text>
    </assertion>
  </section>

  <section id="11.3" title="The BeanManager object">
    <group>
      <text>The container provides a built-in bean with bean type |BeanManager|, scope |@Dependent| and qualifier |@Default|.</text>
      
      <assertion id="aa">
        <text>Test the bean type.</text>
      </assertion>

      <assertion id="ab">
        <text>Test the scope.</text>
      </assertion>

      <assertion id="ac">
        <text>Test the qualifier.</text>
      </assertion>
    </group>

    <assertion id="b">
      <text>The built-in implementation must be a passivation capable dependency, as defined in Section 6.6.2, "Passivation capable dependencies".</text>
    </assertion>

    <assertion id="c">
      <text>Any bean may obtain an instance of |BeanManager| by injecting it.</text>
    </assertion>

    <assertion id="da">
      <text>Java EE components may obtain an instance of |BeanManager| from JNDI by looking up the name |java:comp/BeanManager|.</text>
    </assertion>    

    <assertion id="e">
      <text>Any operation of |BeanManager| may be called at any time during the execution of the application.</text>
      <note>This does not appear to be testable</note>
    </assertion>
  </section>

  <section id="11.3.1" title="Obtaining a contextual reference for a bean">
    <assertion id="a">
      <text>The method |BeanManager.getReference()| returns a contextual reference for a given bean and bean type, as defined in Section 6.5.3, "Contextual reference for a bean".</text>
    </assertion>

    <assertion id="b">
      <text>The first parameter is the |Bean| object representing the bean. The second parameter represents the bean type that must be implemented by any client proxy that is returned.  The third parameter is an instance of |CreationalContext| that may be used to destroy any object with scope |@Dependent| that is created.</text>
    </assertion>
    
    <assertion id="c">
      <text>If the given type is not a bean type of the given bean, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>

  <section id="11.3.2" title="Obtaining an injectable reference">
    <assertion id="a">
      <text>The method |BeanManager.getInjectableReference()| returns an injectable reference for a given injection point, as defined in Section 6.5.5, "Injectable references".</text>
    </assertion>
    
    <assertion id="ab">
      <text>The first parameter represents the target injection point.  The second parameter is an instance of |CreationalContext| that may be used to destroy any object with scope |@Dependent| that is created.</text>
    </assertion>
    
    <assertion id="b">
      <text>If the |InjectionPoint| represents a decorator delegate injection point, |getInjectableReference()| returns a delegate, as defined in Section 8.1.2, "Decorator delegate injection points".</text>
    </assertion>
    
    <assertion id="bb">
      <text>If typesafe resolution results in an unsatisfied dependency, the container must throw an |UnsatisfiedResolutionException|.</text>
    </assertion>
    
    <assertion id="bc">
      <text>If typesafe resolution results in an unresolvable ambiguous dependency, the container must throw an |AmbiguousResolutionException|.</text>
    </assertion>

    <assertion id="c">
      <text>Implementations of |Bean| usually maintain a reference to an instance of |BeanManager|. When the |Bean| implementation performs dependency injection, it must obtain the contextual instances to inject by calling |BeanManager.getInjectableReference()|, passing an instance of  |InjectionPoint| that represents the injection point and the instance of |CreationalContext| that was passed to |Bean.create()|.</text>
      <note>This cannot be well tested at the moment.</note>
    </assertion>
  </section>
  
  <section id="11.3.3" title="Obtaining a CreationalContext">
    <assertion id="a">
      <text>An instance of |CreationalContext| for a certain instance of |Contextual| may be obtained by calling |BeanManager.createCreationalContext()|.</text>
    </assertion>
    
    <assertion id="b">
      <text>An instance of |CreationalContext| for a non-contextual object may be obtained by passing a null value to |createCreationalContext()|.</text>
    </assertion>
  </section>

  <section id="11.3.4" title="Obtaining a Bean by type">
    <assertion id="aa">
      <text>The method |BeanManager.getBeans()| returns the set of beans which have the given required type and qualifiers and are available for injection in the module or library containing the class into which the |BeanManager| was injected or the Java EE component from whose JNDI environment namespace the |BeanManager| was obtained, according to the rules of typesafe resolution defined in Section 5.2, "Typesafe resolution".</text>
    </assertion>

    <assertion id="b">
      <text>The first parameter is a required bean type. The remaining parameters are required qualifiers.</text>
    </assertion>

    <assertion id="c">
      <text>If no qualifiers are passed to |getBeans()|, the default qualifier |@Default| is assumed.</text>
    </assertion>

    <assertion id="da">
      <text>If the given type represents a type variable, an |IllegalArgumentException| is thrown.</text>
    </assertion>

    <assertion id="e">
      <text>If two instances of the same qualifier type are given, an |IllegalArgumentException| is thrown.</text>
    </assertion>

    <assertion id="f">
      <text>If an instance of an annotation that is not a qualifier type is given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>

  <section id="11.3.5" title="Obtaining a Bean by name">
    <assertion id="aa">
      <text>The method |BeanManager.getBeans()| which accepts a string returns the set of beans which have the given EL name and are available for injection in the module or library containing the class into which the |BeanManager| was injected or the Java EE component from whose JNDI environment namespace the |BeanManager| was obtained, according to the rules of EL name resolution defined in Section 5.3, "EL name resolution".</text>
    </assertion>

    <assertion id="b">
      <text>The parameter is an EL name.</text>
    </assertion>
  </section>
  
  <section id="11.3.6" title="Obtaining a passivation capable bean by identifier">
    <assertion id="a">
      <text>The method |BeanManager.getPassivationCapableBean()| returns the |PassivationCapable| bean with the given identifier (see Section 6.6.1, "Passivation capable beans").</text>
    </assertion>
  </section>
  
  <section id="11.3.7" title="Resolving an ambiguous dependency">
    <assertion id="a">
      <text>The method |BeanManager.resolve()| applies the ambiguous dependency resolution rules defined in Section 5.2.1, "Unsatisfied and ambiguous dependencies" to a set of |Bean|s.</text>
    </assertion>
    
    <assertion id="b">
      <text>If the ambiguous dependency resolution rules fail, the container must throw an |AmbiguousResolutionException|.</text>
    </assertion>
  </section>
  
  <section id="11.3.8" title="Validating an injection point">
    <assertion id="a">
      <text>The |BeanManager.validate()| operation validates an injection point and throws an |InjectionException| if there is a deployment problem (for example, an unsatisfied or unresolvable ambiguous dependency) associated with the injection point.</text>
      <note>Statement of intent</note>
    </assertion>

    <assertion id="a">
      <text>The method |validate()| validates the dependency and throws an |InjectionException| if there is a deployment problem (for example, an unsatisfied or unresolvable ambiguous dependency) associated with the injection point.</text>
    </assertion>
  </section>
  
  <section id="11.3.9" title="Firing an event">
    <assertion id="a">
      <text>The method |BeanManager.fireEvent()| fires an event and notifies observers, according to Section 10.5, "Observer notification".</text>
    </assertion>
    
    <assertion id="b">
      <text>The first argument is the event object.  The remaining parameters are event qualifiers.</text>
    </assertion>
    
    <assertion id="c">
      <text>If the runtime type of the event object contains a type variable, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="d">
      <text>If two instances of the same qualifier type are given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="e">
      <text>If an instance of an annotation that is not a qualifier type is given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
        
  </section>
  
  <section id="11.3.10" title="Observer method resolution">
    <assertion id="a">
      <text>The method |BeanManager.resolveObserverMethods()| resolves observer methods for an event according to the rules of observer resolution defined in Section 10.2, "Observer resolution".</text>
    </assertion>

    <assertion id="b">
      <text>The first parameter of |resolveObserverMethods()| is the event object. The remaining parameters are event qualifiers.</text>
    </assertion>
    
    <assertion id="c">
      <text>If the runtime type of the event object contains a type variable, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="d">
      <text>If two instances of the same qualifier type are given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="e">
      <text>If an instance of an annotation that is not a qualifier type is given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>
  
  <section id="11.3.11" title="Decorator resolution">
    <assertion id="a">
      <text>The method |BeanManager.resolveDecorators()| returns the ordered list of decorators for a set of bean types and a set of qualifiers which are enabled in the module or library containing the class into which the |BeanManager| was injected or the Java EE component from whose JNDI environment namespace the |BeanManager| was obtained, as defined in Section 8.3, "Decorator resolution".</text>
    </assertion>
    
    <assertion id="b">
      <text>The first argument is the set of bean types of the decorated bean. The annotations are qualifiers declared by the decorated bean.</text>
    </assertion>
    
    <assertion id="c">
      <text>If two instances of the same qualifier type are given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="d">
      <text>If an instance of an annotation that is not a qualifier type is given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="e">
      <text>If the set of bean types is empty, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>
  
  <section id="11.3.12" title="Interceptor resolution">
    <assertion id="a">
      <text>The method |BeanManager.resolveInterceptors()| returns the ordered list of interceptors for a set of interceptor bindings and a type of interception which are enabled in the module or library containing the class into which the |BeanManager| was injected or the Java EE component from whose JNDI environment namespace the |BeanManager| was obtained, as defined in Section 9.5, "Interceptor resolution".</text>
    </assertion>
    
    <assertion id="b">
      <text>If two instances of the same interceptor binding type are given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="c">
      <text>If no interceptor binding type instance is given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
    
    <assertion id="d">
      <text>If an instance of an annotation that is not an interceptor binding type is given, an |IllegalArgumentException| is thrown.</text>
    </assertion>
  </section>
  
  <section id="11.3.13" title="Determining if an annotation is a qualifier type, scope type, stereotype or interceptor binding type">
    <group>
      <text>A portable extension may test an annotation to determine if it is a qualifier type, scope type, stereotype or interceptor binding type, obtain the set of meta-annotations declared by a stereotype or interceptor binding type, or determine if a scope type is a normal or passivating scope.</text>

      <assertion id="aa">
        <text>Test qualifier type.</text>
      </assertion>

      <assertion id="ab">
        <text>Test scope type.</text>
      </assertion>

      <assertion id="ac">
        <text>Test stereotype.</text>
      </assertion>

      <assertion id="ad">
        <text>Test interceptor binding type.</text>
      </assertion>

      <assertion id="ae">
        <text>Test meta-annotations for stereotype.</text>
      </assertion>

      <assertion id="af">
        <text>Test meta-annotations for interceptor binding type.</text>
      </assertion>

      <assertion id="ag">
        <text>Test obtaining a |ScopeType|.</text>
      </assertion>
    </group>
  </section>
  
  <section id="11.3.14" title="Obtaining the active Context for a scope">
    <assertion id="a">
      <text>The method |BeanManager.getContext()| retrieves an active context object associated with the a given scope, as defined in Section 6.5.1, "The active context object for a scope".</text>
    </assertion>
  </section>
  
  <section id="11.3.15" title="Obtaining the ELResolver">
    <assertion id="a">
      <text>The method |BeanManager.getELResolver()| returns the |javax.el.ELResolver| specified in Section 12.4, "Integration with Unified EL".</text>
    </assertion>
  </section>
  
  <section id="11.3.16" title="Wrapping a Unified EL ExpressionFactory">
    <assertion id="a">
      <text>The method |BeanManager.wrapExpressionFactory()| returns a wrapper |javax.el.ExpressionFactory| that delegates |MethodExpression| and |ValueExpression| creation to the given |ExpressionFactory|.</text>
    </assertion>
    
    <assertion id="b">
      <text>When a Unified EL expression is evaluated using a |MethodExpression| or |ValueExpression| returned by the wrapper |ExpressionFactory|, the rules defined in Section 6.4.3, "Dependent pseudo-scope and Unified EL" are enforced by the container.</text>
    </assertion>
  </section>
  
  <section id="11.3.17" title="Obtaining an AnnotatedType for a class">
    <assertion id="a">
      <text>The method |BeanManager.createAnnotatedType()| returns an |AnnotatedType| that may be used to read the annotations of a given Java class or interface.</text>
    </assertion>
  </section>
  
  <section id="11.3.18" title="Obtaining an InjectionTarget">
    
    <group>
      <text>The method |BeanManager.createInjectionTarget()| returns a container provided implementation of |InjectionTarget| for a given |AnnotatedType| or throws an |IllegalArgumentException| if there is a definition error associated with any injection point of the type.</text>
      <assertion id="aa">
         <text>Check |InjectionTarget| is provided.</text>
      </assertion>

      <assertion id="ab">
        <text>Check |IllegalArgumentException| is thrown.</text>
      </assertion>
    </group>
    
  </section>

  <section id="11.4" title="Alternative metadata sources">
    <assertion id="a" testable="false">
      <text>The interfaces |AnnotatedType|, |AnnotatedField|, |AnnotatedMethod|, |AnnotatedConstructor| and |AnnotatedParameter| in the package |javax.enterprise.inject.spi| allow a portable extension to specify metadata that overrides the annotations that exist on a bean class. The portable extension is responsible for implementing the interfaces, thereby exposing the metadata to the container.</text>
      <note>Statement of intent</note>
    </assertion>

    <assertion id="b" testable="false">
      <text>The interface |javax.enterprise.inject.spi.Annotated| exposes the overriding annotations and type declarations.</text>
      <note>Statement of intent</note>
    </assertion>
    
    <assertion id="c">
      <text>|getBaseType()| returns the type of the program element.</text>
    </assertion>
    
    <assertion id="d">
      <text>|getTypeClosure()| returns all types to which the base type should be considered assignable.</text>
    </assertion>
    
    <assertion id="e">
      <text>|getAnnotation()| returns the program element annotation of the given annotation type, or a null value.</text>
    </assertion>
    
    <assertion id="f">
      <text>|getAnnotations()| returns all annotations of the program element.</text>
    </assertion>
    
    <assertion id="g">
      <text>|isAnnotationPresent()| returns |true| if the program element has an annotation of the given annotation type, or |false| otherwise.</text>
    </assertion>
    
    <group> 
      <text>The container must use the operations of |Annotated| and its subinterfaces to discover program element types and annotations, instead of directly calling the Java Reflection API. In particular, the container must call |Annotated.getBaseType()| to determine the type of an injection point, event parameter or disposed parameter, call |Annotated.getTypeClosure()| to determine the bean types of any kind of bean, call |Annotated.getAnnotations()| to determine the scope, qualifiers, stereotypes and interceptor bindings of a bean, call |Annotated.isAnnotationPresent()| and |Annotated.getAnnotation()| to read any bean annotations defined by this specification, and call |AnnotatedType.getConstructors()|, |AnnotatedType.getMethods()| and |AnnotatedType.getFields()| to determine the members of a bean class.</text>
      
      <assertion id="ha">
         <text>Check that |getBaseType()| is used to determine the type of _a field injection point_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="hb">
         <text>Check that |getBaseType()| is used to determine the type of _an initializer method injection point_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="hc">
         <text>Check that |getBaseType()| is used to determine the type of _a constructor injection point_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="hd">
         <text>Check that |getBaseType()| is used to determine the type of _a producer method injection point_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="he">
         <text>Check that |getBaseType()| is used to determine the type of _a observer method injection point_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="hf">
         <text>Check that |getBaseType()| is used to determine the type of _a disposer method injection point_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="i">
         <text>Check that |getBaseType()| is used to determine the type of _an event parameter_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="j">
         <text>Check that |getBaseType()| is used to determine the type of _disposed parameter_. The base type should be different from the orignal type specified in the class definition</text>
      </assertion>
      
      <assertion id="ka">
         <text>Check that a |getTypeClosure()| is used to determine the bean types for a managed bean. The type closure should be different from the orignal type specified in the class definition.</text>
      </assertion>
      
      <assertion id="kb">
         <text>Check that a |getTypeClosure()| is used to determine the bean types for a session bean. The type closure should be different from the orignal type specified in the class definition.</text>
      </assertion>
      
      <assertion id="kc">
         <text>Check that a |getTypeClosure()| is used to determine the bean types for a producer field. The type closure should be different from the orignal type specified in the class definition.</text>
      </assertion>
      
      <assertion id="kd">
         <text>Check that a |getTypeClosure()| is used to determine the bean types for a producer method. The type closure should be different from the orignal type specified in the class definition.</text>
      </assertion>

      <assertion id="l">
         <text>Check that |getAnnotations()| is used to determine the bean scope. The annotations should be different from the orignal type specified in the class definition.</text>
      </assertion>

      <assertion id="m">
         <text>Check that |getAnnotations()| is used to determine the bean qualifiers. The annotations should be different from the orignal type specified in the class definition.</text>
      </assertion>

      <assertion id="n">
         <text>Check that |getAnnotations()| is used to determine the bean stereotypes. The annotations should be different from the orignal type specified in the class definition.</text>
      </assertion>

      <assertion id="p">
         <text>Check that |getAnnotations()| is used to determine the bean interceptors. The annotations should be different from the orignal type specified in the class definition.</text>
      </assertion>
      
      <assertion id="q" testable="false">
         <text>Check that |isAnnotationPresent()| returns the provided annotations</text>
         <note>No testable behavior</note>
      </assertion>
      
      <assertion id="r">
         <text>Check that a previously non-inject-annotated constructor is used by the container to instantiate a bean.</text>
      </assertion>
      
      <assertion id="s">
         <text>Check that a qualifier added to a parameter is used by the container to instantiate a bean.</text>
      </assertion>
      
      <assertion id="t">
         <text>Check that a previously non-inject-annotated field is injected.</text>
      </assertion>
      
      <assertion id="u">
         <text>Check that an extra qualifier is applied.</text>
      </assertion>
      
      <assertion id="v">
         <text>Check that |@Produces| added creates a producer field.</text>
      </assertion>
      
      <assertion id="w">
         <text>Check that a previously non-inject-annotated method is injected.</text>
      </assertion>
      
      <assertion id="x">
         <text>Check that an extra qualifier is applied to an injectable method</text>
      </assertion>
      
      <assertion id="y">
         <text>Check that |@Produces| added creates a producer method</text>
      </assertion>
      
      <assertion id="z">
         <text>Check that an extra qualifier is applied to a producer method.</text>
      </assertion>
      
      <assertion id="aa">
         <text>Check that a qualifer added to a producer method parameter is applied.</text>
      </assertion>
      
      <assertion id="ab">
         <text>Check that |@Disposes| added to a parameter creates a disposes method</text>
      </assertion>
      
      <assertion id="ac">
         <text>Check that an extra qualifier is applied to a disposes method parameter.</text>
      </assertion>
      
      <assertion id="ad">
         <text>Check that a qualifer added to a disposes method injectable parameter is applied.</text>
      </assertion>
      
      <assertion id="ae">
         <text>Check that |@Observes| added to a parameter creates a observer method</text>
      </assertion>
      
      <assertion id="af">
         <text>Check that an extra qualifier is applied to an observes method parameter.</text>
      </assertion>
      
      <assertion id="ag">
         <text>Check that a qualifer added to a observes method injectable parameter is applied.</text>
      </assertion>
      
    </group>
  </section>

  <section id="11.5" title="Container lifecycle events">
    <assertion id="a" testable="false">
      <text>During the application initialization process, the container fires a series of events, allowing portable extensions to integrate with the container initialization process defined in Section 12.2, "Application initialization lifecycle".</text>
      <note>Generic statement</note>
    </assertion>

    <assertion id="b">
      <text>Observer methods of these events must belong to extensions.  An extension is a service provider of the service |javax.enterprise.inject.spi.Extension| declared in |META-INF/services|.</text>
    </assertion>
    
    <assertion id="bb">
      <text>Service providers may have observer methods, which may observer any event, including any container lifecycle event, and obtain an injected |BeanManager| reference.</text>
    </assertion>
       
    <assertion id="d">
      <text>The container instantiates a single instance of each extension at the beginning of the application initialization process and maintains a reference to it until the application shuts down.  The container delivers event notifications to this instance by calling its observer methods.</text>
    </assertion>
    
    <assertion id="e">
      <text>For each service provider, the container must provide a bean of scope |@ApplicationScoped| and qualifier |@Default|, supporting injection of a reference to the service provider instance. The bean types of this bean include the class of the service provider and all superclases and interfaces.</text>
    </assertion>
  </section>

  <section id="11.5.1" title="BeforeBeanDiscovery event">
    <assertion id="a">
      <text>The container must fire an event before it begins the bean discovery process. The event object must be of type |javax.enterprise.inject.spi.BeforeBeanDiscovery|.</text>
    </assertion>
    
    <assertion id="ab">
      <text>|addQualifier()| declares an annotation type as a qualifier type.</text>
    </assertion>
    
    <assertion id="ac">
      <text>|addScope()| declares an annotation type as a scope type.</text>
    </assertion>
    
    <assertion id="ad">
      <text>|addStereotype()| declares an annotation type as a stereotype, and specifies its meta-annotations.</text>
    </assertion>
    
    <assertion id="ae">
      <text>|addInterceptorBinding()| declares an annotation type as an interceptor binding type, and specifies its meta-annotations.</text>
    </assertion>
    
    <assertion id="af">
      <text>|addAnnotatedType()| adds a given |AnnotatedType| to the set of types which will be scanned during bean discovery.</text>
    </assertion>

    <assertion id="ag">
      <text>If any observer method of the |BeforeBeanDiscovery| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
  </section>

  <section id="11.5.2" title="AfterBeanDiscovery event">
    <assertion id="a">
      <text>The container must fire a second event when it has fully completed the bean discovery process, validated that there are no definition errors relating to the discovered beans, and registered |Bean| and |ObserverMethod| objects for the discovered beans, but before detecting deployment problems.  The event object must be of type |javax.enterprise.inject.spi.AfterBeanDiscovery|.</text>
    </assertion>
    
    <assertion id="ca">
      <text>|addDefinitionError()| registers a definition error with the container, causing the container to abort deployment after all observers have been notified.</text>
    </assertion>

   <group>
      <text>|addBean()| fires an event of type |ProcessBean| containing the given |Bean| and then registers the |Bean| with the container, thereby making it available for injection into other beans. The given |Bean| may implement |Interceptor| or |Decorator|.</text>
      
      <assertion id="da">
         <text>Check that |ProcessBean| is fired</text>
      </assertion>
      
      <assertion id="db">
         <text>Check that a bean is registered</text>
      </assertion>
      
      <assertion id="dc">
         <text>Check that a decorator is registered</text>
      </assertion>
      
      <assertion id="dd">
         <text>Check that an interceptor is registered</text>
      </assertion>
    </group>
    
    <group>
      <text>|addObserverMethod()| fires an event of type |ProcessObserverMethod| containing the given |ObserverMethod| and then registers the |ObserverMethod| with the container, thereby making it available for event notifications.</text>
      <assertion id="ea">
        <text>Check that the |ProcessObserverMethod| is fired</text>
      </assertion>
      <assertion id="eb">
        <text>Check that the observer method is registered</text>
      </assertion>
    </group>
    
    <assertion id="f">
      <text>|addContext()| registers a custom |Context| object with the container.</text>
    </assertion>
    
    <assertion id="fb">
      <text>A portable extension may take advantage of this event to register beans, interceptors, decorators, observer methods and custom context objects with the container.</text>
    </assertion>
    
    <assertion id="g">
      <text>If any observer method of the |AfterBeanDiscovery| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
  </section>

  <section id="11.5.3" title="AfterDeploymentValidation event">
    <assertion id="a">
      <text>The container must fire a third event after it has validated that there are no deployment problems and before creating contexts or processing requests. The event object must be of type |javax.enterprise.inject.spi.AfterDeploymentValidation|.</text>
    </assertion>

    <assertion id="b">
      <text>|addDeploymentProblem()| registers a deployment problem with the container, causing the container to abort deployment after all observers have been notified.</text>
    </assertion>

    <assertion id="c">
      <text>If any observer method of the |AfterDeploymentValidation| event throws an exception, the exception is treated as a deployment problem by the container.</text>
    </assertion>

    <assertion id="d">
      <text>The container must not allow any request to be processed by the deployment until all observers of this event return.</text>
    </assertion>
  </section>

  <section id="11.5.4" title="BeforeShutdown event">
    <assertion id="a">
      <text>The container must fire a final event after it has finished processing requests and destroyed all contexts. The event object must be of type |javax.enterprise.inject.spi.BeforeShutdown|.</text>
    </assertion>

    <assertion id="ba">
      <text>If any observer method of the |BeforeShutdown| event throws an exception, the exception is ignored by the container.</text>
    </assertion>
  </section>

  <section id="11.5.5" title="ProcessAnnotatedType event">
    <assertion id="a">
      <text>The container must fire an event for each Java class it discovers in a bean archive, before it reads the declared annotations. The event object must be of type |javax.enterprise.inject.spi.ProcessAnnotatedType&lt;X&gt;|, where |X| is the class.</text>
    </assertion>

    <assertion id="ba">
      <text>|getAnnotatedType()| returns the |AnnotatedType| object that will be used by the container to read the declared annotations.</text>
    </assertion>
    
    <assertion id="bb">
      <text>|setAnnotatedType()| replaces the |AnnotatedType|.</text>
    </assertion>
    
    <assertion id="bc">
      <text>|veto()| forces the container to ignore the type.</text>
    </assertion>

    <assertion id="ca">
      <text>Any observer of this event is permitted to wrap and/or replace the |AnnotatedType|.  The container must use the final value of this property, after all observers have been called, to discover the types and read the annotations of the program elements.</text>
    </assertion>
    
    <assertion id="e">
      <text>If any observer method of a |ProcessAnnotatedType| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
  </section>

  <section id="11.5.6" title="ProcessInjectionTarget event">
   <group>
      <text>The container must fire an event for every Java EE component class supporting injection that may be instantiated by the container at runtime, including every managed bean declared using |@ManagedBean|, EJB session or message-driven bean, enabled bean, enabled interceptor or enabled decorator.</text>
      <assertion id="aaa">
         <text>Test event is fired for a managed bean</text>
      </assertion>
      <assertion id="aab">
         <text>Test event is fired for a session bean</text>
      </assertion>
      <assertion id="aac">
        <text>Test event is fired for a servlet listener</text>
      </assertion>
      <assertion id="aad">
        <text>Test event is fired for a tag handler</text>
      </assertion>
      <assertion id="aae">
        <text>Test event is fired for a tag library listener</text>
      </assertion>
      <assertion id="aaf">
        <text>Test event is fired for an EJB Interceptor</text>
      </assertion>
      <assertion id="aag">
        <text>Test event is fired for a WS endpoint</text>
      </assertion>
      <assertion id="aah">
        <text>Test event is fired for a servlet</text>
      </assertion>
      <assertion id="aai">
        <text>Test event is fired for a filter</text>
      </assertion>
      <assertion id="aal">
         <text>Test type for a managed bean</text>
      </assertion>
      <assertion id="aam">
         <text>Test type for a session bean</text>
      </assertion>
      <assertion id="aan">
        <text>Test type for a servlet listener</text>
      </assertion>
      <assertion id="aao">
        <text>Test type for a tag handler</text>
      </assertion>
      <assertion id="aap">
        <text>Test type for a tag library listener</text>
      </assertion>
      <assertion id="aaq">
        <text>Test type for an EJB Interceptor</text>
      </assertion>
      <assertion id="aar">
        <text>Test type for a WS endpoint</text>
      </assertion>
      <assertion id="aas">
        <text>Test type for a servlet</text>
      </assertion>
      <assertion id="aat">
        <text>Test type for a filter</text>
      </assertion>
    </group>
    
    <assertion id="aaz">
      <text>The event object must be of type |javax.enterprise.inject.spi.ProcessInjectionTarget&lt;X&gt;|, where |x| is the managed bean class, session bean class or Java EE component class supporting injection.</text>
    </assertion>
    
    <group>
      <text>|getAnnotatedType()| returns the |AnnotatedType| representing the managed bean class, session bean or other Java EE component class supporting injection.</text>
      <assertion id="aba">
         <text>Test type for a managed bean</text>
      </assertion>
      <assertion id="abb">
         <text>Test type for a session bean</text>
      </assertion>
      <assertion id="abc">
        <text>Test type for a servlet listener</text>
      </assertion>
      <assertion id="abd">
        <text>Test type for a tag handler</text>
      </assertion>
      <assertion id="abe">
        <text>Test type for a tag library listener</text>
      </assertion>
      <assertion id="abf">
        <text>Test type for an EJB Interceptor</text>
      </assertion>
      <assertion id="abg">
        <text>Test type for a WS endpoint</text>
      </assertion>
      <assertion id="abh">
        <text>Test type for a servlet</text>
      </assertion>
      <assertion id="abi">
        <text>Test type for a filter</text>
      </assertion>
    </group>
    
    <assertion id="ba">
      <text>|getInjectionTarget()| returns the |InjectionTarget| object that will be used by the container to perform injection.</text>
    </assertion>
    
    <assertion id="bb">
      <text>|setInjectionTarget()| replaces the |InjectionTarget|.</text>
    </assertion>

    <assertion id="da">
      <text>|addDefinitionError()| registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</text>
    </assertion>

    <group>
      <text>Any observer of this event is permitted to wrap and/or replace the |InjectionTarget|.  The container must use the final value of this property, after all observers have been called, whenever it performs injection upon the managed bean, session bean or other Java EE component class supporting injection.</text>
      <assertion id="ea">
         <text>Test type for a managed bean</text>
      </assertion>
      <assertion id="eb">
         <text>Test type for a session bean</text>
      </assertion>
      <assertion id="ec">
        <text>Test type for a servlet listener</text>
      </assertion>
      <assertion id="ed">
        <text>Test type for a tag handler</text>
      </assertion>
      <assertion id="ee">
        <text>Test type for a tag library listener</text>
      </assertion>
      <assertion id="ef">
        <text>Test type for an EJB Interceptor</text>
      </assertion>
      <assertion id="eg">
        <text>Test type for a WS endpoint</text>
      </assertion>
      <assertion id="eh">
        <text>Test type for a servlet</text>
      </assertion>
      <assertion id="ei">
        <text>Test type for a filter</text>
      </assertion>
    </group>
    
    <assertion id="f">
      <text>If any observer method of a |ProcessInjectionTarget| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
  </section>
  
  <section id="11.5.7" title="ProcessProducer event">
    <group>
      <text>The container must fire an event for each producer method or field of each enabled bean, including resources.</text>
      <assertion id="aa">
        <text>Test producer method</text>
      </assertion>
      <assertion id="ab">
        <text>Test producer field</text>
      </assertion>
      <assertion id="ac">
        <text>Test resource producer field</text>
      </assertion>
    </group>
    
    <group>
      <text>The event object must be of type |javax.enterprise.inject.spi.ProcessProducer&lt;T, X&gt;|, where |T| is the bean class of the bean that declares the producer method or field and |X| is the return type of the producer method or the type of the producer field.</text>
      <assertion id="ba">
        <text>Test producer method</text>
      </assertion>
      <assertion id="bb">
        <text>Test producer field</text>
      </assertion>
    </group>
   
    <group>
      <text>|getAnnotatedMember()| returns the |AnnotatedField| representing the producer field or the |AnnotatedMethod| representing the producer method.</text>
      <assertion id="ca">
        <text>Test producer method</text>
      </assertion>
      <assertion id="cb">
        <text>Test producer field</text>
      </assertion>
    </group>
    
    <group>
      <text>|getProducer()| returns the |Producer| object that will be used by the container to call the producer method or read the producer field.</text>
      <assertion id="da">
        <text>Test producer method</text>
      </assertion>
      <assertion id="db">
        <text>Test producer field</text>
      </assertion>
    </group>
    
    <assertion id="e">
      <text>|setProducer()| replaces the |Producer|.</text>
    </assertion>
    
    <assertion id="f">
      <text>|addDefinitionError()| registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</text>
    </assertion>
    
    <group>
      <text>Any observer of this event is permitted to wrap and/or replace the |Producer|. The container must use the final value of this property, after all observers have been called, whenever it calls the producer or disposer.</text>
      <assertion id="ga">
        <text>Test producer method</text>
      </assertion>
      <assertion id="gb">
        <text>Test producer field</text>
      </assertion>
    </group>
    
    <assertion id="h">
      <text>If any observer method of a |ProcessProducer| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
  </section>

  <section id="11.5.8" title="ProcessBean event">
    <assertion id="aa" testable="false">
      <text>The container must fire an event for each enabled bean, interceptor or decorator deployed in a bean archive, before registering the |Bean| object.  No event is fired for any |@New| qualified bean, defined in Section 3.12, "@New qualified beans".</text>
      <note>Tested below</note>
    </assertion>

    <assertion id="ba">
      <text>For a managed bean with bean class |X|, the container must raise an event of type |ProcessManagedBean&lt;X&gt;|.</text>
    </assertion>

    <assertion id="c">
      <text>For a session bean with bean class |X|, the container must raise an event of type |ProcessSessionBean&lt;X&gt;|.</text>
    </assertion>

    <assertion id="eaa">
      <text>For a producer method with method return type |X| of a bean with bean class |T|, the container must raise an event of type |ProcessProducerMethod&lt;T, X&gt;|.</text>
    </assertion>
    
    <assertion id="eb">
      <text>For a producer field with field type |X| of a bean with bean class |T|, the container must raise an event of type |ProcessProducerField&lt;T, X&gt;|.</text>
    </assertion>
    
    <assertion id="ec">
      <text>Resources are considered to be producer fields.</text>
    </assertion>
    
    <group>
      <text>The interface |javax.enterprise.inject.spi.ProcessBean| is a supertype of all these event types.</text>
      <assertion id="eda">
         <text>Test |ProcessManagedBean|</text>
      </assertion>
      <assertion id="edb">
         <text>Test |ProcessSessionBean|</text>
      </assertion>
      <assertion id="edc">
         <text>Test |ProcessProducerMethod|</text>
      </assertion>
      <assertion id="edd">
         <text>Test |ProcessProducerField|</text>
      </assertion>
    </group>
   
    <group>
      <text>|getAnnotated()| returns the |AnnotatedType| representing the bean class, the |AnnotatedMethod| representing the producer method, or the |AnnotatedField| representing the producer field.</text>
      <assertion id="efa">
         <text>Test |ProcessManagedBean|</text>
      </assertion>
      <assertion id="efb">
         <text>Test |ProcessSessionBean|</text>
      </assertion>
      <assertion id="efc">
         <text>Test |ProcessProducerMethod|</text>
      </assertion>
      <assertion id="efd">
         <text>Test |ProcessProducerField|</text>
      </assertion>
    </group>

    <group>
      <text>|getBean()| returns the |Bean| object that is about to be registered.  The |Bean| may implement |Interceptor| or |Decorator|.</text>
      <assertion id="fa">
         <text>Test |ProcessManagedBean|</text>
      </assertion>
      <assertion id="fb">
         <text>Test |ProcessSessionBean|</text>
      </assertion>
      <assertion id="fc">
         <text>Test |ProcessProducerMethod|</text>
      </assertion>
      <assertion id="fd">
         <text>Test |ProcessProducerField|</text>
      </assertion>
    </group>
    
    <assertion id="h">
      <text>|addDefinitionError()| registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</text>
    </assertion>
    
    <assertion id="hb">
      <text>|getEjbName()| returns the EJB name of the session bean.</text>
    </assertion>
    
    <assertion id="hc">
      <text>|getSessionBeanType()| returns a |javax.enterprise.inject.spi.SessionBeanType| representing the kind of session bean.</text>
    </assertion>
    
    <assertion id="hd">
      <text>If any observer method of a |ProcessBean| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
    
    <assertion id="i" implied="true">
      <text>Check the |getAnnotatedProducerMethod()|</text>
    </assertion>
    
    <assertion id="j" implied="true">
      <text>Check the |getAnnotatedDisposesParameter()|</text>
    </assertion>
    
    <assertion id="k" implied="true">
      <text>Check the |getAnnotatedSessionBeanClass()|</text>
    </assertion>
    
    <group>
      <text>Check the |getAnnotatedBeanClass()|</text>
      <assertion id="l" implied="true">
         <text>Check for managed bean</text>
      </assertion>
      <assertion id="m" implied="true">
         <text>Check for session bean</text>
      </assertion>
    </group>
    
    <assertion id="n" implied="true">
      <text>Check the |getAnnotatedProducerField()|</text>
    </assertion>
    
  </section>

  <section id="11.5.9" title="ProcessObserverMethod event">
    <assertion id="aaa">
    <text>The container must fire an event for each observer method of each enabled bean, before registering the |ObserverMethod| object.  The event object must be of type |javax.enterprise.inject.spi.ProcessObserverMethod&lt;T, X&gt;| where |T| is the bean class of the bean that declares the observer method and |X| is the observed event type of the observer method.</text>
    </assertion>

    <assertion id="aba">
    <text>|getAnnotatedEventParameter()| returns the |AnnotatedParameter| representing the event parameter.</text>
    </assertion>
    
    <assertion id="ba">
      <text>|getObserverMethod()| returns the |ObserverMethod| object that will be used by the container to call the observer method.</text>
    </assertion>

    <assertion id="da">
      <text>|addDefinitionError()| registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</text>
    </assertion>
    
    <assertion id="db">
      <text>If any observer method of a |ProcessObserverMethod| event throws an exception, the exception is treated as a definition error by the container.</text>
    </assertion>
  </section>

  <section id="12" title="Packaging and Deployment">

  </section>

  <section id="12.1" title="Bean deployment archives">
    <assertion id="aa" testable="false">
      <text>Bean classes of enabled beans must be deployed in bean archives.</text>
    </assertion>
    
    <assertion id="a" testable="false">
      <text>A library jar, EJB jar, application client jar or rar archive is a bean archive if it has a file named |beans.xml| in the |META-INF| directory.</text>
    </assertion>
    
    <assertion id="ab" testable="false">
      <text>The |WEB-INF/classes| directory of a war is a bean archive if there is a file named |beans.xml| in the |WEB-INF| directory of the war.</text>
    </assertion>
    
    <assertion id="ac" testable="false">
      <text>A directory in the JVM classpath is a bean deployment archive if it has a file named |beans.xml| in the |META-INF| directory.</text>
      <note>covered in bb*, bc*, bd*</note>
    </assertion>

    <assertion id="b" testable="false">
      <text>The container is not required to support application client jar bean archives.</text>
    </assertion>

    <assertion id="ba" testable="false">
      <text>The container searches for beans in all bean archives in the application classpath.</text>
      <note>covered in bb*, bc*, bd*</note>
    </assertion>
    
    <group>
      <text>In an application deployed as an ear, the container searches every bean archive bundled with or referenced by the ear, including bean archives bundled with or referenced by wars and EJB jars contained in the ear. The bean archives might be library jars, EJB jars, rars or war |WEB-INF/classes| directories.</text>
      <assertion id="bba">
         <text>Check an EJB jar in an EAR</text>
      </assertion>
      <assertion id="bbb">
         <text>Check a bundled library in an EAR</text>
      </assertion>
      <assertion id="bbc">
         <text>Check a bundled library in a WAR</text>
      </assertion>
      <assertion id="bbd">
         <text>Check a rar</text>
      </assertion>
      <assertion id="bbe">
         <text>Check a war in an ear</text>
      </assertion>
      <assertion id="bbf">
         <text>Check for a jar installed as a library</text>
      </assertion>
    </group>
    
    <group>
      <text>In an application deployed as a war, the container searches every bean archive bundled with or referenced by the war. The bean archives might be library jars or the |WEB-INF/classes| directory.</text>
      <assertion id="bca">
         <text>Check classes in the war</text>
      </assertion>
      <assertion id="bcb">
         <text>Check bundled libraries in the war</text>
      </assertion>
      <assertion id="bcc">
         <text>Check for a jar installed as a library</text>
      </assertion>
    </group>
    
    <group>
      <text>In an application deployed as an EJB jar, the container searches the EJB jar, if it is a bean archive, and every bean archive referenced by the EJB jar.</text>
      
      <assertion id="bcd">
        <text>Check classes in the jar.</text>
      </assertion>
    </group>
    
    <group>
      <text>An embeddable EJB container searches each bean archive in the JVM classpath that is listed in the value of the embeddable container initialization property |javax.ejb.embeddable.modules|, or every bean archive in the JVM classpath if the property is not specified. The bean archives might be directories, library jars or EJB jars.</text>
      <assertion id="bda" testable="false">
         <text>Check modules specified by |javax.ejb.embeddable.modules|</text>
         <note>1.0 release of the TCK does not cover embeddable EJB</note>
      </assertion>
      <assertion id="bdb" testable="false">
         <text>Check libraries</text>
         <note>1.0 release of the TCK does not cover embeddable EJB</note>
      </assertion>
      <assertion id="bdc" testable="false">
         <text>Check directories</text>
         <note>1.0 release of the TCK does not cover embeddable EJB</note>
      </assertion>
      <assertion id="bda" testable="false">
         <text>Check ejb jars</text>
         <note>1.0 release of the TCK does not cover embeddable EJB</note>
      </assertion>
    </group>   
    
    <assertion id="be" testable="false">
      <text>When searching for beans, the container considers any Java class in any bean archive, any |ejb-jar.xml| file in the metadata directory of any EJB bean archive, any Java class referenced by the |@New| qualifier of an injection point of another bean, and any interceptor or decorator class declared in the |beans.xml| file of any bean archive.</text>
      <note>covered in bb*, bc*, bd*</note>
    </assertion>
    
    <assertion id="d" testable="false">
      <text>If a bean class is deployed in two different bean archives, non-portable behaviour results.  Portable applications must deploy each bean class in no more than one bean archive.</text>
      <note>Describes undefined behavior</note>
    </assertion>
  </section>

  <section id="12.2" title="Application initialization lifecycle">
    <assertion id="a" testable="false">
      <text>When an application is started, the container performs the following steps.</text>
      <note>Description</note>
    </assertion>

    <assertion id="b">
      <text>First, the container must search for service providers for the service |javax.enterprise.inject.spi.Extension| defined in Section 11.5, "Container lifecycle events", instantiate a single instance of each service provider, and search the service provider class for observer methods of initialization events.</text>
    </assertion>

    <assertion id="c">
      <text>Next, the container must fire an event of type |BeforeBeanDiscovery|, as defined in Section 11.5.1, "BeforeBeanDiscovery event".</text>
    </assertion>

    <group>
      <text>Next, the container must perform bean discovery, and abort initialization of the application if any definition errors exist, as defined in Section 2.8, "Problems detected automatically by the container".  Additionally, for every Java EE component class supporting injection that may be instantiated by the container at runtime, the container must create an |InjectionTarget| for the class, as defined in 11.2, "The Producer and InjectionTarget interfaces", and fire an event of type ProcessInjectionTarget, as defined in Section 11.5.6, "ProcessInjectionTarget event".</text>
      
      <assertion id="da">
         <text>Check beans are discovered</text>
      </assertion>
      <assertion id="db">
         <text>
            Check definitions errors occur
         </text>
      </assertion>
    </group>
    

    <assertion id="e">
      <text>Next, the container must fire an event of type |AfterBeanDiscovery|, as defined in Section 11.5.2, "AfterBeanDiscovery event", and abort initialization of the application if any observer registers a definition error.</text>
    </assertion>

    <assertion id="f">
      <text>Next, the container must detect deployment problems by validating bean dependencies and specialization and abort initialization of the application if any deployment problems exist, as defined in Section 2.8, "Problems detected automatically by the container".</text>
    </assertion>

    <assertion id="g">
      <text>Next, the container must fire an event of type |AfterDeploymentValidation|, as defined in Section 11.5.3, "AfterDeploymentValidation event", and abort initialization of the application if any observer registers a deployment problem.</text>
    </assertion>

    <assertion id="h">
      <text>Finally, the container begins directing requests to the application.</text>
      <note>Can only check the inverse, that requests aren't directed to the application before</note>
    </assertion>
  </section>

  <section id="12.3" title="Bean discovery">
    <assertion id="a" testable="false">
      <text>The container automatically discovers managed beans (according to the rules of Section 3.1.1, "Which Java classes are managed beans?") and session beans in bean archives and searches the bean classes for producer methods, producer fields, disposer methods and observer methods.</text>
      <note>Statement of intent</note>
    </assertion>

    <group>
      <text>For each Java class or interface deployed in a bean archive, the container must create an |AnnotatedType| representing the type and fire an event of type |ProcessAnnotatedType|, as defined in Section 11.5.5, "ProcessAnnotatedType event".</text>
      <assertion id="ba">
        <text>Check managed bean</text>  
      </assertion>
      <assertion id="bb">
        <text>Check session bean</text>  
      </assertion>
      <assertion id="bc">
        <text>Check non-contextual session bean</text>
      </assertion>
      <assertion id="bd">
        <text>Check JSF managed beans</text>
      </assertion>
      <assertion id="be">
        <text>Check servlet listener</text>
      </assertion>
      <assertion id="bf">
        <text>Check tag handler</text>
      </assertion>
      <assertion id="bg">
        <text>Check tag library listener</text>
      </assertion>
      <assertion id="bh">
        <text>Check EJB Interceptor</text>
      </assertion>
      <assertion id="bi">
        <text>Check WS endpoint</text>
      </assertion>
      <assertion id="bj">
        <text>Check servlet</text>
      </assertion>
      <assertion id="bk">
        <text>Check filter</text>
      </assertion>
    </group>

    <assertion id="c" testable="false">
      <text>For each Java class in any bean archive, the container must inspect the type metadata to determine if it is a bean or other Java EE component class supporting injection.</text>
      <note>No consequence</note>
    </assertion>

    <assertion id="d" testable="false">
      <text>For each Java class in any bean archive, the container must detect definition errors by validating the class and its metadata.</text>
      <note>Tested elsewhere</note>
    </assertion>

    <group>   
      <text>For each Java class in any bean archive, the container must, if the class is a managed bean, session bean, or other Java EE component class supporting injection, create an |InjectionTarget| for the class, as defined in Section 11.2, "The Producer and InjectionTarget interfaces", and fire an event of type |ProcessInjectionTarget|, as defined in Section 11.5.6, "ProcessInjectionTarget event"</text>
      <assertion id="da">
        <text>Check managed bean</text>  
      </assertion>
      <assertion id="db">
        <text>Check session bean</text>  
      </assertion>
      <assertion id="dc">
        <text>Check non-contextual session bean</text>
      </assertion>
      <assertion id="dd">
        <text>Check JSF managed beans</text>
      </assertion>
      <assertion id="de">
        <text>Check servlet listener</text>
      </assertion>
      <assertion id="df">
        <text>Check tag handler</text>
      </assertion>
      <assertion id="dg">
        <text>Check tag library listener</text>
      </assertion>
      <assertion id="dh">
        <text>Check EJB Interceptor</text>
      </assertion>
      <assertion id="di">
        <text>Check WS endpoint</text>
      </assertion>
      <assertion id="dj">
        <text>Check servlet</text>
      </assertion>
      <assertion id="dk">
        <text>Check filter</text>
      </assertion>
    </group>

    <group>
      <text>For each Java class in any bean archive, the container must, if the class is an enabled bean, interceptor or decorator, create a |Bean| object that implements the rules defined in Section 7.3.1, "Lifecycle of managed beans", Section 7.3.2, "Lifecycle of stateful session beans" or Section 7.3.3, "Lifecycle of stateless session and singleton beans", and fire an event which is a subtype of |ProcessBean|, as defined in Section 11.5.8, "ProcessBean event".</text>
      <assertion id="fa">
        <text>Check a managed bean</text>
      </assertion>
      <assertion id="fb">
        <text>Check a session bean</text>
      </assertion>
    </group>
    
    <group>
      <text>For each enabled bean, the container must search the class for producer methods and fields, including resources, and for each producer method or field create a |Producer|, as defined in Section 11.2, "The Producer and InjectionTarget interfaces", and fire an event of type |ProcessProducer|, as defined in Section 11.5.7, "ProcessProducer event", and then if the producer method or field is enabled, create a |Bean| object that implements the rules defined in Section 7.3.4, "Lifecycle of producer methods", Section 7.3.5, "Lifecycle of producer fields" or Section 7.3.6, "Lifecycle of resources", and fire an event which is a subtype of |ProcessBean|, as defined  in Section 11.5.8, "ProcessBean event".</text>
      <assertion id="ha">
        <text>
          Check a producer method
        </text>
      </assertion>
      <assertion id="hb">
        <text>
          Check a producer field
        </text>
      </assertion>
    </group>
    
    
    <assertion id="i">
      <text>For each enabled bean, the container must search the class for observer methods, and for each observer method create an |ObserverMethod| object, as defined in Section 11.1.3, "The ObserverMethod interface" and fire an event of type |ProcessObserverMethod|, as defined in Section 11.5.9, "ProcessObserverMethod event".</text>
    </assertion>

    <group>
      <text>The container determines which alternatives, interceptors and decorators are enabled, according to the rules defined in Section 5.1.2, "Enabled and disabled beans", Section 9.4, "Interceptor enablement and ordering" and Section 8.2, "Decorator enablement and ordering", taking into account any |&lt;enable&gt;|, |&lt;interceptors&gt;| and |&lt;decorators&gt;| declarations in the |beans.xml| files, and registers the |Bean| and |ObserverMethod| objects.</text>
      <assertion id="ka">
        <text>Check only beans for enabled policies registered</text>
      </assertion>
      <assertion id="kb">
        <text>Check only enabled interceptors registered</text>
      </assertion>
      <assertion id="kc">
        <text>Check only enabled decorators registered</text>
      </assertion>
    </group>
    
    <assertion id="l" testable="false">
      <text>For each enabled bean that is not an interceptor or decorator, the container registers an instance of the |Bean| interface defined in Section 11.1, "The Bean interface".</text>
      <note>Checked above</note>
    </assertion>

    <assertion id="m" testable="false">
      <text>For each enabled interceptor, the container registers an instance of the |Interceptor| interface as defined in Section 11.1.2, "The Interceptor interface".</text>
      <note>Checked above</note>
    </assertion>

    <assertion id="n" testable="false">
      <text>For each enabled decorator, the container registers an instance of the |Decorator| interface defined in Section 11.1.1, "The Decorator interface".</text>
      <note>Checked above</note>
    </assertion>

    <assertion id="o">
      <text>For each observer method of every enabled bean, the container registers an instance of the |ObserverMethod| interface defined in Section 11.1.3, "The ObserverMethod interface".</text>
    </assertion>
  </section>
  
  <section id="12.4" title="Integration with Unified EL">
    <assertion id="a">
      <text>The container must provide a Unified EL |ELResolver| to the servlet engine and JSF implementation that resolves bean EL names using the rules of name resolution defined in 5.3, "EL name resolution" and resolving ambiguities according to Section 5.3.1, "Ambiguous EL names".</text>
    </assertion>

    <assertion id="c">
      <text>If a name used in an EL expression does not resolve to any bean, the |ELResolver| must return a null value.</text>
    </assertion>
    
    <assertion id="b">
      <text>If a name used in an EL expression resolves to more than one bean, the |ELResolver| must throw an |AmbiguousResolutionException|.</text>
    </assertion>
    
    <assertion id="d">
      <text>Otherwise, if a name used in an EL expression resolves to exactly one bean, the |ELResolver| must return a contextual instance of the bean, as defined in Section 6.5.2, "Contextual instance of a bean".</text>
    </assertion>
  </section>

</specification>
